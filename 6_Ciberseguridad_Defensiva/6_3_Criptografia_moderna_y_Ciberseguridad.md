| **Inicio**         | **atr√°s 2**                                               | **Siguiente 4**                                         |
| ------------------ | --------------------------------------------------------- | ------------------------------------------------------- |
| [üè†](../README.md) | [‚è™](./6_2_Criptografia_y_Ciberseguridad_Introduccion.md) | [‚è©](./6_4_CiberSeguridad_de_los_datos_Data_Scurity.md) |

---

## **√çndice**

| Temario                                                                                                                                                 |
| ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [398. Criptosistemas sim√©tricos modernos](#398-criptosistemas-sim√©tricos-modernos)                                                                      |
| [399. Stream Ciphers](#399-stream-ciphers)                                                                                                              |
| [400. El tama√±o del Keystream](#400-el-tama√±o-del-keystream)                                                                                            |
| [401. Propiedades de los Stream Ciphers](#401-propiedades-de-los-stream-ciphers)                                                                        |
| [402. Stream Ciphers populares](#402-stream-ciphers-populares)                                                                                          |
| [403. RC4](#403-rc4)                                                                                                                                    |
| [404. RC4 en la pr√°ctica](#404-rc4-en-la-pr√°ctica)                                                                                                      |
| [405. Implementa RC4 en Python](#405-implementa-rc4-en-python)                                                                                          |
| [406. Ataques a RC4](#406-ataques-a-rc4)                                                                                                                |
| [407. ChaCha20](#407-chacha20)                                                                                                                          |
| [408. Funcionamiento de ChaCha20](#408-funcionamiento-de-chacha20)                                                                                      |
| [409. Caso Pr√°ctico: ChaCha20](#409-caso-pr√°ctico-chacha20)                                                                                             |
| [410. Block Ciphers](#410-block-ciphers)                                                                                                                |
| [411. Propiedades de los Block Ciphers](#411-propiedades-de-los-block-ciphers)                                                                          |
| [412. Block Ciphers populares](#412-block-ciphers-populares)                                                                                            |
| [413. DES (Data Encryption Standard)](#413-des-data-encryption-standard)                                                                                |
| [414. Detalles del funcionamiento de DES](#414-detalles-del-funcionamiento-de-des)                                                                      |
| [415. Ataques a DES](#415-ataques-a-des)                                                                                                                |
| [416. Triple DES](#416-triple-des)                                                                                                                      |
| [417. AES (Advanced Encryption Standard)](#417-aes-advanced-encryption-standard)                                                                        |
| [418. Detalles de las funciones de AES](#418-detalles-de-las-funciones-de-aes)                                                                          |
| [419. Caso pr√°ctico: AES](#419-caso-pr√°ctico-aes)                                                                                                       |
| [420. Initialization Vector (IV)](#420-initialization-vector-iv)                                                                                        |
| [421. Modos de operaci√≥n: ECB](#421-modos-de-operaci√≥n-ecb)                                                                                             |
| [422. Modos de operaci√≥n: CBC](#422-modos-de-operaci√≥n-cbc)                                                                                             |
| [423. Modos de operaci√≥n: CFB](#423-modos-de-operaci√≥n-cfb)                                                                                             |
| [424. Modos de operaci√≥n: OFB](#424-modos-de-operaci√≥n-ofb)                                                                                             |
| [425. Modos de operaci√≥n: CTR](#425-modos-de-operaci√≥n-ctr)                                                                                             |
| [426. Cu√°ndo usar criptosistemas sim√©tricos](#426-cu√°ndo-usar-criptosistemas-sim√©tricos)                                                                |
| [427. Criptosistemas asim√©tricos o de clave p√∫blica](#427-criptosistemas-asim√©tricos-o-de-clave-p√∫blica)                                                |
| [428. Diffie Hellman: Intercambio de claves](#428-diffie-hellman-intercambio-de-claves)                                                                 |
| [429. RSA](#429-rsa)                                                                                                                                    |
| [430. Generando un par de claves RSA con OpenSSL](#430-generando-un-par-de-claves-rsa-con-openssl)                                                      |
| [431. Curvas el√≠pticas](#431-curvas-el√≠pticas)                                                                                                          |
| [432. Computaci√≥n cu√°ntica: Un viaje hacia una nueva era en la criptograf√≠a](#432-computaci√≥n-cu√°ntica-un-viaje-hacia-una-nueva-era-en-la-criptograf√≠a) |

---

# **Criptografia moderna y Ciberseguridad**

## **398. Criptosistemas sim√©tricos modernos**

### üß† ¬øQu√© es un Criptosistema Sim√©trico?

Un **criptosistema sim√©trico** es un sistema de cifrado donde **la misma clave se usa para cifrar y descifrar** la informaci√≥n.

#### üîê Caracter√≠sticas clave:

| Caracter√≠stica         | Descripci√≥n                                                    |
| ---------------------- | -------------------------------------------------------------- |
| Clave √∫nica compartida | El emisor y el receptor usan la **misma clave secreta**.       |
| R√°pido                 | Son **muy eficientes** para cifrar grandes vol√∫menes de datos. |
| Seguro (si bien usado) | Ofrece buena seguridad si se protege la clave.                 |

---

### üèõÔ∏è Ejemplos de criptosistemas sim√©tricos modernos:

| Algoritmo      | Descripci√≥n breve                                      |
| -------------- | ------------------------------------------------------ |
| **AES**        | Est√°ndar de cifrado avanzado. El m√°s usado hoy en d√≠a. |
| **DES**        | Algoritmo m√°s antiguo, ahora considerado inseguro.     |
| **Triple DES** | Variaci√≥n de DES m√°s segura.                           |
| **ChaCha20**   | Alternativa moderna a AES, muy usada en m√≥viles y VPN. |
| **Blowfish**   | Algoritmo r√°pido, √∫til para contrase√±as.               |

El m√°s usado hoy en d√≠a es **AES (Advanced Encryption Standard)**, y es el que veremos en el ejemplo.

---

### üß™ ¬øC√≥mo funciona AES (por ejemplo)?

Imagina que quieres enviar el mensaje `"HOLA MUNDO"` y ambos t√∫ y tu amigo tienen esta **clave secreta compartida**:

```
Clave: "clave_super_secreta123"
```

El algoritmo AES toma el mensaje, lo convierte en bloques binarios, los mezcla, los revuelve y los transforma en un texto ilegible (cifrado). Solo con la misma clave podr√°s devolverlo a su forma original (descifrado).

---

### üîß ¬øC√≥mo se ‚Äúinstala‚Äù o se usa?

Usaremos **Python** con la librer√≠a `cryptography`, que es moderna, segura y f√°cil de usar.

#### üîπ Paso 1: Instalar la librer√≠a

Abre la terminal o consola de comandos y escribe:

```bash
pip install cryptography
```

---

### üíª Ejemplo completo de cifrado y descifrado con AES

Vamos a cifrar y descifrar el mensaje `"HOLA MUNDO"` usando AES con clave sim√©trica.

#### üìÑ C√≥digo en Python:

```python
from cryptography.fernet import Fernet

# 1. Generamos una clave sim√©trica
clave = Fernet.generate_key()
cipher = Fernet(clave)

# 2. Mensaje original
mensaje = "HOLA MUNDO".encode()

# 3. Cifrado del mensaje
mensaje_cifrado = cipher.encrypt(mensaje)

# 4. Descifrado del mensaje
mensaje_descifrado = cipher.decrypt(mensaje_cifrado)

# 5. Mostrar resultados
print("Clave secreta:", clave.decode())
print("Mensaje original:", mensaje.decode())
print("Mensaje cifrado:", mensaje_cifrado.decode())
print("Mensaje descifrado:", mensaje_descifrado.decode())
```

#### üßæ Posible salida:

```
Clave secreta: pJrfkUSuol6hxTIGfDnONrkwK9ArX4HeYTbNRITywh4=
Mensaje original: HOLA MUNDO
Mensaje cifrado: gAAAAABkgn7e9tUdcZK...
Mensaje descifrado: HOLA MUNDO
```

---

### üõ°Ô∏è Ventajas de los Criptosistemas Sim√©tricos Modernos

- ‚úÖ Muy r√°pidos
- ‚úÖ Buenos para cifrar archivos, bases de datos, discos duros
- ‚úÖ Usados en HTTPS, VPNs, Wi-Fi (WPA2/WPA3), backups, etc.

---

### ‚ö†Ô∏è Desventajas

- ‚ùå **Debes proteger muy bien la clave** (si alguien la obtiene, todo se puede descifrar).
- ‚ùå No sirven bien para sistemas de comunicaci√≥n abiertos como correo sin una segunda capa (como criptograf√≠a asim√©trica).

---

### üß≠ ¬øCu√°ndo usar criptograf√≠a sim√©trica?

| Uso                                   | Recomendado                           |
| ------------------------------------- | ------------------------------------- |
| Cifrar archivos en tu disco duro      | ‚úÖ S√≠                                 |
| Cifrar base de datos o backups        | ‚úÖ S√≠                                 |
| Comunicaci√≥n entre servidores seguros | ‚úÖ S√≠                                 |
| Enviar correos cifrados a extra√±os    | ‚ùå No (mejor usar cifrado asim√©trico) |

---

### ‚úÖ Conclusi√≥n r√°pida

| Pregunta               | Resumen breve                               |
| ---------------------- | ------------------------------------------- |
| ¬øQu√© es?               | Cifrado con una √∫nica clave compartida      |
| ¬øEs seguro?            | S√≠, si proteges la clave                    |
| ¬øQu√© algoritmo se usa? | AES, ChaCha20, Triple DES, Blowfish, etc.   |
| ¬øC√≥mo lo uso?          | Con librer√≠as como `cryptography` en Python |

---

[üîº](#√≠ndice)

---

## **399. Stream Ciphers**

### üîê ¬øQu√© es un Stream Cipher?

Un **stream cipher** o **cifrador de flujo** es un tipo de algoritmo criptogr√°fico **sim√©trico** que **cifra los datos bit por bit o byte por byte**, usando una clave y un generador de flujo.

üîÅ A diferencia de los **block ciphers** (como AES), que cifran los datos en bloques (por ejemplo, de 128 bits), los **stream ciphers** trabajan con datos que van llegando poco a poco, como si fuese una transmisi√≥n en tiempo real.

---

#### üß† ¬øC√≥mo funciona?

1. Se tiene una **clave secreta** (key).
2. Se genera un flujo de bits pseudoaleatorio (keystream).
3. El flujo de bits se combina con el mensaje original (texto claro) usando una operaci√≥n como **XOR** (exclusiva o).
4. Se obtiene un texto cifrado.
5. Para descifrar, se aplica el mismo keystream al texto cifrado con XOR y se recupera el mensaje original.

---

### üì¶ Ejemplo f√°cil

#### Sup√≥n este mensaje:

```
Mensaje: 10110001
Keystream: 11001100
```

Aplicamos XOR (‚äï):

```
Texto cifrado: 01111101
```

Para descifrarlo:

```
01111101 ‚äï 11001100 = 10110001  ‚Üí ¬°recuperamos el mensaje original!
```

---

### üß∞ Ejemplos conocidos de stream ciphers

| Algoritmo    | Uso com√∫n                                             |
| ------------ | ----------------------------------------------------- |
| **RC4**      | Usado antiguamente en SSL/TLS y Wi-Fi (ya no seguro). |
| **ChaCha20** | Reemplazo moderno, r√°pido y seguro.                   |
| **Salsa20**  | Similar a ChaCha20, tambi√©n muy seguro.               |

---

### üìå ¬øCu√°ndo usar un Stream Cipher?

- Cuando se necesita **cifrar en tiempo real** (como llamadas, video, o streaming).
- Cuando los datos **no tienen tama√±o fijo**.
- En aplicaciones con pocos recursos (IoT, m√≥viles).

---

### ‚öôÔ∏è ¬øC√≥mo se instala?

Usaremos **Python** con la librer√≠a `cryptography`, que soporta **ChaCha20**, un stream cipher moderno y seguro.

#### üß™ Instalaci√≥n

Abre la terminal y escribe:

```bash
pip install cryptography
```

---

### üíª Ejemplo completo: ChaCha20 en Python

Vamos a cifrar y descifrar un mensaje con un stream cipher moderno.

#### üìÑ C√≥digo:

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
from cryptography.hazmat.backends import default_backend
import os

# 1. Crear clave de 32 bytes y un nonce (√∫nico por mensaje)
clave = os.urandom(32)
nonce = os.urandom(16)

# 2. Crear el cifrador ChaCha20
algorithm = algorithms.ChaCha20(clave, nonce)
cipher = Cipher(algorithm, mode=None, backend=default_backend())
encryptor = cipher.encryptor()

# 3. Mensaje original
mensaje = b"Hola mundo desde stream cipher!"

# 4. Cifrar
cifrado = encryptor.update(mensaje)

# 5. Descifrar (usar misma clave y nonce)
decryptor = cipher.decryptor()
descifrado = decryptor.update(cifrado)

# 6. Mostrar resultados
print("Clave:", clave.hex())
print("Nonce:", nonce.hex())
print("Mensaje original:", mensaje.decode())
print("Mensaje cifrado:", cifrado.hex())
print("Mensaje descifrado:", descifrado.decode())
```

---

#### üìå Resultado esperado (ejemplo):

```
Clave: d09f...7b
Nonce: 918f...1d
Mensaje original: Hola mundo desde stream cipher!
Mensaje cifrado: 69a12f...
Mensaje descifrado: Hola mundo desde stream cipher!
```

---

### ‚úÖ Ventajas de los stream ciphers

- üîÑ Buen rendimiento para flujos continuos de datos.
- ‚ö° M√°s r√°pidos que muchos block ciphers en algunos contextos.
- üîê Bien dise√±ados (como ChaCha20) son muy seguros.

---

### ‚ö†Ô∏è Desventajas

- ‚ùå Si se reutiliza la clave y el nonce ‚Üí el sistema se rompe.
- ‚ùå RC4 ya **no es seguro** (no usar).

---

### üß≠ Cuadro comparativo: Stream vs Block Cipher

| Caracter√≠stica                      | Stream Cipher | Block Cipher        |
| ----------------------------------- | ------------- | ------------------- |
| Cifra bit/byte a bit                | ‚úÖ S√≠         | ‚ùå No (usa bloques) |
| Cifra en tiempo real                | ‚úÖ Ideal      | ‚ùå Menos eficiente  |
| Vulnerable a reutilizaci√≥n de clave | ‚úÖ S√≠         | ‚úÖ Tambi√©n          |
| Ejemplo moderno                     | ChaCha20      | AES                 |

---

### üéØ Conclusi√≥n

- Los stream ciphers son ideales para comunicaciones en **tiempo real** o **datos de tama√±o variable**.
- El uso de algoritmos modernos como **ChaCha20** es recomendable.
- No reutilices la clave y nonce: eso rompe la seguridad.
- Puedes usarlos f√°cilmente en Python con `cryptography`.

---

[üîº](#√≠ndice)

---

## **400. El tama√±o del Keystream**

### üîê ¬øQu√© es el Keystream?

El **keystream** es un flujo de bits (o bytes) pseudoaleatorio que se **genera a partir de una clave secreta**, y que se **combina con el texto original** (plaintext) para obtener un texto cifrado (ciphertext) en un cifrado de flujo (stream cipher).

Se suele usar una operaci√≥n XOR (`‚äï`) entre el texto original y el keystream:

```
Texto cifrado = Texto original ‚äï Keystream
```

---

### üìè ¬øQu√© significa "tama√±o del Keystream"?

El **tama√±o del keystream** es la **longitud** (en bits o bytes) del flujo generado por el algoritmo criptogr√°fico para cifrar un mensaje.

üîë **Regla importante:**

> üìå **El tama√±o del keystream debe ser igual o mayor al tama√±o del mensaje.**

Porque si el keystream es m√°s corto, **no puedes cifrar todo el mensaje**.

---

### üéì Ejemplo simple paso a paso

Sup√≥n este mensaje (en binario):

```
Mensaje:   10101100 (8 bits)
Keystream: 11010110 (8 bits)
```

Aplicamos XOR bit a bit:

```
Cifrado:   01111010
```

üîÅ Para descifrar, hacemos lo mismo:

```
Cifrado:   01111010
Keystream: 11010110
Original:  10101100
```

‚úÖ ¬°Recuperamos el mensaje original!

---

### ‚ö†Ô∏è ¬øQu√© pasa si el keystream es **m√°s corto**?

Ejemplo:

```
Mensaje:   10101100 01010101 (16 bits)
Keystream: 11010110          (8 bits solamente) ‚ùå
```

‚õî Solo puedes cifrar la **primera mitad** del mensaje. El resto no se puede cifrar, o deber√≠as repetir la clave (lo cual **no es seguro**).

---

### üéØ ¬øPor qu√© es importante?

Un cifrado de flujo seguro (como el **One-Time Pad**) **nunca debe reutilizar la clave ni el keystream**.

**El tama√±o del keystream afecta la seguridad:**

- Si es m√°s corto ‚Üí no puedes cifrar todo.
- Si lo repites ‚Üí pierdes seguridad (puede romperse por ataques estad√≠sticos).

---

### ‚úÖ Buenas pr√°cticas:

1. üîë Aseg√∫rate de que el tama√±o del keystream sea **al menos igual** al tama√±o del mensaje.
2. üîÑ No reutilices el mismo keystream (especialmente con one-time pad).
3. üìè Si el mensaje cambia de longitud, genera un nuevo keystream.

---

### üß∞ ¬øC√≥mo se genera un keystream?

El keystream se genera a partir de:

- Una **clave secreta** (`key`)
- Un **nonce** o n√∫mero √∫nico para cada mensaje

El algoritmo genera un flujo pseudoaleatorio usando esos valores.

---

### üíª Ejemplo completo en Python usando `ChaCha20` (stream cipher moderno)

#### ‚úÖ Requisitos

```bash
pip install cryptography
```

---

#### üßë‚Äçüíª C√≥digo paso a paso:

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
from cryptography.hazmat.backends import default_backend
import os

# 1. Generar una clave de 32 bytes y un nonce de 16 bytes
key = os.urandom(32)
nonce = os.urandom(16)

# 2. Crear algoritmo ChaCha20 (stream cipher)
algorithm = algorithms.ChaCha20(key, nonce)
cipher = Cipher(algorithm, mode=None, backend=default_backend())

# 3. Crear cifrador y descifrador
encryptor = cipher.encryptor()
decryptor = cipher.decryptor()

# 4. Mensaje original
mensaje = b"Hola desde el keystream!"

# 5. Cifrar (esto genera un keystream del mismo tama√±o que el mensaje)
cifrado = encryptor.update(mensaje)

# 6. Descifrar (mismo keystream se usa para recuperar el mensaje)
descifrado = decryptor.update(cifrado)

# 7. Mostrar resultados
print("Mensaje original:", mensaje.decode())
print("Texto cifrado (hex):", cifrado.hex())
print("Mensaje descifrado:", descifrado.decode())
```

---

#### üß™ Resultado esperado:

```
Mensaje original: Hola desde el keystream!
Texto cifrado (hex): a75f79f...
Mensaje descifrado: Hola desde el keystream!
```

---

### üìå Conclusi√≥n

- El **tama√±o del keystream** debe **igualar o superar** al tama√±o del mensaje.
- Si el keystream es **muy corto**, **no se puede cifrar todo el mensaje**.
- En cifradores como **ChaCha20**, el keystream se genera autom√°ticamente y del tama√±o correcto seg√∫n el mensaje.
- **Nunca reutilices el keystream** con diferentes mensajes (es un gran error de seguridad).

---

[üîº](#√≠ndice)

---

## **401. Propiedades de los Stream Ciphers**

### üîê ¬øQu√© es un Stream Cipher?

Un **Stream Cipher** (cifrador de flujo) es un tipo de algoritmo de cifrado **sim√©trico** que **cifra los datos bit a bit o byte a byte**, utilizando un flujo de claves pseudoaleatorias llamadas **keystream**.

Se diferencia de un **Block Cipher** (cifrador por bloques), que cifra los datos por bloques completos (por ejemplo, de 128 bits).

---

### ‚úÖ Propiedades clave de los Stream Ciphers

#### üîÑ **Cifrado en tiempo real (bit a bit o byte a byte)**

- Cifran y descifran los datos **uno por uno**.
- Ideal para transmisi√≥n de datos en tiempo real: voz, video, streaming.

üìå **Ejemplo:** mientras alguien te est√° enviando un mensaje por voz cifrada, cada byte se cifra al momento que se env√≠a.

---

#### üîë **Uso de un Keystream (flujo de claves)**

- Se genera un **flujo de bits pseudoaleatorio** usando una clave secreta.
- El keystream se **combina con el mensaje original** usando una operaci√≥n XOR.

üìå **Ejemplo:**

```
Mensaje original:  11001010
Keystream:         10101010
Cifrado:           01100000  ‚Üê Resultado de XOR
```

---

#### üîÅ **Determinismo**

- Dado el mismo mensaje, clave y nonce, el resultado **siempre ser√° el mismo**.
- Pero si cambias solo el nonce o la clave, el resultado cambia totalmente.

---

#### üß† **Alta eficiencia**

- R√°pidos y requieren **menos recursos computacionales** que block ciphers.
- Muy usados en dispositivos con recursos limitados (como IoT, radios, tarjetas SIM).

---

#### üß∑ **Sensibles al orden y sincronizaci√≥n**

- Si se pierde un bit durante la transmisi√≥n, todo el mensaje posterior puede quedar corrupto.
- Ambos extremos deben estar sincronizados en el flujo de claves.

---

#### üîê **No deben reutilizar el mismo keystream**

- Si se usa el mismo keystream para dos mensajes, un atacante puede recuperar informaci√≥n.

üìå Ejemplo de mal uso (muy importante):

```plaintext
Mensaje1 ‚äï Keystream = Cifrado1
Mensaje2 ‚äï Keystream = Cifrado2

‚Üí Cifrado1 ‚äï Cifrado2 = Mensaje1 ‚äï Mensaje2
```

Esto da **informaci√≥n directa sobre ambos mensajes**.

---

#### üìè **No necesitan padding**

- Como no cifran por bloques, **no es necesario rellenar** el mensaje para que encaje.
- Esto simplifica el dise√±o.

---

#### üß© **Puede usarse con modos de operaci√≥n como CTR o OFB**

Aunque hay stream ciphers dedicados (como RC4, ChaCha20), tambi√©n puedes simular un flujo de claves usando un bloque cifrado en modo **CTR** o **OFB**, que lo convierten en una especie de stream cipher.

---

### üîß ¬øC√≥mo se ‚Äúinstala‚Äù o implementa un stream cipher?

Como no se instala como un programa, lo que realmente haces es **usar una biblioteca de cifrado** (como `cryptography` en Python o `Crypto` en Node.js).

---

### üßë‚Äçüíª Ejemplo completo: Usando ChaCha20 (Stream Cipher moderno) en Python

#### ‚úÖ Requisitos:

```bash
pip install cryptography
```

---

#### üì¶ C√≥digo paso a paso:

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
from cryptography.hazmat.backends import default_backend
import os

# 1. Crear clave (32 bytes para ChaCha20)
clave = os.urandom(32)

# 2. Crear nonce (n√∫mero de uso √∫nico, 16 bytes)
nonce = os.urandom(16)

# 3. Crear cifrador de flujo ChaCha20
algoritmo = algorithms.ChaCha20(clave, nonce)
cifrador = Cipher(algoritmo, mode=None, backend=default_backend())

# 4. Crear objeto para cifrar y descifrar
encryptor = cifrador.encryptor()
decryptor = cifrador.decryptor()

# 5. Mensaje original
mensaje = b"Hola mundo desde stream cipher!"

# 6. Cifrar el mensaje
cifrado = encryptor.update(mensaje)

# 7. Descifrar el mensaje
descifrado = decryptor.update(cifrado)

# 8. Mostrar resultados
print("Mensaje original:", mensaje.decode())
print("Cifrado (hex):", cifrado.hex())
print("Mensaje descifrado:", descifrado.decode())
```

---

#### üß™ Resultado esperado:

```
Mensaje original: Hola mundo desde stream cipher!
Cifrado (hex): 45bfa2...
Mensaje descifrado: Hola mundo desde stream cipher!
```

---

### üß† Conclusi√≥n

**Propiedades importantes de los Stream Ciphers**:

| Propiedad               | Descripci√≥n breve                                 |
| ----------------------- | ------------------------------------------------- |
| Bit a bit / byte a byte | Ideal para tiempo real                            |
| Keystream               | Generado desde una clave, no debe repetirse       |
| R√°pidos                 | Eficientes, ideal para dispositivos peque√±os      |
| Sin padding             | No necesitas rellenar bloques                     |
| Sensibles al orden      | Un bit perdido arruina el resto                   |
| No reutilizar keystream | Rompe la seguridad                                |
| Simples de implementar  | Muy directos en librer√≠as criptogr√°ficas modernas |

---

[üîº](#√≠ndice)

---

## **402. Stream Ciphers populares**

### üß† ¬øQu√© son los Stream Ciphers?

Un **Stream Cipher** es un tipo de cifrado sim√©trico que **cifra los datos bit a bit o byte a byte**, usando una secuencia pseudoaleatoria llamada **keystream**.

Cada bit del texto original se combina con un bit del keystream, normalmente mediante la operaci√≥n XOR.

---

### ‚≠ê Stream Ciphers m√°s populares

Aqu√≠ tienes algunos de los stream ciphers m√°s conocidos y utilizados en la pr√°ctica:

---

#### üîí **RC4 (Rivest Cipher 4)**

- Fue ampliamente usado en SSL/TLS, WEP y WPA.
- Es r√°pido y f√°cil de implementar.
- **Actualmente est√° obsoleto** por vulnerabilidades cr√≠ticas (filtraciones de bytes del keystream).
- Ejemplo de ataque: si se reutiliza la clave, es muy f√°cil romperlo.

üìå **Uso t√≠pico (hist√≥rico):** navegaci√≥n web segura, Wi-Fi (WEP).

---

#### üîí **ChaCha20**

- Dise√±ado por Daniel J. Bernstein.
- Mucho m√°s seguro que RC4.
- **Muy r√°pido**, resistente a ataques y confiable.
- Usado por **Google, WhatsApp, WireGuard, OpenSSH, TLS 1.3**.
- No usa tablas S-box como RC4 ‚Üí m√°s seguro contra ataques de canal lateral (como timing attacks).

üìå **Clave:** 256 bits (32 bytes)

üìå **Nonce:** 96 bits o 128 bits (seg√∫n implementaci√≥n)

---

#### üîí **Salsa20**

- Antecesor de ChaCha20, tambi√©n creado por Bernstein.
- M√°s simple, eficiente y tambi√©n seguro.
- Ya no se usa tanto como ChaCha20, pero sigue siendo confiable.

---

#### üîí **Grain y Trivium**

- Son **stream ciphers dise√±ados para hardware** y dispositivos de baja potencia (como IoT).
- Son parte del proyecto **eSTREAM**.
- No se usan tanto en software general, pero s√≠ en criptograf√≠a embebida.

---

#### üîÑ **AES en modo CTR (Counter Mode)**

Aunque AES es un **block cipher**, si lo usas en **modo CTR (Counter)** se comporta como un stream cipher:

- Genera un keystream cifrando un contador que va aumentando.
- Muy seguro y ampliamente adoptado.

üìå Se usa en muchas aplicaciones modernas para obtener los beneficios de los stream ciphers sin dejar de usar AES.

---

### üõ†Ô∏è ¬øC√≥mo se "instalan" los stream ciphers?

No se instalan como programas normales. Para usarlos, necesitas una biblioteca criptogr√°fica en tu lenguaje favorito. Aqu√≠ tienes algunos ejemplos:

| Lenguaje | Biblioteca popular             |
| -------- | ------------------------------ |
| Python   | `cryptography`                 |
| Node.js  | `crypto`                       |
| Java     | `javax.crypto`                 |
| C        | OpenSSL                        |
| C#       | `System.Security.Cryptography` |

---

### üß™ Ejemplo completo: Usando **ChaCha20** en Python

#### üîß Requisitos

Aseg√∫rate de instalar la librer√≠a:

```bash
pip install cryptography
```

---

#### ‚úÖ C√≥digo completo

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
from cryptography.hazmat.backends import default_backend
import os

# 1. Crear clave y nonce
clave = os.urandom(32)     # 256 bits para ChaCha20
nonce = os.urandom(16)     # 128 bits

# 2. Crear el objeto de cifrado
algoritmo = algorithms.ChaCha20(clave, nonce)
cifrador = Cipher(algoritmo, mode=None, backend=default_backend())

# 3. Crear el encryptor y decryptor
encryptor = cifrador.encryptor()
decryptor = cifrador.decryptor()

# 4. Mensaje original
mensaje = b"Hola, este es un mensaje cifrado con ChaCha20!"

# 5. Cifrar el mensaje
cifrado = encryptor.update(mensaje)

# 6. Descifrar el mensaje
descifrado = decryptor.update(cifrado)

# 7. Mostrar resultados
print("Mensaje original:", mensaje.decode())
print("Mensaje cifrado (hex):", cifrado.hex())
print("Mensaje descifrado:", descifrado.decode())
```

---

#### üßæ Resultado esperado (salida):

```plaintext
Mensaje original: Hola, este es un mensaje cifrado con ChaCha20!
Mensaje cifrado (hex): 7f43c3e21d... (una secuencia hexadecimal)
Mensaje descifrado: Hola, este es un mensaje cifrado con ChaCha20!
```

---

### üß† Conclusi√≥n

| Cifrador      | Estado      | Uso com√∫n                    | Seguridad |
| ------------- | ----------- | ---------------------------- | --------- |
| RC4           | Obsoleto ‚ùå | WEP, TLS                     | Inseguro  |
| ChaCha20      | Actual ‚úÖ   | TLS 1.3, WhatsApp, WireGuard | Muy alta  |
| Salsa20       | Vigente ‚úÖ  | Alternativa simple a ChaCha  | Alta      |
| AES-CTR       | Actual ‚úÖ   | Cifrado moderno              | Muy alta  |
| Grain/Trivium | Niche ‚úÖ    | IoT, hardware embebido       | Alta      |

---

[üîº](#√≠ndice)

---

## **403. RC4**

### üîê ¬øQu√© es RC4?

**RC4** (Rivest Cipher 4) es un algoritmo de cifrado sim√©trico de flujo, dise√±ado por **Ron Rivest** en 1987. Es famoso por su **simplicidad, velocidad y facilidad de implementaci√≥n**. Por muchos a√±os fue usado en protocolos como **SSL/TLS** y en **WEP/WPA** (seguridad Wi-Fi).

> üìõ **Importante:** Hoy en d√≠a **RC4 est√° considerado inseguro** y **obsoleto**, debido a varias vulnerabilidades descubiertas, especialmente si se reutiliza la clave.

---

### üìå Caracter√≠sticas de RC4

- Es un **stream cipher**, cifra los datos **byte por byte**.
- Usa una **clave variable** entre 40 y 2048 bits (generalmente 128 bits).
- Usa una estructura interna llamada **S-box** (una permutaci√≥n de 256 bytes).
- La operaci√≥n principal es el XOR entre el texto plano y el keystream.

---

### ‚öôÔ∏è ¬øC√≥mo funciona RC4?

RC4 tiene **dos fases** principales:

1. **Key Scheduling Algorithm (KSA)**

   Inicializa y mezcla la tabla S (permuta los valores del 0 al 255 en base a la clave).

2. **Pseudo-Random Generation Algorithm (PRGA)**

   Genera un keystream pseudoaleatorio que se combina con el texto plano usando XOR.

---

### üë®‚Äçüè´ Ejemplo simple paso a paso

Sup√≥n que tienes el mensaje:

```
Texto plano:  HOLA
Clave:         KEY
```

El keystream generado ser√° una secuencia de bytes pseudoaleatorios, por ejemplo: `0x5A, 0x1F, 0x33, 0x9C`.

El texto cifrado se obtiene as√≠:

```
'H' (0x48) XOR 0x5A ‚Üí 0x12
'O' (0x4F) XOR 0x1F ‚Üí 0x50
'L' (0x4C) XOR 0x33 ‚Üí 0x7F
'A' (0x41) XOR 0x9C ‚Üí 0xDD
```

Texto cifrado en hexadecimal: `12 50 7F DD`

Para **descifrar**, simplemente vuelves a aplicar XOR con el mismo keystream.

---

### üì¶ Instalaci√≥n y uso de RC4 en Python

Aunque RC4 est√° en desuso, puedes usarlo para **fines educativos** con bibliotecas como `PyCryptodome`.

#### üîß Paso 1: Instalar PyCryptodome

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo completo en Python

```python
from Crypto.Cipher import ARC4
from Crypto.Random import get_random_bytes

# 1. Crear clave (16 bytes)
clave = get_random_bytes(16)

# 2. Crear el cifrador RC4
cipher = ARC4.new(clave)

# 3. Texto original
mensaje = b"Hola, este es un mensaje usando RC4."

# 4. Cifrar
cifrado = cipher.encrypt(mensaje)

# 5. Para descifrar, crear un nuevo cifrador con la misma clave
cipher2 = ARC4.new(clave)
descifrado = cipher2.decrypt(cifrado)

# 6. Resultados
print("Mensaje original:", mensaje.decode())
print("Mensaje cifrado (hex):", cifrado.hex())
print("Mensaje descifrado:", descifrado.decode())
```

---

### üîç Salida esperada

```plaintext
Mensaje original: Hola, este es un mensaje usando RC4.
Mensaje cifrado (hex): b4a7d2f09f...
Mensaje descifrado: Hola, este es un mensaje usando RC4.
```

---

### üö´ Vulnerabilidades conocidas de RC4

1. **Sesgo en los primeros bytes** del keystream.
2. **Ataques al primer byte** (usado en WEP para romper claves).
3. **Predecibilidad** del keystream si la clave se reutiliza.

üîê Hoy en d√≠a, **ChaCha20 o AES-CTR** son usados como reemplazo seguro de RC4.

---

### üß† Conclusi√≥n

| Ventajas de RC4               | Desventajas de RC4                               |
| ----------------------------- | ------------------------------------------------ |
| R√°pido y f√°cil de implementar | Inseguro, especialmente si se reutiliza la clave |
| Usado hist√≥ricamente en TLS   | Sesgos en el keystream                           |
| No necesita relleno (padding) | No cumple con est√°ndares modernos                |

---

[üîº](#√≠ndice)

---

## **404. RC4 en la pr√°ctica**

### üîê ¬øQu√© es RC4 en la pr√°ctica?

**RC4** (Rivest Cipher 4) es un algoritmo de cifrado por flujo **sim√©trico**, lo que significa que **usa la misma clave para cifrar y descifrar**. A pesar de estar **obsoleto** para usos reales (por inseguro), **es √∫til para aprender** c√≥mo funcionan los cifrados de flujo y para practicar criptograf√≠a b√°sica.

En la pr√°ctica, RC4:

- Se implementa f√°cilmente con unas pocas l√≠neas de c√≥digo.
- Se usa para cifrar texto o archivos peque√±os.
- Su clave puede ser corta (por ejemplo, 16 bytes).
- Es vulnerable si reutilizas la clave o no descartas los primeros bytes del keystream.

---

### üß† ¬øC√≥mo funciona RC4?

1. **Generaci√≥n de estado interno (S-box)** con 256 valores (0-255).
2. **Mezcla (Key Scheduling Algorithm ‚Äì KSA)** usando la clave.
3. **Generaci√≥n de keystream (PRGA)**: RC4 genera un flujo de bytes pseudoaleatorios.
4. **Cifrado/Descifrado**: El texto plano se combina con el keystream usando XOR.

> üîÅ En la pr√°ctica, cifrar y descifrar son la **misma operaci√≥n XOR**.

---

### üíª ¬øC√≥mo se instala RC4 para probarlo?

La forma m√°s sencilla es usando **Python** con la biblioteca `PyCryptodome`.

#### üîß Instalaci√≥n paso a paso

1. Abre tu terminal o CMD
2. Escribe este comando:

```bash
pip install pycryptodome
```

> Esta librer√≠a contiene muchas herramientas criptogr√°ficas, incluyendo RC4 (llamado `ARC4` aqu√≠ por temas de derechos de autor).

---

### ‚úÖ Ejemplo pr√°ctico completo: cifrado y descifrado RC4

#### ‚úèÔ∏è C√≥digo en Python

```python
from Crypto.Cipher import ARC4
from Crypto.Random import get_random_bytes

# Paso 1: Crear una clave aleatoria (de 16 bytes)
clave = get_random_bytes(16)

# Paso 2: Crear el cifrador con la clave
cifrador = ARC4.new(clave)

# Paso 3: Texto a cifrar
mensaje = b"Este es un mensaje secreto con RC4."

# Paso 4: Cifrar el mensaje
mensaje_cifrado = cifrador.encrypt(mensaje)

# Paso 5: Para descifrar, se debe reiniciar el cifrador con la misma clave
descifrador = ARC4.new(clave)
mensaje_descifrado = descifrador.decrypt(mensaje_cifrado)

# Paso 6: Mostrar resultados
print("Texto original:", mensaje.decode())
print("Texto cifrado (hex):", mensaje_cifrado.hex())
print("Texto descifrado:", mensaje_descifrado.decode())
```

---

#### üì• Salida esperada

```plaintext
Texto original: Este es un mensaje secreto con RC4.
Texto cifrado (hex): 9a4f88aaffb3...
Texto descifrado: Este es un mensaje secreto con RC4.
```

---

### üéØ Explicaci√≥n l√≠nea por l√≠nea

| L√≠nea de c√≥digo            | Explicaci√≥n                                                 |
| -------------------------- | ----------------------------------------------------------- |
| `get_random_bytes(16)`     | Genera una clave de 16 bytes aleatorios                     |
| `ARC4.new(clave)`          | Crea una instancia del cifrador RC4 con la clave            |
| `encrypt(mensaje)`         | Cifra el mensaje con el keystream generado                  |
| `decrypt(mensaje_cifrado)` | Descifra el mensaje aplicando XOR otra vez con el keystream |
| `.hex()`                   | Convierte bytes cifrados a hexadecimal para visualizar      |

---

### üö´ ¬øPor qu√© no se recomienda RC4 en sistemas modernos?

RC4 es f√°cil de implementar, pero:

- Tiene **sesgos estad√≠sticos** en el keystream.
- Se puede **romper f√°cilmente** si no descartas los primeros bytes.
- Fue explotado en **ataques a WEP** y **TLS con RC4**.

Por eso hoy se prefieren algoritmos como:

- **AES en modo CTR**
- **ChaCha20**

---

### üìö Resumen

| Concepto              | Detalle                                 |
| --------------------- | --------------------------------------- |
| Tipo de cifrado       | Sim√©trico, por flujo                    |
| Seguridad actual      | D√©bil, no recomendado para producci√≥n   |
| Usos educativos       | Excelente para aprender XOR y keystream |
| Clave                 | Secreta, entre 40 y 2048 bits           |
| Instalaci√≥n en Python | `pip install pycryptodome`              |
| Biblioteca usada      | `Crypto.Cipher.ARC4`                    |

---

### üß™ ¬øQu√© puedes hacer ahora?

Aqu√≠ tienes algunas ideas para practicar con RC4:

1. Cifrar y descifrar archivos de texto.
2. Implementar RC4 desde cero en Python (sin librer√≠as).
3. Comparar RC4 con AES o ChaCha20.
4. Simular un ataque por reutilizaci√≥n de clave.

---

[üîº](#√≠ndice)

---

## **405. Implementa RC4 en Python**

### üîê ¬øQu√© es RC4?

**RC4** es un algoritmo de cifrado **sim√©trico por flujo** que genera un **keystream** (flujo de claves pseudoaleatorias) que luego se **combina mediante XOR con el texto original** para cifrarlo o descifrarlo.

---

### üìå Conceptos clave de RC4

#### **Key Scheduling Algorithm (KSA):**

- Inicializa una lista `S` con valores del 0 al 255.
- Mezcla `S` usando la clave.

#### **Pseudo-Random Generation Algorithm (PRGA):**

- Usa `S` para generar una secuencia pseudoaleatoria de bytes (keystream).
- El keystream se usa para cifrar o descifrar usando **XOR**.

---

### üß† ¬øC√≥mo funciona?

1. **Prepara una clave** (por ejemplo, `"clave123"`).
2. Inicializa un array `S` con los n√∫meros del 0 al 255.
3. Aplica el **KSA** con esa clave para mezclar `S`.
4. Ejecuta el **PRGA** para generar el keystream.
5. Aplica **XOR** entre cada byte del texto y el keystream para cifrar/descifrar.

---

### üíª Instalaci√≥n

üëâ No necesitas instalar nada. Solo necesitas **Python instalado en tu sistema** (puede ser Python 3.7 o superior).

Para verificar si lo tienes:

```bash
python --version
```

---

### ‚úÖ Implementaci√≥n completa en Python (desde cero)

```python
def KSA(key):
    """Key Scheduling Algorithm: mezcla la lista S con la clave."""
    key_length = len(key)
    S = list(range(256))
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % key_length]) % 256
        S[i], S[j] = S[j], S[i]  # intercambio
    return S

def PRGA(S):
    """Pseudo-Random Generation Algorithm: genera el keystream."""
    i = 0
    j = 0
    while True:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]  # intercambio
        K = S[(S[i] + S[j]) % 256]
        yield K

def RC4(key, data):
    """Cifra o descifra el texto usando RC4."""
    key = [ord(c) for c in key]  # convierte la clave en lista de enteros
    S = KSA(key)
    keystream = PRGA(S)
    result = bytes([c ^ next(keystream) for c in data])
    return result
```

---

### üß™ Ejemplo completo de uso

```python
# Texto original y clave
clave = "clave123"
texto = "Hola, mundo secreto"

# Cifrado
texto_bytes = texto.encode()
cifrado = RC4(clave, texto_bytes)
print("Texto cifrado (hex):", cifrado.hex())

# Descifrado
descifrado = RC4(clave, cifrado)
print("Texto descifrado:", descifrado.decode())
```

#### üßæ Salida esperada:

```bash
Texto cifrado (hex): 2d7be90b9a4d5f...
Texto descifrado: Hola, mundo secreto
```

---

### üß† ¬øQu√© debes recordar?

| Concepto         | Explicaci√≥n breve                                     |
| ---------------- | ----------------------------------------------------- |
| XOR              | Es reversible: `C = M ‚äï K`, luego `M = C ‚äï K`         |
| Simetr√≠a         | Se usa la misma clave para cifrar y descifrar         |
| Keystream        | Flujo pseudoaleatorio generado desde `S`              |
| Clave            | Puede ser cualquier texto (ideal: >= 8 caracteres)    |
| Seguridad actual | RC4 ya **no es seguro para uso real**, solo educativo |

---

[üîº](#√≠ndice)

---

## **406. Ataques a RC4**

### üîê ¬øQu√© es RC4?

RC4 es un **algoritmo de cifrado de flujo sim√©trico** muy r√°pido, creado en 1987 por Ron Rivest. Durante a√±os fue ampliamente usado en protocolos como:

- SSL/TLS (para cifrado web)
- WEP y WPA (en redes Wi-Fi)
- Microsoft Office y PDF antiguos

Pero con el tiempo se descubrieron **varias debilidades**, lo que lo hace **inseguro hoy en d√≠a**.

---

### ‚ö†Ô∏è ¬øPor qu√© RC4 es vulnerable?

#### Vulnerabilidades clave:

| Tipo de ataque                       | Explicaci√≥n breve                                                                                             |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| **Sesgo del keystream**              | Algunos bytes al inicio del keystream no son completamente aleatorios.                                        |
| **Bias en pares de bytes**           | Algunos pares de bytes se repiten m√°s que otros, lo cual puede usarse para deducir la clave o el texto plano. |
| **Ataques sobre WEP/WPA**            | Se reutilizan claves o IVs (vectores de inicializaci√≥n), lo cual facilita ataques.                            |
| **Ataques de recuperaci√≥n de clave** | En protocolos mal implementados, como WEP, es posible recuperar la clave compartida.                          |

---

### üîé Ejemplos de ataques a RC4

#### 1. üîÅ **Reutilizaci√≥n de keystreams (clave+IV repetido)**

- **Regla de oro del cifrado por flujo**: Nunca reutilices el keystream.
- Si cifras dos mensajes con el mismo keystream:

```text
Mensaje 1: M1 = "hola mundo"
Mensaje 2: M2 = "clave secreta"
Cifrado1 = M1 ‚äï K
Cifrado2 = M2 ‚äï K

Entonces:
Cifrado1 ‚äï Cifrado2 = M1 ‚äï K ‚äï M2 ‚äï K = M1 ‚äï M2
```

Y si se conoce M1, se puede recuperar M2 (y viceversa).

---

#### 2. üìä **Ataques de an√°lisis estad√≠stico**

RC4 tiene **sesgos**: ciertos valores del keystream ocurren **con m√°s frecuencia** de lo que deber√≠an.

Ejemplo:

- El segundo byte del keystream tiende a ser `0x00` m√°s seguido que cualquier otro valor.
- Los atacantes pueden analizar muchos mensajes cifrados con RC4 y deducir partes del texto o de la clave.

---

#### 3. üß∞ Ataques reales: BEAST, Lucky13, RC4 NOMORE

RC4 fue **deshabilitado oficialmente en TLS** (seguridad web) porque:

- Ataques como **RC4 NOMORE** (2015) demostraron que RC4 es vulnerable incluso si se usa correctamente.
- Analizando millones de mensajes cifrados, se pod√≠a recuperar texto plano (como cookies o contrase√±as).

---

### üõ†Ô∏è ¬øC√≥mo ‚Äúinstalar‚Äù un entorno para probar ataques?

Puedes simular un entorno vulnerable para pruebas educativas con:

#### üîß Requisitos:

- Python instalado
- Un editor como VSCode o Jupyter Notebook

#### üêç Instala `pycryptodome` (opcional, para comparar con cifrados modernos):

```bash
pip install pycryptodome
```

---

### üß™ Ejemplo completo: Mostrar debilidad al reutilizar keystream

```python
def xor_bytes(a, b):
    return bytes([x ^ y for x, y in zip(a, b)])

def ejemplo_ataque_rc4():
    # Keystream fijo (mismo para ambos mensajes)
    keystream = b'\x1f\x2a\x3b\x4c\x5d\x6e\x7f\x80\x91\xa2'

    # Mensaje original
    mensaje1 = b'Hola Mundo'
    mensaje2 = b'Secreto123'

    # Cifrado (simulaci√≥n)
    cifrado1 = xor_bytes(mensaje1, keystream)
    cifrado2 = xor_bytes(mensaje2, keystream)

    # Ataque: si el atacante tiene ambos cifrados:
    xor_cifrados = xor_bytes(cifrado1, cifrado2)

    print("Cifrado1:", cifrado1.hex())
    print("Cifrado2:", cifrado2.hex())
    print("XOR de ambos:", xor_cifrados)

    # Si el atacante conoce uno de los textos:
    mensaje2_reconstruido = xor_bytes(xor_cifrados, mensaje1)
    print("Mensaje2 recuperado:", mensaje2_reconstruido.decode())

ejemplo_ataque_rc4()
```

#### üßæ Salida esperada:

```
Cifrado1: 5f460d280e...
Cifrado2: 4c64092a1e...
XOR de ambos: 13020c0210...
Mensaje2 recuperado: Secreto123
```

---

### üîê Conclusi√≥n

| ‚úÖ Ventajas de RC4 (hist√≥ricas) | ‚ùå Debilidades que lo hacen inseguro hoy |
| ------------------------------- | ---------------------------------------- |
| Simple y r√°pido                 | Sesgo estad√≠stico en el keystream        |
| F√°cil de implementar            | Sensible a reutilizaci√≥n de claves/IV    |
| Usado en protocolos populares   | Ataques pr√°cticos en WEP, TLS, SSL       |

#### ‚ùóEstado actual:

> **RC4 ya no debe usarse** en ning√∫n sistema moderno. Est√° **prohibido en TLS desde 2015**. Solo se usa con fines educativos.

---

[üîº](#√≠ndice)

---

## **407. ChaCha20**

### üîê ¬øQu√© es ChaCha20?

**ChaCha20** es un **cifrado de flujo sim√©trico moderno** desarrollado por Daniel J. Bernstein en 2008, basado en el cifrado anterior llamado **Salsa20**. Es r√°pido, seguro y est√° dise√±ado para funcionar bien en hardware y software.

#### ‚ú® ¬øPor qu√© es tan popular?

- ‚úÖ **Muy r√°pido** (incluso m√°s que AES en muchos dispositivos m√≥viles)

- ‚úÖ **Seguro** (no tiene los sesgos de RC4)

- ‚úÖ **Resistente a ataques de canal lateral**

- ‚úÖ Usado por **Google, WhatsApp, WireGuard, OpenSSH**, etc.

---

### üß† ¬øC√≥mo funciona ChaCha20?

ChaCha20 no cifra directamente como AES. En lugar de eso:

1. **Toma una clave secreta de 256 bits (32 bytes)**.
2. Toma un **contador de bloque** y un **nonce** (un n√∫mero aleatorio √∫nico por mensaje).
3. Genera un **keystream (flujo de claves pseudoaleatorias)**.
4. Luego, **XOR** el keystream con el mensaje para cifrarlo.

#### F√≥rmula:

```
ciphertext = plaintext ‚äï keystream
```

Y para descifrar:

```
plaintext = ciphertext ‚äï keystream
```

üí° **Nota**:

El mismo keystream **jam√°s debe reutilizarse** con la misma clave + nonce, igual que otros stream ciphers.

---

### üì¶ ¬øC√≥mo instalar ChaCha20?

Usaremos `pycryptodome`, una librer√≠a de Python que implementa ChaCha20 de forma segura.

#### üîß Paso 1: Instalar la librer√≠a

Abre tu terminal o consola y escribe:

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo completo en Python

```python
from Crypto.Cipher import ChaCha20
from Crypto.Random import get_random_bytes

def ejemplo_chacha20():
    # Paso 1: Crear clave y nonce
    clave = get_random_bytes(32)   # 256 bits
    nonce = get_random_bytes(12)   # 96 bits, recomendado para ChaCha20

    # Paso 2: Crear el mensaje
    mensaje = b"Este es un mensaje secreto usando ChaCha20"

    # Paso 3: Cifrar
    cifrador = ChaCha20.new(key=clave, nonce=nonce)
    ciphertext = cifrador.encrypt(mensaje)

    print("Mensaje original:", mensaje)
    print("Cifrado (hex):", ciphertext.hex())

    # Paso 4: Descifrar
    descifrador = ChaCha20.new(key=clave, nonce=nonce)
    mensaje_recuperado = descifrador.decrypt(ciphertext)

    print("Mensaje descifrado:", mensaje_recuperado)

ejemplo_chacha20()
```

#### üßæ Salida esperada:

```
Mensaje original: b'Este es un mensaje secreto usando ChaCha20'
Cifrado (hex): 83a2f1c78ef8b1e3f5...
Mensaje descifrado: b'Este es un mensaje secreto usando ChaCha20'
```

---

### üìå Resumen de ChaCha20

| Caracter√≠stica       | Detalles                                  |
| -------------------- | ----------------------------------------- |
| Tipo                 | Cifrado de flujo (stream cipher)          |
| Longitud de clave    | 256 bits (32 bytes)                       |
| Longitud del nonce   | 96 bits (12 bytes) recomendado            |
| Seguridad            | Muy alta, sin ataques pr√°cticos conocidos |
| Velocidad            | Excelente, mejor que AES en m√≥viles       |
| Implementaci√≥n com√∫n | TLS 1.3, WireGuard, WhatsApp, OpenSSH     |

---

### üõ°Ô∏è ¬øChaCha20 es mejor que AES?

Depende del caso:

| Criterio                         | AES          | ChaCha20         |
| -------------------------------- | ------------ | ---------------- |
| Velocidad en CPU sin aceleraci√≥n | M√°s lento    | Mucho m√°s r√°pido |
| Seguridad moderna                | Alta         | Alta             |
| Hardware necesario               | Aceleradores | No necesita      |
| Resistente a timing attacks      | No mucho     | S√≠ ‚úÖ            |

---

[üîº](#√≠ndice)

---

## **408. Funcionamiento de ChaCha20**

### üîê ¬øQu√© es ChaCha20?

**ChaCha20** es un **cifrado de flujo moderno** creado por **Daniel J. Bernstein**. Est√° dise√±ado para ser:

- M√°s **r√°pido** que AES en algunos dispositivos.
- M√°s **seguro** que antiguos cifrados como RC4.
- M√°s **resistente** a ataques de temporizaci√≥n (side-channel attacks).

üí° Es ampliamente usado en:

- **TLS 1.3 (HTTPS)**
- **WireGuard VPN**
- **OpenSSH**
- **WhatsApp**

---

### ‚öôÔ∏è ¬øC√≥mo funciona internamente ChaCha20?

ChaCha20 **no cifra directamente el mensaje**, sino que:

#### üìå En lugar de eso:

1. **Genera una secuencia pseudoaleatoria de bytes** (keystream).
2. Luego realiza un **XOR** entre el mensaje original y ese keystream.

Esto convierte el mensaje en algo incomprensible (cifrado).

---

#### üîß ¬øQu√© necesita ChaCha20 para funcionar?

- Una **clave secreta** de 256 bits (32 bytes)
- Un **nonce** (n√∫mero aleatorio √∫nico de 96 bits = 12 bytes)
- Un **contador de bloques** (32 bits)
- El **mensaje en texto claro**

---

#### üßÆ ¬øQu√© pasa dentro de ChaCha20?

ChaCha20 usa una funci√≥n llamada **"ChaCha core function"**, que transforma un estado inicial de 512 bits (64 bytes) con una serie de operaciones matem√°ticas:

1. Sumas m√≥dulo $2^{32}$
2. Rotaciones a la izquierda
3. XORs

Estos pasos se repiten 20 veces para asegurar la mezcla total de datos.

> üéØ Resultado: se genera un bloque de 64 bytes de keystream.

Este **keystream** se usa para cifrar (o descifrar) el texto mediante una operaci√≥n XOR:

```
ciphertext = plaintext ‚äï keystream
plaintext = ciphertext ‚äï keystream
```

---

### üß† Ejemplo simplificado (con analog√≠a)

Imagina que quieres enviar un mensaje a tu amigo. Ambos tienen un **libro secreto** (la clave) y cada d√≠a usan una **p√°gina distinta** (el nonce).

- El libro (clave) genera una lista de n√∫meros aleatorios (keystream).
- T√∫ sumas tu mensaje con esa lista (XOR).
- Tu amigo usa el mismo libro y p√°gina para **restar** (XOR de nuevo) y recuperar el mensaje.

---

### üì¶ Instalaci√≥n para probar ChaCha20

Usaremos Python y la biblioteca `pycryptodome`, que incluye una implementaci√≥n segura de ChaCha20.

#### ‚úÖ Instala con pip:

```bash
pip install pycryptodome
```

---

### üß™ Ejemplo completo en Python

```python
from Crypto.Cipher import ChaCha20
from Crypto.Random import get_random_bytes

def cifrar_con_chacha20(mensaje):
    # Generar clave de 32 bytes (256 bits)
    clave = get_random_bytes(32)

    # Generar nonce de 12 bytes (96 bits)
    nonce = get_random_bytes(12)

    # Crear objeto cifrador con clave y nonce
    cifrador = ChaCha20.new(key=clave, nonce=nonce)

    # Cifrar el mensaje
    ciphertext = cifrador.encrypt(mensaje)

    print("Mensaje original:", mensaje)
    print("Texto cifrado:", ciphertext.hex())

    # Descifrado (necesita misma clave y nonce)
    descifrador = ChaCha20.new(key=clave, nonce=nonce)
    texto_descifrado = descifrador.decrypt(ciphertext)

    print("Texto descifrado:", texto_descifrado)

# Ejecutar
mensaje = b"Hola, esto es un ejemplo de ChaCha20"
cifrar_con_chacha20(mensaje)
```

---

#### üßæ Salida esperada:

```
Mensaje original: b'Hola, esto es un ejemplo de ChaCha20'
Texto cifrado: e1a3f9c4a8f927...
Texto descifrado: b'Hola, esto es un ejemplo de ChaCha20'
```

---

### ‚úÖ Resumen

| Elemento            | Valor                                  |
| ------------------- | -------------------------------------- |
| Cifrado             | ChaCha20                               |
| Tipo                | Stream Cipher (flujo)                  |
| Clave               | 256 bits (32 bytes)                    |
| Nonce               | 96 bits (12 bytes)                     |
| Operaci√≥n principal | XOR con keystream                      |
| Seguridad           | Alta, sin ataques pr√°cticos conocidos  |
| Ventaja             | R√°pido, seguro y simple de implementar |

---

[üîº](#√≠ndice)

---

## **409. Caso Pr√°ctico: ChaCha20**

### üîê ¬øQu√© es ChaCha20 (resumen corto)?

ChaCha20 es un **cifrado por flujo moderno**:

- Muy r√°pido y seguro
- Usado en WhatsApp, TLS 1.3, WireGuard, etc.
- Funciona generando un **keystream pseudoaleatorio** que se combina con el mensaje usando XOR

---

### üß† ¬øCu√°ndo lo usar√≠as en la vida real?

ChaCha20 es ideal cuando necesitas:

- üîê Cifrar mensajes o archivos en dispositivos m√≥viles (es r√°pido en hardware d√©bil)
- üõ°Ô∏è Evitar ataques de temporizaci√≥n (seguro en entornos no protegidos)
- üß≥ Cifrado r√°pido sin depender de AES (alternativa moderna)

---

### üß™ Caso pr√°ctico: cifrar un archivo de texto confidencial

Imagina que trabajas en una empresa y tienes que guardar informaci√≥n confidencial en un archivo de texto (por ejemplo, nombres de clientes, contrase√±as temporales, notas internas).

#### üéØ Objetivo:

1. **Cifrar** el archivo usando ChaCha20
2. **Guardar** la clave y el nonce (necesarios para descifrar)
3. **Descifrar** el archivo cuando se necesite

---

### üì¶ Instalaci√≥n (en tu PC)

Instala la librer√≠a `pycryptodome`:

```bash
pip install pycryptodome
```

---

### üìÅ Archivos que usaremos

- `datos.txt`: contiene el texto a cifrar
- `clave_nonce.bin`: contiene la clave y el nonce (guardados en binario)
- `datos_cifrados.bin`: resultado cifrado
- `datos_descifrados.txt`: resultado descifrado

---

### üß© C√≥digo completo

#### üîí Paso 1: Cifrar el archivo

```python
from Crypto.Cipher import ChaCha20
from Crypto.Random import get_random_bytes

# Leer el archivo original
with open("datos.txt", "rb") as f:
    datos = f.read()

# Generar clave de 32 bytes y nonce de 12 bytes
clave = get_random_bytes(32)
nonce = get_random_bytes(12)

# Cifrar con ChaCha20
cipher = ChaCha20.new(key=clave, nonce=nonce)
datos_cifrados = cipher.encrypt(datos)

# Guardar datos cifrados
with open("datos_cifrados.bin", "wb") as f:
    f.write(datos_cifrados)

# Guardar clave y nonce (necesarios para descifrar)
with open("clave_nonce.bin", "wb") as f:
    f.write(clave + nonce)

print("‚úÖ Archivo cifrado correctamente.")
```

---

#### üîì Paso 2: Descifrar el archivo

```python
from Crypto.Cipher import ChaCha20

# Leer los datos cifrados
with open("datos_cifrados.bin", "rb") as f:
    datos_cifrados = f.read()

# Leer clave y nonce
with open("clave_nonce.bin", "rb") as f:
    contenido = f.read()
    clave = contenido[:32]
    nonce = contenido[32:]

# Descifrar con ChaCha20
cipher = ChaCha20.new(key=clave, nonce=nonce)
datos_descifrados = cipher.decrypt(datos_cifrados)

# Guardar los datos descifrados
with open("datos_descifrados.txt", "wb") as f:
    f.write(datos_descifrados)

print("‚úÖ Archivo descifrado correctamente.")
```

---

### üìÇ Estructura del proyecto

```
üìÅ proyecto_chacha20
‚îú‚îÄ‚îÄ datos.txt               # Texto original
‚îú‚îÄ‚îÄ datos_cifrados.bin      # Texto cifrado
‚îú‚îÄ‚îÄ datos_descifrados.txt   # Texto recuperado
‚îú‚îÄ‚îÄ clave_nonce.bin         # Clave y nonce guardados
‚îú‚îÄ‚îÄ cifrar.py               # Script de cifrado
‚îî‚îÄ‚îÄ descifrar.py            # Script de descifrado
```

---

### üß™ Ejemplo en ejecuci√≥n

**Contenido de `datos.txt`:**

```
Usuario: Ana
Contrase√±a: Secreta123
Notas: Enviar informe antes del viernes.
```

**Despu√©s de cifrar y descifrar**, el archivo `datos_descifrados.txt` debe contener exactamente el mismo texto.

---

### üß∑ Buenas pr√°cticas

- Nunca reutilices la misma combinaci√≥n de **clave y nonce** en otro mensaje.
- Almacena la clave y el nonce en un lugar **seguro**, por ejemplo, un archivo cifrado o un gestor de claves.
- Puedes combinar ChaCha20 con **Poly1305** si necesitas **autenticaci√≥n de integridad** (ChaCha20-Poly1305).

---

### ‚úÖ Resumen final

| Paso               | Detalle                                 |
| ------------------ | --------------------------------------- |
| üîê Cifrado usado   | ChaCha20                                |
| üì¶ Instalaci√≥n     | `pip install pycryptodome`              |
| üîë Requiere        | Clave de 256 bits + Nonce de 96 bits    |
| üß™ Caso pr√°ctico   | Cifrado y descifrado de archivos        |
| üìÅ Archivos usados | texto, clave+nonce, cifrado, descifrado |

---

[üîº](#√≠ndice)

---

## **410. Block Ciphers**

### üîê ¬øQu√© es un Block Cipher (cifrador por bloques)?

Un **Block Cipher** es un algoritmo criptogr√°fico que **cifra datos en bloques fijos de bits**, por ejemplo de 64 o 128 bits. A diferencia de los cifradores por flujo (que cifran bit a bit o byte a byte), un cifrador por bloques toma **un bloque completo de datos de entrada** y lo transforma con una clave secreta.

---

#### üß± Ejemplo b√°sico:

Supongamos que tenemos un cifrador que cifra **bloques de 4 letras** a la vez, y nuestro mensaje es:

```
Mensaje: HOLAAMIGOS
Bloques: [HOLA] [AMIG] [OSXX]  ‚Üê (rellenamos con X para completar el √∫ltimo bloque)
```

Cada bloque es procesado **independientemente** (o con alguna relaci√≥n, seg√∫n el modo de operaci√≥n) usando la clave.

---

### üß∞ ¬øD√≥nde se usan los block ciphers?

- En **TLS/SSL** (cuando visitas p√°ginas web HTTPS)
- En **archivos cifrados** (como ZIP, PDF, discos duros cifrados)
- En **sistemas bancarios y bases de datos cifradas**
- En **VPNs y conexiones seguras**

---

### üîë Caracter√≠sticas importantes

| Caracter√≠stica      | Explicaci√≥n                                                                                                        |
| ------------------- | ------------------------------------------------------------------------------------------------------------------ |
| **Bloques fijos**   | Trabajan con bloques de tama√±o definido (ej. 128 bits)                                                             |
| **Determin√≠sticos** | El mismo bloque de entrada y clave siempre da la misma salida (a menos que se use un modo como CBC, ver m√°s abajo) |
| **Sim√©tricos**      | Usan la misma clave para cifrar y descifrar                                                                        |

---

### üîÑ Modos de operaci√≥n

Un block cipher **por s√≠ solo solo cifra un bloque**. Para cifrar mensajes largos, usamos **modos de operaci√≥n**:

| Modo    | Descripci√≥n simplificada                                     |
| ------- | ------------------------------------------------------------ |
| ECB     | Cada bloque se cifra por separado (no recomendado, inseguro) |
| CBC     | Cada bloque depende del anterior (m√°s seguro)                |
| CFB/CTR | Cifran como si fueran un stream cipher                       |
| GCM     | Agrega autenticaci√≥n (AEAD, moderno y seguro)                |

---

### üîí Ejemplos de cifradores por bloques populares

| Nombre   | Tama√±o de bloque | Tama√±o de clave    | Seguro hoy           |
| -------- | ---------------- | ------------------ | -------------------- |
| **AES**  | 128 bits         | 128, 192, 256 bits | ‚úÖ S√≠                |
| DES      | 64 bits          | 56 bits            | ‚ùå No (obsoleto)     |
| 3DES     | 64 bits          | 112 o 168 bits     | ‚ö†Ô∏è No recomendado    |
| Blowfish | 64 bits          | Hasta 448 bits     | ‚ö†Ô∏è No tan usado      |
| Twofish  | 128 bits         | Hasta 256 bits     | ‚úÖ Alternativa a AES |

---

### üõ†Ô∏è Instalaci√≥n (librer√≠a en Python)

Usaremos **PyCryptodome**, que ofrece soporte para AES y otros cifradores por bloques.

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo completo: Cifrado con AES en modo CBC

#### ‚úèÔ∏è Paso 1: Cifrar un mensaje

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Random import get_random_bytes

# Mensaje a cifrar
mensaje = b"Hola, este es un mensaje secreto que debe protegerse."

# Clave de 16 bytes (128 bits)
clave = get_random_bytes(16)

# IV: vector de inicializaci√≥n (16 bytes tambi√©n)
iv = get_random_bytes(16)

# Crear objeto de cifrado AES en modo CBC
cipher = AES.new(clave, AES.MODE_CBC, iv)

# Rellenar el mensaje al m√∫ltiplo de 16 bytes
mensaje_padded = pad(mensaje, AES.block_size)

# Cifrar
cifrado = cipher.encrypt(mensaje_padded)

print("üîê Mensaje cifrado:", cifrado.hex())
```

---

#### ‚úèÔ∏è Paso 2: Descifrar el mensaje

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

# Crear objeto de descifrado con misma clave e IV
cipher = AES.new(clave, AES.MODE_CBC, iv)

# Descifrar
descifrado_padded = cipher.decrypt(cifrado)

# Quitar relleno
mensaje_original = unpad(descifrado_padded, AES.block_size)

print("üì® Mensaje descifrado:", mensaje_original.decode())
```

---

### üìÇ Resumen del c√≥digo

- Usamos AES con bloques de 128 bits (16 bytes)
- Modo CBC (Cipher Block Chaining) para seguridad real
- Usamos `pad()` y `unpad()` para asegurar el tama√±o de los bloques
- Guardamos `clave` e `iv`, ya que son necesarios para descifrar

---

### üß† Conclusi√≥n

| Concepto                | Valor                                |
| ----------------------- | ------------------------------------ |
| Tipo                    | Cifrador por bloques (Block Cipher)  |
| Algoritmo usado         | AES (moderno y seguro)               |
| Tama√±o de bloque        | 128 bits                             |
| Modo de operaci√≥n usado | CBC                                  |
| Uso real                | HTTPS, archivos cifrados, VPNs, etc. |

---

[üîº](#√≠ndice)

---

## **411. Propiedades de los Block Ciphers**

### üîê ¬øQu√© es un Block Cipher?

Un **Block Cipher** es un algoritmo de cifrado **sim√©trico** que transforma datos de entrada (plaintext) en bloques de un tama√±o fijo, t√≠picamente 64 o 128 bits, usando una clave secreta.

Por ejemplo:

```
Entrada (64 bits): 01001011 10101001 ...
Clave (64 bits):   01100011 11100011 ...
‚Üì
Salida (64 bits):  11100101 00011010 ...
```

---

### üß† Propiedades clave de los Block Ciphers

Estas propiedades son esenciales para garantizar que un Block Cipher sea seguro y √∫til en la pr√°ctica.

| Propiedad                           | ¬øQu√© significa?                                                                    | Ejemplo f√°cil                                                        |
| ----------------------------------- | ---------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| **Determinismo (sin modo CBC)**     | Con la misma clave y el mismo texto plano, **siempre** se obtiene el mismo cifrado | AES en modo ECB siempre da el mismo resultado para la misma entrada  |
| **Difusi√≥n**                        | Un cambio peque√±o en el texto plano afecta muchos bits en el cifrado               | Cambiar 1 letra del mensaje cambia todo el bloque cifrado            |
| **Confusi√≥n**                       | La relaci√≥n entre la clave y el texto cifrado debe ser lo m√°s compleja posible     | No se puede adivinar la clave viendo el texto cifrado                |
| **Avalancha**                       | Cambiar un solo bit en la entrada **cambia la mitad o m√°s de los bits de salida**  | Cambiar una letra hace que el resultado cifrado cambie completamente |
| **Inversibilidad**                  | Se puede **descifrar** correctamente con la misma clave                            | Con la clave correcta puedes recuperar el mensaje original           |
| **Resistencia a ataques conocidos** | No debe ser vulnerable a ataques como texto claro conocido o elegido               | AES y Twofish han sido dise√±ados para resistir estos ataques         |
| **Longitud fija del bloque**        | El cifrador opera con bloques de un tama√±o determinado (ej. 128 bits)              | AES siempre trabaja con bloques de 128 bits                          |

---

#### üéØ Ejemplo visual de **difusi√≥n** y **avalancha**

Imagina dos mensajes que difieren por una sola letra:

```
Mensaje A: "HOLA MUNDO"
Mensaje B: "HOLA NUNDO" ‚Üê cambiamos la M por una N

‚Üí El resultado cifrado (en AES modo CBC) ser√° **completamente distinto**
```

Este comportamiento es deseado: **difusi√≥n y avalancha protegen contra ataques que intentan deducir patrones**.

---

### üß∞ Instalaci√≥n de herramientas (Python)

Vamos a usar la librer√≠a `pycryptodome`, que incluye implementaciones modernas de cifradores por bloques como AES.

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo completo en Python: Comparando propiedades

Vamos a ver c√≥mo un peque√±o cambio en el texto claro cambia completamente el texto cifrado (difusi√≥n y avalancha) usando **AES en modo ECB (no recomendado en producci√≥n, pero √∫til para estudiar)**.

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Random import get_random_bytes

# Clave de 16 bytes (128 bits)
clave = get_random_bytes(16)

# Mensajes similares
mensaje1 = b"HOLA MUNDO   "  # 12 bytes
mensaje2 = b"HOLA NUNDO   "  # solo cambia una letra: M -> N

# Rellenar mensajes a 16 bytes (bloque de AES)
mensaje1_padded = pad(mensaje1, 16)
mensaje2_padded = pad(mensaje2, 16)

# Crear cifrador AES en modo ECB (determin√≠stico)
cipher = AES.new(clave, AES.MODE_ECB)

# Cifrar ambos mensajes
cifrado1 = cipher.encrypt(mensaje1_padded)
cifrado2 = cipher.encrypt(mensaje2_padded)

# Mostrar resultados
print("üîê Cifrado de mensaje1:", cifrado1.hex())
print("üîê Cifrado de mensaje2:", cifrado2.hex())
print("\n¬øSon iguales?:", cifrado1 == cifrado2)
```

#### Salida esperada (ejemplo):

```
üîê Cifrado de mensaje1: 6c31...9aef
üîê Cifrado de mensaje2: 7b12...fd23
¬øSon iguales?: False
```

Esto demuestra:

- **Avalancha**: cambiar una letra cambia todo el cifrado.
- **Determinismo**: si se cifra dos veces el mismo mensaje con misma clave y modo ECB, da el mismo resultado.

---

### üìå Nota importante

- El **modo ECB** (Electronic Code Book) **no es seguro** para datos reales, porque **no oculta patrones**. Se usa aqu√≠ solo con fines educativos.
- En pr√°ctica se usan modos como **CBC**, **CTR**, **GCM** que s√≠ protegen contra ataques de an√°lisis.

---

### üß† Conclusi√≥n

| Propiedad      | Ejemplo pr√°ctico                                  |
| -------------- | ------------------------------------------------- |
| Difusi√≥n       | Cambio en una letra ‚Üí cifrado totalmente distinto |
| Avalancha      | 1 bit cambia ‚Üí mitad del resultado cambia         |
| Inversibilidad | El mensaje se puede recuperar con la clave        |
| Determinismo   | (en ECB) mismo mensaje = mismo resultado          |

---

[üîº](#√≠ndice)

---

## **412. Block Ciphers populares**

### üîê ¬øQu√© es un Block Cipher?

Un **Block Cipher** es un algoritmo de cifrado **sim√©trico** que toma bloques de texto plano (por ejemplo, de 64 o 128 bits) y los convierte en texto cifrado usando una **clave secreta**.

üîÅ La misma clave se usa tanto para cifrar como para descifrar.

---

### ‚≠ê Block Ciphers populares

Aqu√≠ te muestro los m√°s conocidos y usados, con explicaciones f√°ciles:

| Algoritmo    | A√±o  | Tama√±o de bloque | Tama√±o de clave  | ¬øD√≥nde se usa?                      |
| ------------ | ---- | ---------------- | ---------------- | ----------------------------------- |
| **DES**      | 1977 | 64 bits          | 56 bits          | Obsoleto, usado hist√≥ricamente      |
| **3DES**     | 1998 | 64 bits          | 112 o 168 bits   | Obsoleto, fue usado en banca y VPN  |
| **AES**      | 2001 | 128 bits         | 128/192/256 bits | Est√°ndar actual (WiFi, SSL, discos) |
| **Blowfish** | 1993 | 64 bits          | 32 a 448 bits    | VPN, software antiguo               |
| **Twofish**  | 1998 | 128 bits         | 128/192/256 bits | Alternativa a AES                   |
| **Camellia** | 2000 | 128 bits         | 128/192/256 bits | Recomendado en Jap√≥n y Europa       |
| **IDEA**     | 1991 | 64 bits          | 128 bits         | Fue usado en PGP                    |

---

### üß† Explicaci√≥n sencilla de los m√°s importantes

#### üîπ 1. **AES (Advanced Encryption Standard)**

- Reemplaz√≥ al DES por ser m√°s seguro y r√°pido.
- Usa bloques de **128 bits**.
- Claves de **128, 192 o 256 bits**.
- Altamente eficiente y resistente a ataques conocidos.

üß™ **Ejemplo real:**

Usado en HTTPS, WhatsApp, Zoom, discos duros encriptados (BitLocker, VeraCrypt), WiFi WPA2/WPA3.

---

#### üîπ 2. **3DES (Triple DES)**

- Aplica DES tres veces para mejorar la seguridad.
- Lento comparado con AES.
- Considerado **inseguro hoy en d√≠a** (desde 2018, NIST lo desaprueba).

üß™ **Ejemplo real:**

Se us√≥ en cajeros autom√°ticos, bancos y tarjetas inteligentes.

---

#### üîπ 3. **Blowfish**

- Libre y r√°pido.
- Bloques de 64 bits ‚Üí no recomendado para archivos grandes.
- Reemplazado por su sucesor: **Twofish**.

---

#### üîπ 4. **Twofish**

- Candidato finalista para reemplazar a DES (junto con AES).
- Muy seguro, y clave de hasta 256 bits.
- Ideal en sistemas embebidos o alternativos a AES.

---

#### üîπ 5. **Camellia**

- Seguridad similar a AES.
- Recomendado por la ISO y la Uni√≥n Europea.
- R√°pido en hardware y software.

---

### üß∞ Instalaci√≥n de herramientas para probarlos (Python)

Vamos a usar **`pycryptodome`**, una librer√≠a de Python que implementa muchos cifradores modernos:

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo completo: Cifrado y descifrado con AES

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

# Generar clave y datos
clave = get_random_bytes(16)  # 128 bits
datos = b"Hola, mundo secreto"

# Rellenar el mensaje para que sea m√∫ltiplo de 16
datos_padded = pad(datos, 16)

# Crear cifrador AES en modo ECB (para ejemplo sencillo)
cipher = AES.new(clave, AES.MODE_ECB)

# Cifrar
cifrado = cipher.encrypt(datos_padded)
print("üîê Cifrado:", cifrado.hex())

# Descifrar
cipher2 = AES.new(clave, AES.MODE_ECB)
descifrado = unpad(cipher2.decrypt(cifrado), 16)
print("üîì Descifrado:", descifrado.decode('utf-8'))
```

#### Salida esperada:

```
üîê Cifrado: 77a3efca9a6f1c38c5f0c4fcd71e2e...
üîì Descifrado: Hola, mundo secreto
```

---

### ‚ö†Ô∏è Nota sobre el modo ECB

- El modo ECB es **inseguro** porque no oculta patrones.
- En la pr√°ctica se usan modos como:

  - **CBC** (Cipher Block Chaining)
  - **CTR** (Counter Mode)
  - **GCM** (Galois Counter Mode)

---

### üß† Conclusi√≥n

| Algoritmo | ¬øSe usa hoy?   | Seguridad | Comentario              |
| --------- | -------------- | --------- | ----------------------- |
| AES       | ‚úÖ S√≠          | üîí Alta   | Est√°ndar global         |
| 3DES      | ‚ùå No          | ‚ö†Ô∏è D√©bil  | Obsoleto desde 2018     |
| Blowfish  | ‚ö†Ô∏è Menos       | Buena     | Reemplazado por Twofish |
| Twofish   | ‚úÖ Alternativa | üîí Alta   | Libre, r√°pido, flexible |
| Camellia  | ‚úÖ En uso      | üîí Alta   | Apoyo fuerte en Asia/UE |

---

[üîº](#√≠ndice)

---

## **413. DES (Data Encryption Standard)**

### üîê ¬øQu√© es DES?

**DES (Data Encryption Standard)** es un algoritmo de **cifrado sim√©trico por bloques**, publicado en 1977 por el **NIST**. Usa una **clave de 56 bits** (aunque originalmente son 64, 8 se usan para verificaci√≥n de paridad) y trabaja con **bloques de 64 bits** de datos.

#### üì¶ Caracter√≠sticas principales:

| Propiedad        | Valor                    |
| ---------------- | ------------------------ |
| Tipo             | Cifrado sim√©trico        |
| Tama√±o de bloque | 64 bits                  |
| Tama√±o de clave  | 56 bits efectivos        |
| Rondas           | 16 rondas                |
| Velocidad        | Razonable, pero obsoleto |

---

### üß† ¬øC√≥mo funciona DES (explicaci√≥n simple)?

1. **Entrada**: Un bloque de 64 bits (8 bytes de texto plano).
2. **Clave**: Una clave de 64 bits (de los cuales solo 56 se usan).
3. **Divisi√≥n**: El bloque se divide en dos mitades de 32 bits: izquierda (L) y derecha (R).
4. **16 rondas** de transformaci√≥n:

   - En cada ronda, se usa una subclave derivada de la clave original.
   - Se aplica una funci√≥n (F) a la mitad derecha y se combina con la mitad izquierda.

5. **Reuni√≥n final**: Se combinan ambas mitades, se aplica una permutaci√≥n final, y se obtiene el texto cifrado.

---

### üìõ ¬øPor qu√© ya no se usa DES?

Aunque fue un est√°ndar por d√©cadas, **DES fue roto en 1998** mediante fuerza bruta, debido a su **clave muy corta (56 bits)**. Hoy en d√≠a, no se considera seguro.

üëâ Por eso se desarrollaron alternativas como **3DES** y luego **AES**.

---

### üîß Instalaci√≥n para probar DES

Vamos a usar `pycryptodome`, una librer√≠a de Python para cifrado.

#### Paso 1: Instala la librer√≠a

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo completo: Cifrado y descifrado con DES

```python
from Crypto.Cipher import DES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

# DES necesita una clave de 8 bytes (64 bits)
clave = get_random_bytes(8)

# Mensaje a cifrar (debe ser m√∫ltiplo de 8 al final)
mensaje = b"Hola, mundo!"

# Rellenar (padding) a m√∫ltiplos de 8 bytes
mensaje_padded = pad(mensaje, 8)

# Crear el cifrador en modo ECB
cipher = DES.new(clave, DES.MODE_ECB)

# Cifrar el mensaje
cifrado = cipher.encrypt(mensaje_padded)
print("üîê Cifrado (hex):", cifrado.hex())

# Descifrar
cipher_dec = DES.new(clave, DES.MODE_ECB)
descifrado = unpad(cipher_dec.decrypt(cifrado), 8)
print("üîì Descifrado:", descifrado.decode('utf-8'))
```

---

### üß™ Salida esperada (var√≠a porque la clave es aleatoria)

```
üîê Cifrado (hex): 8e53a1f67c9e541c275149dfd183b703
üîì Descifrado: Hola, mundo!
```

---

### ‚ö†Ô∏è Seguridad de DES

- **Clave corta**: solo 56 bits ‚Üí vulnerable a fuerza bruta.
- **Reemplazado por 3DES** y luego **AES**.
- Solo se usa hoy en sistemas antiguos o para prop√≥sitos educativos.

---

### üß† Conclusi√≥n f√°cil

| Ventaja                     | Desventaja                    |
| --------------------------- | ----------------------------- |
| R√°pido y simple de entender | Clave muy corta (inseguro)    |
| Buena base para aprender    | Vulnerable a ataques modernos |
| Usado durante 20 a√±os       | Reemplazado por AES           |

---

[üîº](#√≠ndice)

---

## **414. Detalles del funcionamiento de DES**

### üîê ¬øQu√© es DES?

DES (**Data Encryption Standard**) es un algoritmo de cifrado **sim√©trico por bloques**. Eso significa que:

- Usa **la misma clave para cifrar y descifrar**.
- Cifra datos **en bloques de 64 bits (8 bytes)**.
- Utiliza una **clave de 64 bits**, aunque solo 56 son usados realmente (los otros 8 son bits de paridad).

---

### üß† ¬øC√≥mo funciona DES paso a paso?

Vamos a explicarlo **paso a paso**, con analog√≠as y ejemplos:

---

#### **Entrada: Texto claro de 64 bits**

Sup√≥n que queremos cifrar este texto:

```plaintext
Texto: "ABCDEFGH"
```

Cada car√°cter tiene 1 byte (8 bits), entonces en total son 8 bytes = 64 bits.

---

#### **Clave de 64 bits (8 bytes)**

Ejemplo:

```plaintext
Clave: "mi_clave" + un byte adicional
```

Pero solo se usan **56 bits** (7 bytes) realmente, el resto se usa para verificaci√≥n de paridad.

---

#### **Permutaci√≥n inicial (IP)**

Antes de comenzar, DES hace una **permutaci√≥n inicial** (reordena los bits del bloque de entrada). No cambia el contenido, solo el orden.

---

#### **Divisi√≥n en mitades: L0 y R0**

El bloque de 64 bits se divide en dos mitades de 32 bits:

- **L0** = izquierda (los primeros 32 bits)
- **R0** = derecha (los √∫ltimos 32 bits)

---

#### **16 rondas de Feistel**

DES hace **16 rondas**, y en cada una:

- Se genera una **subclave de 48 bits** desde la clave principal.
- Se aplica una **funci√≥n F** a la mitad derecha y se combina con la mitad izquierda.

##### Cada ronda:

```
Li = Ri-1
Ri = Li-1 XOR F(Ri-1, subclave_i)
```

La funci√≥n F hace esto:

1. **Expansi√≥n** de R: de 32 bits a 48 bits.
2. **XOR con subclave** (48 bits).
3. **Sustituci√≥n** con S-boxes (reduce de 48 a 32 bits).
4. **Permutaci√≥n**.

---

#### **Intercambio final y permutaci√≥n inversa**

Despu√©s de 16 rondas:

- Se intercambian las mitades una vez m√°s.
- Se aplica una permutaci√≥n inversa (IP‚Åª¬π) para obtener el bloque final cifrado.

---

### üßÆ Ejemplo visual simplificado

**Texto plano**: `"ABCDEFGH"` ‚Üí 64 bits

**Clave**: `"12345678"` (64 bits)

Despu√©s del proceso, podr√≠as obtener algo como:

**Texto cifrado (hexadecimal)**:

```
E.g.: 6AC5F149D1FE4379
```

---

### üîß Instalaci√≥n

Para experimentar con DES en Python:

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo completo en Python

```python
from Crypto.Cipher import DES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

# Paso 1: Generar una clave de 8 bytes (64 bits)
clave = get_random_bytes(8)
print("Clave:", clave.hex())

# Paso 2: Mensaje de prueba
mensaje = b"HolaMundo123"  # 11 bytes

# Paso 3: Padding (DES necesita m√∫ltiplos de 8 bytes)
mensaje_padded = pad(mensaje, 8)

# Paso 4: Crear el cifrador
cipher = DES.new(clave, DES.MODE_ECB)

# Paso 5: Cifrar
texto_cifrado = cipher.encrypt(mensaje_padded)
print("Texto cifrado (hex):", texto_cifrado.hex())

# Paso 6: Descifrar
cipher_dec = DES.new(clave, DES.MODE_ECB)
descifrado = unpad(cipher_dec.decrypt(texto_cifrado), 8)
print("Texto descifrado:", descifrado.decode())
```

---

#### üß™ Resultado esperado

```
Clave: b7e2f3a6c5d4e1f0
Texto cifrado (hex): 8a7b6f21ed34c5...
Texto descifrado: HolaMundo123
```

---

### ‚ö†Ô∏è Seguridad de DES hoy

- **DES es obsoleto**: Su clave de 56 bits es muy corta.
- En 1998, se construy√≥ una m√°quina que romp√≠a DES en menos de un d√≠a.
- Hoy usamos **AES** o **ChaCha20**.

---

### üß† Resumen

| Paso            | Explicaci√≥n                              |
| --------------- | ---------------------------------------- |
| Entrada         | Bloque de 64 bits (8 bytes)              |
| Clave           | 64 bits (solo 56 √∫tiles)                 |
| Rondas          | 16 rondas Feistel                        |
| Funci√≥n F       | Expansi√≥n ‚Üí XOR ‚Üí Sustituci√≥n ‚Üí Permutar |
| Resultado final | Bloque cifrado de 64 bits                |
| Implementaci√≥n  | Usando `pycryptodome` en Python          |

---

[üîº](#√≠ndice)

---

## **415. Ataques a DES**

### üß† ¬øQu√© es DES?

DES es un algoritmo de **cifrado sim√©trico por bloques** desarrollado en los a√±os 70. Utiliza:

- Bloques de **64 bits** de datos.
- Una clave de **64 bits**, de los cuales **56 bits son √∫tiles** (8 son de paridad).
- **16 rondas** de operaciones en estructura Feistel.

Aunque fue muy popular, **hoy est√° considerado inseguro**.

---

### üõ†Ô∏è ¬øPor qu√© DES es vulnerable?

Principalmente por su **tama√±o de clave corto**. Solo tiene 2‚Åµ‚Å∂ combinaciones posibles, lo que permite ataques **por fuerza bruta**.

2‚Åµ‚Å∂ ‚âà 72 cuatrillones de claves

Hoy, eso puede romperse en **horas o minutos** con computadoras modernas.

---

### üîì Principales ataques a DES

#### üî® **Ataque por Fuerza Bruta**

**Qu√© es**: Probar todas las claves posibles hasta encontrar la correcta.

**Ejemplo**:

Sup√≥n que el mensaje cifrado es `8A1B3C4D...`, y sabes que el texto plano original comienza con `"Hola"`. Puedes probar todas las combinaciones posibles de claves hasta que la desencriptaci√≥n coincida con `"Hola..."`.

üîß En 1998, la **EFF (Electronic Frontier Foundation)** construy√≥ una m√°quina que romp√≠a DES en menos de 24 horas.

---

#### üß† **Ataques de Texto Plano Conocido**

**Qu√© es**:

El atacante **sabe parte del mensaje original** (texto plano) y tambi√©n el mensaje cifrado correspondiente. As√≠ puede intentar recuperar la clave.

**Ejemplo f√°cil**:

- Texto plano: `"Inicio sesi√≥n: admin"`
- Texto cifrado: `F3C1B2...`

Si se tienen suficientes pares de texto plano y cifrado, se puede reconstruir la clave o reducir el espacio de b√∫squeda.

---

#### üîÅ **Ataque de Texto Cifrado Elegido**

**Qu√© es**:

El atacante **elige textos a cifrar** y obtiene los resultados cifrados, como en un sistema vulnerable tipo "encripta tu contrase√±a aqu√≠".

Esto permite estudiar c√≥mo se comporta el algoritmo y reconstruir la clave.

---

#### üß± **Criptoan√°lisis Diferencial**

**Qu√© es**:

T√©cnica que analiza **c√≥mo peque√±as diferencias en el texto plano afectan al texto cifrado**.

Se necesitan **muchos pares de datos cifrados** con diferencias controladas.

Esto fue una t√©cnica avanzada **dise√±ada por investigadores de IBM** y luego usada por la NSA.

---

### üõë ¬øPor qu√© NO se debe usar DES hoy?

| Motivo                        | Detalle                                |
| ----------------------------- | -------------------------------------- |
| Clave muy corta               | 56 bits son f√°ciles de romper hoy.     |
| Criptoan√°lisis efectivo       | Diferencial y lineal funcionan.        |
| Fuerza bruta acelerada        | Hardware moderno lo rompe r√°pidamente. |
| Sustituido por AES y ChaCha20 | M√°s r√°pidos, seguros y modernos.       |

---

### üîß ¬øC√≥mo simular un ataque a DES? (did√°ctico)

Para fines educativos, puedes hacer una **mini fuerza bruta** usando claves peque√±as, aunque no es realista para 2‚Åµ‚Å∂ claves.

#### üì¶ Instalaci√≥n

Usamos `pycryptodome`:

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo en Python: Mini fuerza bruta a DES

Vamos a usar claves de 8 bytes pero solo probar las primeras 1000 posibles (por simplicidad):

```python
from Crypto.Cipher import DES
from Crypto.Util.Padding import pad, unpad
from itertools import product
import string

# Mensaje original y clave real
clave_real = b'12345678'  # 8 bytes
mensaje = b"HolaDES123"

# Cifrado original
cipher = DES.new(clave_real, DES.MODE_ECB)
mensaje_padded = pad(mensaje, 8)
cifrado = cipher.encrypt(mensaje_padded)
print("Texto cifrado (hex):", cifrado.hex())

# Simulamos ataque por fuerza bruta (solo 3 caracteres para el demo)
alfabeto = string.digits
for k in product(alfabeto, repeat=3):
    intento = ''.join(k).ljust(8, '0')  # Rellenar con ceros hasta 8 bytes
    try:
        cipher_try = DES.new(intento.encode(), DES.MODE_ECB)
        descifrado = unpad(cipher_try.decrypt(cifrado), 8)
        if b"Hola" in descifrado:
            print(f"¬°Clave encontrada!: {intento}")
            print("Mensaje descifrado:", descifrado.decode())
            break
    except:
        continue
```

#### üß™ Resultado esperado (versi√≥n reducida):

```
Texto cifrado (hex): 8f4b1c...
¬°Clave encontrada!: 12300000
Mensaje descifrado: HolaDES123
```

---

### üõ°Ô∏è ¬øC√≥mo protegerse?

#### ‚úÖ Soluciones modernas:

| Soluci√≥n                | Descripci√≥n                                       |
| ----------------------- | ------------------------------------------------- |
| **AES (128, 192, 256)** | Algoritmo de cifrado moderno y seguro.            |
| **ChaCha20**            | R√°pido y seguro, ideal para dispositivos m√≥viles. |
| **Evitar modo ECB**     | Usa CBC, GCM o modos con IV aleatorio.            |
| **Contrase√±as fuertes** | Usa generadores seguros, no patrones simples.     |

---

### üìå Resumen Final

- **DES ya no es seguro**. Romperlo es factible hoy en d√≠a.
- **Fuerza bruta**, criptoan√°lisis y ataques con texto conocido son efectivos.
- Puedes simular ataques reducidos con Python para aprender.
- **Usa AES o ChaCha20** en sistemas modernos.

---

[üîº](#√≠ndice)

---

## **416. Triple DES**

### üîê ¬øQu√© es Triple DES?

**Triple DES (3DES)** es una versi√≥n m√°s segura del algoritmo original **DES** (Data Encryption Standard), que **cifra los datos tres veces** en lugar de una.

> üîé Se cre√≥ porque DES (con claves de 56 bits) se volvi√≥ inseguro ante ataques por fuerza bruta.

---

#### üß† ¬øC√≥mo funciona?

En lugar de cifrar una vez con una clave, 3DES **cifra, descifra y vuelve a cifrar** el mensaje, usando **tres claves diferentes** (o una clave dividida en partes).

**Esquema b√°sico (modo EDE):**

```
C = E(K3, D(K2, E(K1, P)))
```

Donde:

- `E = Encrypt`, `D = Decrypt`, `P = Plaintext`, `C = Ciphertext`
- `K1`, `K2`, `K3` son las claves (pueden ser iguales o distintas)
- Se cifra con `K1`, luego se descifra con `K2`, y se cifra otra vez con `K3`

---

### üîë Tipos de claves en Triple DES

| Tipo                            | Descripci√≥n                         |
| ------------------------------- | ----------------------------------- |
| **1 clave (K1 = K2 = K3)**      | Igual a DES, inseguro hoy           |
| **2 claves (K1 ‚â† K2, K3 = K1)** | Seguridad media                     |
| **3 claves distintas**          | Seguridad alta (168 bits efectivos) |

---

### ‚úÖ Ventajas y ‚ùå Desventajas

| ‚úÖ Ventajas                 | ‚ùå Desventajas                           |
| --------------------------- | ---------------------------------------- |
| M√°s seguro que DES          | M√°s lento que AES                        |
| F√°cil de implementar        | Usa bloques de 64 bits (menos eficiente) |
| Compatible con sistemas DES | Vulnerable a ataques de cumplea√±os       |

---

### üß™ Ejemplo pr√°ctico f√°cil de entender

Sup√≥n que quieres cifrar el mensaje:

```
Mensaje: "Hola mundo"
Clave1: "12345678"
Clave2: "abcdefgh"
Clave3: "ABCDEFGH"
```

Se cifra 3 veces con esas claves.

---

### üß∞ ¬øC√≥mo se ‚Äúinstala‚Äù o usa?

Usaremos **Python** y la librer√≠a `pycryptodome`, que permite trabajar con 3DES f√°cilmente.

#### üì¶ Instalaci√≥n

Primero, instala la librer√≠a:

```bash
pip install pycryptodome
```

---

### üßë‚Äçüíª Ejemplo completo en Python con Triple DES

```python
from Crypto.Cipher import DES3
from Crypto.Util.Padding import pad, unpad

# Mensaje a cifrar
mensaje = b"Hola mundo"

# Claves deben tener 16 o 24 bytes para 3DES
clave = b'12345678abcdefghABCDEFGH'  # 24 bytes = 3 claves de 8 bytes

# Crear objeto Triple DES
cipher = DES3.new(clave, DES3.MODE_ECB)

# Cifrado
mensaje_padded = pad(mensaje, 8)  # DES usa bloques de 8 bytes
cifrado = cipher.encrypt(mensaje_padded)
print("Cifrado (hex):", cifrado.hex())

# Descifrado
cipher2 = DES3.new(clave, DES3.MODE_ECB)
descifrado = unpad(cipher2.decrypt(cifrado), 8)
print("Descifrado:", descifrado.decode())
```

#### ‚úÖ Salida esperada:

```
Cifrado (hex): 2fa3d4...
Descifrado: Hola mundo
```

---

### üìå Consideraciones importantes

1. **Modo ECB** es el m√°s b√°sico pero **no recomendado** para producci√≥n. Usar CBC o GCM con un **IV aleatorio** es mejor.
2. **3DES est√° obsoleto**, aunque a√∫n es usado en sistemas antiguos.
3. Para nuevos proyectos se recomienda **AES** o **ChaCha20**.

---

### üõ°Ô∏è Alternativas modernas

| Algoritmo    | Longitud de clave  | Seguridad                       |
| ------------ | ------------------ | ------------------------------- |
| **AES**      | 128, 192, 256 bits | Muy alta                        |
| **ChaCha20** | 256 bits           | Alta y r√°pida                   |
| **3DES**     | 112 o 168 bits     | Aceptable pero lenta y obsoleta |

---

### üß† Resumen final

| Punto clave                          | Detalle                             |
| ------------------------------------ | ----------------------------------- |
| Triple DES = cifrar 3 veces          | E(K3, D(K2, E(K1, P)))              |
| Claves: 1, 2 o 3 distintas           | 3 claves = m√°s seguridad (168 bits) |
| Python lo soporta con `pycryptodome` | Usa `DES3.new()` y `pad/unpad`      |
| Mejor usar AES en nuevos sistemas    | M√°s r√°pido y seguro                 |

---

[üîº](#√≠ndice)

---

## **417. AES (Advanced Encryption Standard)**

### üîê ¬øQu√© es AES?

**AES** (Advanced Encryption Standard) es uno de los algoritmos de cifrado **m√°s usados y seguros del mundo**. Se utiliza para **proteger datos** en comunicaciones, discos, correos electr√≥nicos, aplicaciones bancarias, etc.

Fue adoptado por el **gobierno de EE.UU.** en 2001 como reemplazo del antiguo **DES**, que era vulnerable.

---

#### üìå Caracter√≠sticas principales de AES

| Caracter√≠stica      | Valor                                               |
| ------------------- | --------------------------------------------------- |
| Tipo de cifrado     | Sim√©trico (misma clave para cifrar y descifrar)     |
| Longitudes de clave | 128, 192 o 256 bits                                 |
| Tama√±o de bloque    | 128 bits (16 bytes)                                 |
| Velocidad           | R√°pido y eficiente                                  |
| Seguridad           | Muy alta (incluso contra ataques cu√°nticos b√°sicos) |

---

### üß† ¬øC√≥mo funciona AES?

AES **trabaja en bloques de 16 bytes** (128 bits). Usa una serie de transformaciones llamadas **rondas**, y cada tama√±o de clave tiene un n√∫mero diferente de rondas:

| Tama√±o de clave | Rondas |
| --------------- | ------ |
| 128 bits        | 10     |
| 192 bits        | 12     |
| 256 bits        | 14     |

Cada ronda hace:

1. **SubBytes**: Sustituye cada byte con otro usando una tabla fija.
2. **ShiftRows**: Mueve (rota) las filas de la matriz de bytes.
3. **MixColumns**: Mezcla los datos de cada columna.
4. **AddRoundKey**: Mezcla con una parte de la clave.

---

### üîë ¬øPor qu√© AES es seguro?

- Las transformaciones son no lineales y complejas.
- Soporta claves de 256 bits (inmune a ataques de fuerza bruta).
- Ha resistido an√°lisis cripto durante m√°s de 20 a√±os.

---

### üß™ Ejemplo simple de uso

Supongamos que quieres cifrar este texto:

```
Texto: "Hola mundo AES"
Clave: "EstaEsUnaClaveSegura123456" (32 bytes ‚Üí AES-256)
```

---

### üß∞ ¬øC√≥mo se instala y usa en Python?

Usaremos la biblioteca `pycryptodome`.

#### üì¶ Instalaci√≥n

Abre tu terminal y ejecuta:

```bash
pip install pycryptodome
```

---

### üßë‚Äçüíª Ejemplo completo en Python

Aqu√≠ ciframos y desciframos un mensaje con **AES en modo CBC**, que es m√°s seguro que ECB porque usa un IV (vector de inicializaci√≥n) aleatorio.

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

# Mensaje original
mensaje = b"Hola mundo AES"

# Clave de 32 bytes = AES-256
clave = b'EstaEsUnaClaveSegura1234567890!!'

# IV (vector de inicializaci√≥n) aleatorio de 16 bytes
iv = get_random_bytes(16)

# Crear objeto AES en modo CBC
cipher = AES.new(clave, AES.MODE_CBC, iv)

# Cifrar mensaje con padding
mensaje_padded = pad(mensaje, AES.block_size)
cifrado = cipher.encrypt(mensaje_padded)

print("Cifrado (hex):", cifrado.hex())

# Para descifrar
cipher2 = AES.new(clave, AES.MODE_CBC, iv)
descifrado = unpad(cipher2.decrypt(cifrado), AES.block_size)

print("Descifrado:", descifrado.decode())
```

---

#### ‚úÖ Salida esperada

```text
Cifrado (hex): 3a9b58ac53e9e7a4...
Descifrado: Hola mundo AES
```

---

### üîê Modos de operaci√≥n comunes

AES no se usa solo: necesita un **modo de operaci√≥n**:

| Modo | Descripci√≥n                           | Seguro para producci√≥n |
| ---- | ------------------------------------- | ---------------------- |
| ECB  | Cifra bloques por separado (inseguro) | ‚ùå                     |
| CBC  | Cifra cada bloque con el anterior     | ‚úÖ (con IV aleatorio)  |
| CTR  | Convierte AES en un stream cipher     | ‚úÖ                     |
| GCM  | Autenticado y r√°pido (usa IV + tag)   | ‚úÖ‚úÖ‚úÖ (preferido)     |

---

### üõ°Ô∏è Buenas pr√°cticas

- Usa **AES-256** si quieres m√°xima seguridad.
- Usa siempre un **IV aleatorio** (excepto en ECB).
- Nunca reutilices la misma clave + IV.
- Para producci√≥n: usa **modo GCM** porque da **autenticaci√≥n (integridad)** adem√°s del cifrado.

---

### üìå Resumen final

| Concepto                 | Explicaci√≥n breve                      |
| ------------------------ | -------------------------------------- |
| AES                      | Algoritmo de cifrado sim√©trico moderno |
| Bloques                  | 128 bits (16 bytes)                    |
| Claves                   | 128, 192, 256 bits                     |
| Modo recomendado         | GCM o CBC (con IV aleatorio)           |
| Implementaci√≥n en Python | Usando `pycryptodome`                  |

---

[üîº](#√≠ndice)

---

## **418. Detalles de las funciones de AES**

### üß† ¬øQu√© hace internamente AES?

AES **transforma bloques de texto plano en bloques cifrados** de 128 bits usando una clave de 128, 192 o 256 bits. Este proceso se realiza en **rondas** (entre 10 y 14, dependiendo del tama√±o de la clave), y cada ronda aplica una **serie de funciones internas**:

---

### üîÑ Funciones internas de AES

Cada ronda de AES aplica las siguientes 4 operaciones (excepto la √∫ltima, que omite una):

#### **SubBytes** (Sustituci√≥n no lineal)

üîπ **¬øQu√© hace?**

Sustituye cada byte de la matriz con otro seg√∫n una tabla (llamada **S-box**), fija y conocida.

üîπ **¬øPor qu√©?**

Introduce **no linealidad**, haciendo m√°s dif√≠cil para un atacante predecir los cambios.

üîπ **Ejemplo:**

Sup√≥n que un byte en la matriz vale `0x53`. En la S-box, eso se sustituye por `0xED`.

```txt
Entrada: 0x53
Salida:  0xED  ‚Üê seg√∫n la S-box
```

---

#### **ShiftRows** (Rotaci√≥n de filas)

üîπ **¬øQu√© hace?**

Rota los bytes en cada fila de la matriz hacia la izquierda:

- Fila 0: no se mueve.
- Fila 1: se rota 1 byte.
- Fila 2: se rota 2 bytes.
- Fila 3: se rota 3 bytes.

üîπ **¬øPor qu√©?**

Rompe la alineaci√≥n vertical y dispersa los datos.

üîπ **Ejemplo:**

Antes:

```
[ a  b  c  d ]
[ e  f  g  h ]
[ i  j  k  l ]
[ m  n  o  p ]
```

Despu√©s de ShiftRows:

```
[ a  b  c  d ]
[ f  g  h  e ]
[ k  l  i  j ]
[ p  m  n  o ]
```

---

#### **MixColumns** (Mezcla por columnas)

üîπ **¬øQu√© hace?**

Aplica una transformaci√≥n matem√°tica (multiplicaci√≥n en Galois Field) a cada **columna** de la matriz.

üîπ **¬øPor qu√©?**

Introduce **difusi√≥n**: un solo byte del texto afecta a varios bytes del bloque cifrado.

üîπ **Ejemplo simplificado:**

```txt
Entrada: columna [a, b, c, d]
Salida: columna [a', b', c', d'] ‚Üê mezcla calculada por f√≥rmula GF(2‚Å∏)
```

No es intuitivo ver el resultado sin c√°lculos complejos, pero la idea es que mezcla los 4 valores para dispersar la informaci√≥n.

---

#### **AddRoundKey** (XOR con parte de la clave)

üîπ **¬øQu√© hace?**

Cada byte del estado (matriz de 4x4 bytes) se mezcla con una parte de la clave mediante **XOR**.

üîπ **¬øPor qu√©?**

Introduce la clave al proceso de cifrado.

üîπ **Ejemplo:**

```txt
Estado:    0x3C
Clave:     0xA6
Resultado: 0x3C ^ 0xA6 = 0x9A
```

---

#### üîÅ ¬øCu√°ntas veces se repite esto?

| Tama√±o de clave | Rondas totales |
| --------------- | -------------- |
| 128 bits        | 10             |
| 192 bits        | 12             |
| 256 bits        | 14             |

- La **primera ronda** solo hace `AddRoundKey`.
- Las **intermedias** hacen las 4 funciones.
- La **√∫ltima ronda** omite `MixColumns`.

---

### üìä Estructura general de AES-128

```
Entrada: Texto plano (16 bytes)
‚Üì
AddRoundKey (clave inicial)
‚Üì
9 Rondas de:
    SubBytes
    ShiftRows
    MixColumns
    AddRoundKey
‚Üì
√öltima ronda (solo 3 pasos):
    SubBytes
    ShiftRows
    AddRoundKey
‚Üì
Salida: Texto cifrado
```

---

### üì¶ Instalaci√≥n para usar AES

Usaremos la biblioteca `pycryptodome`.

Inst√°lala con:

```bash
pip install pycryptodome
```

---

### üß™ Ejemplo completo en Python

Este c√≥digo muestra el cifrado AES-128 con clave de 16 bytes y modo ECB (educativo, **no seguro en producci√≥n**).

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

# Clave de 16 bytes = 128 bits
clave = b'ClaveDe16Bytes!!'

# Mensaje de prueba (menos de 16 bytes ‚Üí necesita padding)
mensaje = b"Hola AES"

# Rellenar mensaje a m√∫ltiplos de 16 bytes
mensaje_padded = pad(mensaje, AES.block_size)

# Crear objeto AES en modo ECB (solo para demostraci√≥n)
cipher = AES.new(clave, AES.MODE_ECB)

# Cifrar
cifrado = cipher.encrypt(mensaje_padded)
print("Texto cifrado (hex):", cifrado.hex())

# Descifrar
cipher2 = AES.new(clave, AES.MODE_ECB)
descifrado = unpad(cipher2.decrypt(cifrado), AES.block_size)
print("Texto descifrado:", descifrado.decode())
```

---

#### üõë Nota importante

ECB **no** es seguro en producci√≥n porque no usa IV y patrones se repiten. Usa CBC o GCM en la pr√°ctica.

---

### ‚úÖ Resumen

| Funci√≥n     | Qu√© hace                  | Por qu√© importa           |
| ----------- | ------------------------- | ------------------------- |
| SubBytes    | Sustituye bytes por otros | No linealidad (confusi√≥n) |
| ShiftRows   | Rota filas                | Dispersi√≥n (difusi√≥n)     |
| MixColumns  | Mezcla columnas           | M√°s difusi√≥n              |
| AddRoundKey | XOR con parte de la clave | Introduce secreto         |

---

[üîº](#√≠ndice)

---

## **419. Caso pr√°ctico: AES**

### üîê ¬øQu√© es AES?

**AES (Advanced Encryption Standard)** es un algoritmo de cifrado **sim√©trico** que transforma informaci√≥n legible (texto plano) en algo ilegible (texto cifrado) usando una **clave secreta compartida**.

üîë **Sim√©trico** = la misma clave sirve para **cifrar y descifrar**.

---

### üß† Caso pr√°ctico: ‚ÄúEncriptar contrase√±as de usuarios antes de guardarlas‚Äù

#### üéØ Objetivo:

Simular un sistema donde un usuario crea una cuenta, su contrase√±a se **cifra con AES**, y luego se puede **descifrar** solo con la clave.

> üö® _Nota:_ En el mundo real, **las contrase√±as se almacenan con funciones hash (como bcrypt)**, no cifradas. Este caso es educativo, tambi√©n aplicable a cifrado de mensajes, archivos, etc.

---

### ‚öôÔ∏è Instalaci√≥n

Primero, necesitas instalar la biblioteca **`pycryptodome`**, que contiene la implementaci√≥n de AES:

```bash
pip install pycryptodome
```

---

### üß© Elementos que usaremos

- **Clave secreta**: de 16, 24 o 32 bytes (AES-128, 192 o 256)
- **IV (vector de inicializaci√≥n)**: requerido en modos como CBC
- **Modo de cifrado**: usaremos **AES en modo CBC**, m√°s seguro que ECB
- **Relleno (padding)**: los datos deben ser m√∫ltiplos de 16 bytes

---

### ‚úÖ Ejemplo completo en Python

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

# 1. Supongamos que el usuario escribe una contrase√±a
password = "MiS3cret0!"  # texto plano

# 2. Convertimos a bytes
datos = password.encode()

# 3. Generamos una clave secreta de 16 bytes (AES-128)
clave = get_random_bytes(16)  # se debe guardar para descifrar despu√©s

# 4. Generamos un IV aleatorio (vector de inicializaci√≥n) de 16 bytes
iv = get_random_bytes(16)

# 5. Crear el objeto AES en modo CBC
cipher = AES.new(clave, AES.MODE_CBC, iv)

# 6. Cifrar el mensaje (con padding para completar a m√∫ltiplos de 16)
cifrado = cipher.encrypt(pad(datos, AES.block_size))

print("üîí Contrase√±a cifrada (hex):", cifrado.hex())

# 7. Para descifrar...
# Crear un nuevo objeto AES con la misma clave e IV
cipher_descifrado = AES.new(clave, AES.MODE_CBC, iv)

# 8. Descifrar y quitar el padding
descifrado = unpad(cipher_descifrado.decrypt(cifrado), AES.block_size)

print("üîì Contrase√±a descifrada:", descifrado.decode())
```

---

#### üß™ Salida esperada (var√≠a por el IV aleatorio):

```
üîí Contrase√±a cifrada (hex): 01ae9f89b7ef276cabf0c35dc419ab2b
üîì Contrase√±a descifrada: MiS3cret0!
```

---

### üõ°Ô∏è ¬øD√≥nde se usa AES en la vida real?

- Cifrado de archivos ZIP, PDF, y bases de datos
- Seguridad de comunicaciones (TLS/SSL)
- Mensajer√≠a cifrada (como WhatsApp)
- Tarjetas inteligentes (smart cards)
- Seguridad en discos duros (BitLocker, FileVault)

---

### üìå Recomendaciones

| Buenas pr√°cticas AES         | Descripci√≥n                                         |
| ---------------------------- | --------------------------------------------------- |
| Nunca uses ECB               | Usa CBC, GCM, o CTR ‚Äî ECB repite patrones           |
| Usa IV aleatorio y √∫nico     | Pero no necesitas mantenerlo en secreto             |
| Guarda la clave con cuidado  | Es la llave para recuperar la informaci√≥n           |
| Aplica padding               | Usa `pad` y `unpad` para asegurar bloques correctos |
| No uses AES para contrase√±as | Usa hashing como `bcrypt` o `argon2` en esos casos  |

---

### üß† ¬øQu√© aprendiste?

Has aplicado AES en un caso **realista y pr√°ctico**, entendiendo:

- Qu√© funciones necesita AES para funcionar
- Qu√© datos debes generar (clave, IV)
- C√≥mo cifrar y descifrar correctamente

---

[üîº](#√≠ndice)

---

## **420. Initialization Vector (IV)**

### üîê ¬øQu√© es un Initialization Vector (IV)?

El **IV (Initialization Vector)** o **Vector de Inicializaci√≥n** es un **valor aleatorio o pseudorrandom** que se utiliza **junto con una clave** para **cifrar datos** en muchos algoritmos de cifrado sim√©trico, como **AES en modo CBC, CFB, OFB y CTR**.

> üìå **Importante:** El IV no necesita ser secreto, pero **debe ser √∫nico y aleatorio para cada cifrado**.
>
> Si usas el mismo IV y la misma clave para cifrar dos mensajes diferentes, podr√≠as facilitar un ataque criptogr√°fico.

---

### üß† ¬øPor qu√© se necesita el IV?

Si ciframos dos mensajes iguales con la **misma clave**, **sin IV**, el resultado cifrado ser√≠a el mismo. Eso **filtra informaci√≥n**. El IV **asegura que los textos cifrados sean distintos**, incluso si el texto plano es igual.

---

### üèóÔ∏è ¬øD√≥nde se usa el IV?

El IV se usa en **modos de operaci√≥n de cifrado por bloques** como:

| Modo | ¬øUsa IV? | ¬øPara qu√© sirve el IV?                  |
| ---- | -------- | --------------------------------------- |
| ECB  | ‚ùå       | No usa IV (inseguro)                    |
| CBC  | ‚úÖ       | Cifra el primer bloque                  |
| CFB  | ‚úÖ       | Inicializa el primer bloque de feedback |
| OFB  | ‚úÖ       | Semilla para generar keystream          |
| CTR  | ‚úÖ       | Contador inicial                        |

---

### ‚öôÔ∏è Instalaci√≥n (si usas Python)

Usaremos la librer√≠a `pycryptodome` para el cifrado:

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo completo en Python

Cifraremos una contrase√±a usando AES en modo CBC con un IV aleatorio.

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

# Texto plano (ej. una contrase√±a)
texto_plano = "contrasena123"
datos = texto_plano.encode()

# Generamos una clave AES de 16 bytes (AES-128)
clave = get_random_bytes(16)

# Generamos un IV aleatorio de 16 bytes (para CBC)
iv = get_random_bytes(16)

# Creamos el objeto de cifrado AES en modo CBC
cifrador = AES.new(clave, AES.MODE_CBC, iv)

# Aplicamos padding al texto plano y lo ciframos
cifrado = cifrador.encrypt(pad(datos, AES.block_size))

# Mostramos resultados
print("Texto cifrado (hex):", cifrado.hex())
print("IV usado (hex):", iv.hex())

# üîì Desciframos
# Necesitamos usar el mismo IV y clave
descifrador = AES.new(clave, AES.MODE_CBC, iv)
descifrado = unpad(descifrador.decrypt(cifrado), AES.block_size)

print("Texto descifrado:", descifrado.decode())
```

---

#### üß™ Salida esperada (variable en cada ejecuci√≥n):

```
Texto cifrado (hex): 7c508fa8e7a7e27d15a82e2ad8bd6c50
IV usado (hex): 23fe3a8fbb3a7c0d7c52493303f2f312
Texto descifrado: contrasena123
```

---

### üìå Buenas pr√°cticas sobre el IV

| Pr√°ctica                                                                | ¬øPor qu√©?                           |
| ----------------------------------------------------------------------- | ----------------------------------- |
| Generar IV aleatorio para cada cifrado                                  | Asegura la unicidad y seguridad     |
| Usar un IV del tama√±o correcto (igual al tama√±o del bloque del cifrado) | AES = 16 bytes                      |
| Guardar o enviar el IV junto al mensaje cifrado                         | Es necesario para descifrar         |
| No reutilizar el IV con la misma clave                                  | Puede provocar ataques por patrones |

---

### üì¶ ¬øC√≥mo guardar o enviar el IV?

Como el IV no es secreto, puedes hacer cosas como:

```python
mensaje_final = iv + cifrado
```

Y al descifrar:

```python
iv_recibido = mensaje_final[:16]
cifrado_recibido = mensaje_final[16:]
```

---

### üß† ¬øQu√© aprendiste?

- El IV **agrega aleatoriedad y seguridad** al cifrado.
- Debe ser √∫nico por mensaje y tener el tama√±o adecuado.
- No es secreto, pero s√≠ esencial para descifrar.

---

[üîº](#√≠ndice)

---

## **421. Modos de operaci√≥n: ECB**

### üß† ¬øQu√© es ECB (Electronic Codebook Mode)?

**ECB (Electronic Codebook)** es uno de los modos de operaci√≥n de los **algoritmos de cifrado por bloques**, como AES o DES.

#### üîê ¬øC√≥mo funciona?

- Divide el mensaje en **bloques del mismo tama√±o** (por ejemplo, 16 bytes para AES).
- **Cada bloque** se cifra **de forma independiente** usando la **misma clave**.

> üßä Es como poner cada bloque en una caja fuerte separada, **todas con la misma llave**.

---

### üì¶ Ejemplo visual

Supongamos que queremos cifrar el mensaje:

```
"ATAQUEALAMANANA"
```

(AES trabaja con bloques de 16 bytes, este texto tiene 15, as√≠ que le aplicamos **padding** para que encaje).

Ahora lo dividimos en bloques:

```
[ATAQUEALAMANANA]
```

Como es un solo bloque (16 bytes), ECB lo cifra con la **misma clave**.

Pero si tuvi√©ramos:

```
ATAQUE A LA MA√ëANA EN EL PUENTE
```

Se dividir√≠a en bloques as√≠ (imaginando que cada bloque es de 8 letras):

```
[ATAQUE A] [ LA MA√ëA] [NA EN EL ] [PUENTE..]
```

Y **si se repite un bloque**, **el texto cifrado ser√° igual**, lo cual es **un gran problema** de seguridad.

---

### ‚ö†Ô∏è Problema de seguridad del ECB

**ECB no oculta patrones** en los datos. Esto puede ser **peligroso**.

#### Ejemplo famoso: imagen cifrada con ECB

Cuando una imagen (como el logo de Linux) se cifra en modo ECB, los **patrones visuales se mantienen**, aunque los colores cambien. No se ve igual, pero **la forma de Tux sigue all√≠**.

¬°Malo para la seguridad! üò¨

---

### ‚úÖ ¬øCu√°ndo usar ECB?

**NUNCA** en la pr√°ctica moderna, salvo en casos muy espec√≠ficos (como cifrado de claves o datos muy peque√±os y √∫nicos).

---

### ‚öôÔ∏è Instalaci√≥n del entorno (Python)

Usaremos `pycryptodome`, una librer√≠a para cifrado:

```bash
pip install pycryptodome
```

---

### üß™ Ejemplo completo en Python: AES en modo ECB

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

# Texto plano
texto = "ATAQUEALAMANANA"
datos = texto.encode()  # Convertimos a bytes

# Clave AES de 16 bytes (AES-128)
clave = get_random_bytes(16)

# Ciframos usando ECB
cifrador = AES.new(clave, AES.MODE_ECB)
cifrado = cifrador.encrypt(pad(datos, AES.block_size))

print("Texto cifrado (hex):", cifrado.hex())

# Desciframos
descifrador = AES.new(clave, AES.MODE_ECB)
descifrado = unpad(descifrador.decrypt(cifrado), AES.block_size)

print("Texto descifrado:", descifrado.decode())
```

---

#### üßæ Salida esperada:

```
Texto cifrado (hex): 8f763f542bf64a70c8f172c13886f96e
Texto descifrado: ATAQUEALAMANANA
```

---

### üìå Resumen r√°pido:

| Caracter√≠stica                           | ECB          |
| ---------------------------------------- | ------------ |
| ¬øDivide en bloques?                      | ‚úÖ           |
| ¬øCada bloque se cifra igual si es igual? | ‚ùå inseguro  |
| ¬øUsa IV?                                 | ‚ùå           |
| ¬øSe recomienda en la pr√°ctica?           | ‚ùå No        |
| ¬øEs simple de usar?                      | ‚úÖ Muy f√°cil |

---

### ‚úÖ Conclusi√≥n

- ECB es **el modo m√°s b√°sico**, pero tambi√©n **el m√°s inseguro**.
- Es √∫til **para entender** c√≥mo funciona el cifrado por bloques.
- **Nunca lo uses para cifrar archivos, mensajes o im√°genes reales.**

---

[üîº](#√≠ndice)

---

## **422. Modos de operaci√≥n: CBC**

### üîê ¬øQu√© es CBC?

**CBC (Cipher Block Chaining)** es un **modo de operaci√≥n** para algoritmos de cifrado por bloques como AES. Es mucho m√°s seguro que ECB porque **agrega dependencia entre los bloques cifrados**.

#### üß† Idea b√°sica:

Cada bloque de texto plano se **XORea con el bloque cifrado anterior** antes de cifrarlo. As√≠, **aunque dos bloques de texto plano sean iguales, los bloques cifrados ser√°n diferentes**, si el anterior fue distinto.

---

### üßä Flujo del cifrado CBC

Sup√≥n que tienes estos bloques de texto plano (en letras para simplificar):

```
Bloque 1: ATAQUEEN
Bloque 2: LAMA√ëANA
```

Y un **IV (vector de inicializaci√≥n)** de 16 bytes aleatorios:

1. Se hace:

   `Bloque1 XOR IV ‚Üí resultado ‚Üí cifrar con clave ‚Üí C1 (primer bloque cifrado)`

2. Luego:

   `Bloque2 XOR C1 ‚Üí resultado ‚Üí cifrar con clave ‚Üí C2`

üîÅ Y as√≠ con todos los bloques siguientes.

---

### üì¶ ¬øQu√© es el IV?

**IV (Vector de Inicializaci√≥n)** es como una "semilla aleatoria" que se aplica **solo al primer bloque** para garantizar que incluso si cifras el mismo mensaje otra vez, **el resultado sea diferente**.

> üîê Muy importante: **El IV no es secreto**, pero **debe ser aleatorio y √∫nico** para cada mensaje.

---

### ‚úÖ Ventajas de CBC

- Evita que bloques iguales produzcan bloques cifrados iguales.
- Mucho m√°s seguro que ECB.
- Ideal para cifrar archivos, contrase√±as o textos largos.

### ‚ö†Ô∏è Desventajas

- No se puede paralelizar f√°cilmente el cifrado.
- Requiere IV.
- Un error en un bloque afecta el siguiente.

---

### üõ† Instalaci√≥n del entorno (Python)

Instalamos la librer√≠a `pycryptodome`:

```bash
pip install pycryptodome
```

---

### üß™ Ejemplo completo en Python: AES en modo CBC

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

# Texto plano
texto = "ATAQUE A LA MA√ëANA"
datos = texto.encode()

# Clave AES de 16 bytes (AES-128)
clave = get_random_bytes(16)

# IV de 16 bytes aleatorios
iv = get_random_bytes(16)

# Cifrado
cifrador = AES.new(clave, AES.MODE_CBC, iv)
cifrado = cifrador.encrypt(pad(datos, AES.block_size))

print("Texto cifrado (hex):", cifrado.hex())

# Descifrado
descifrador = AES.new(clave, AES.MODE_CBC, iv)
descifrado = unpad(descifrador.decrypt(cifrado), AES.block_size)

print("Texto descifrado:", descifrado.decode())
```

---

#### üßæ Salida esperada:

```
Texto cifrado (hex): 3fa21b7c... ‚Üê cambia cada vez por el IV
Texto descifrado: ATAQUE A LA MA√ëANA
```

---

### üß† ¬øQu√© pasar√≠a si cambiamos una letra?

Supongamos que cambiamos solo una letra del texto original. El resultado cifrado ser√° **completamente diferente**, debido al **encadenamiento de bloques (CBC)**.

---

### üìå Resumen:

| Concepto                                                 | CBC Mode                           |
| -------------------------------------------------------- | ---------------------------------- |
| Usa IV                                                   | ‚úÖ S√≠, obligatorio                 |
| Bloques cifrados iguales si bloques de texto son iguales | ‚ùå No (m√°s seguro)                 |
| Necesita padding                                         | ‚úÖ S√≠                              |
| Se puede paralelizar                                     | ‚ùå Solo en descifrado              |
| ¬øSe recomienda en pr√°ctica?                              | ‚úÖ S√≠ (aunque hoy se prefiere GCM) |

---

### üéØ Conclusi√≥n:

- CBC es mucho m√°s seguro que ECB.
- Muy usado para cifrar archivos, bases de datos o transmisiones.
- Es importante usar un **IV diferente cada vez**.
- El mismo mensaje cifrado dos veces con CBC generar√° **dos salidas distintas**.

---

[üîº](#√≠ndice)

---

## **423. Modos de operaci√≥n: CFB**

### üîê ¬øQu√© es el modo CFB?

**CFB (Cipher Feedback Mode)** es un **modo de operaci√≥n** que permite usar un **cifrado por bloques (como AES o DES) para trabajar como si fuera un cifrado por flujo**. Es decir, **procesa los datos en trozos m√°s peque√±os (bits o bytes)** en lugar de por bloques enteros, aunque internamente sigue usando bloques.

---

### üì¶ ¬øPor qu√© usar CFB?

- Permite cifrar **datos en tiempo real**, como en comunicaciones por red o mensajes de texto.
- No requiere padding, ya que se puede cifrar en segmentos menores al tama√±o del bloque (por ejemplo, byte a byte).
- Se puede usar para cifrar **textos de longitud variable**, incluso sin saber el tama√±o del mensaje.

---

### üîÅ ¬øC√≥mo funciona el CFB?

#### Supongamos que estamos usando AES de 128 bits (16 bytes) y queremos cifrar un mensaje de 3 bloques:

1. **Inicio**:

   - Usamos un **IV (Vector de Inicializaci√≥n)** de 16 bytes.
   - El primer paso es cifrar el IV con AES.
   - Luego se toma el resultado y se hace un XOR con el primer bloque del texto plano ‚Üí se obtiene el primer bloque cifrado.

2. **Despu√©s**:

   - El resultado del XOR (el bloque cifrado) **se vuelve a cifrar**, y el resultado se hace XOR con el siguiente bloque de texto plano, y as√≠ sucesivamente.

---

#### ‚úèÔ∏è Ejemplo visual (simplificado):

Supongamos:

- Texto plano: `"HOLA"`
- Clave AES: `"clave1234567890"`
- IV: `"IV12345678901234"`

##### Paso 1:

```
Cifrar(IV) ‚Üí resultado1
resultado1 XOR 'H' ‚Üí C1
```

##### Paso 2:

```
Cifrar(C1) ‚Üí resultado2
resultado2 XOR 'O' ‚Üí C2
```

Y as√≠ sucesivamente...

---

### ‚öñÔ∏è Ventajas y desventajas

| Ventajas                           | Desventajas                            |
| ---------------------------------- | -------------------------------------- |
| No requiere padding                | Los errores de transmisi√≥n se propagan |
| Funciona como un cifrado por flujo | Cifrado y descifrado no son sim√©tricos |
| Adecuado para transmisi√≥n de datos | Un solo bit alterado da√±a varios bits  |

---

### üì• Instalaci√≥n (en Python)

Usaremos la librer√≠a `pycryptodome`, que contiene funciones para AES y CFB.

```bash
pip install pycryptodome
```

---

### ‚úÖ Ejemplo completo: Cifrado y descifrado en modo CFB con AES

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

# Texto plano a cifrar
mensaje = b"HOLA MUNDO DESDE CFB"

# Clave de 16 bytes para AES-128
clave = get_random_bytes(16)

# IV (vector de inicializaci√≥n)
iv = get_random_bytes(16)

# Crear cifrador en modo CFB
cifrador = AES.new(clave, AES.MODE_CFB, iv)

# Cifrado
cifrado = cifrador.encrypt(mensaje)

print("Texto cifrado (hex):", cifrado.hex())

# Crear descifrador con la misma clave e IV
descifrador = AES.new(clave, AES.MODE_CFB, iv)

# Descifrado
descifrado = descifrador.decrypt(cifrado)

print("Texto descifrado:", descifrado.decode())
```

---

#### üí° Resultado t√≠pico:

```
Texto cifrado (hex): 8f2c4a02f7ae19dca9...
Texto descifrado: HOLA MUNDO DESDE CFB
```

> üîê **IMPORTANTE:** El mismo texto cifrado con la misma clave, pero con un IV diferente, **genera resultados distintos**, lo cual ayuda a la seguridad.

---

### üß† Resumen de CFB

| Caracter√≠stica        | Valor                          |
| --------------------- | ------------------------------ |
| Usa IV                | ‚úÖ S√≠                          |
| Requiere padding      | ‚ùå No                          |
| Puede cifrar flujos   | ‚úÖ S√≠ (byte a byte)            |
| Propaga errores       | ‚ö†Ô∏è S√≠, en los siguientes bytes |
| Se usa en la pr√°ctica | ‚úÖ Comunicaciones seguras      |

---

### üìå Cu√°ndo usar CFB

- Cuando se quiere cifrar texto o datos en tiempo real (mensajer√≠a, transmisi√≥n de voz).
- Cuando no se conoce de antemano el tama√±o total del mensaje.
- En aplicaciones donde no se quiere usar padding (relleno) como en ECB o CBC.

---

[üîº](#√≠ndice)

---

## **424. Modos de operaci√≥n: OFB**

### üîê ¬øQu√© es el modo OFB?

**OFB (Output Feedback)** es un **modo de operaci√≥n** que convierte un **cifrado por bloques** (como AES) en un **cifrado por flujo**. Es decir, permite cifrar datos poco a poco (byte a byte o bit a bit), sin necesidad de procesar bloques enteros de una sola vez.

---

### ‚öôÔ∏è ¬øC√≥mo funciona el modo OFB?

A diferencia de otros modos como CBC o CFB, **en OFB el texto cifrado anterior NO se usa como entrada para el siguiente paso**. En cambio, el resultado del **cifrado del bloque anterior** se usa como entrada para el siguiente.

#### Pasos:

1. Se elige un **IV (vector de inicializaci√≥n)**.
2. El IV se cifra con la clave secreta usando AES (u otro algoritmo).
3. El resultado se llama "salida intermedia" (output feedback).
4. Esa salida se **hace XOR con el texto plano** para obtener el texto cifrado.
5. Luego, se **vuelve a cifrar la salida anterior** (no el texto cifrado) y se repite.

---

### üß† Diferencia clave

- En **CFB**, se cifra el texto cifrado anterior.
- En **OFB**, se cifra la **salida cifrada anterior**.

---

### üîÅ Ejemplo conceptual paso a paso:

Sup√≥n que queremos cifrar `"HOLA"` con una clave y un IV.

- Texto plano: `H O L A`
- IV: `IV0`
- Clave: `K`

#### Proceso:

1. `S1 = Cifrar(IV0, K)`
2. `C1 = H XOR S1`
3. `S2 = Cifrar(S1, K)`
4. `C2 = O XOR S2`
5. `S3 = Cifrar(S2, K)`
6. `C3 = L XOR S3`
7. ...

---

### ‚úÖ Ventajas de OFB

| Ventaja                       | Descripci√≥n                                             |
| ----------------------------- | ------------------------------------------------------- |
| üîÑ Cifrado por flujo          | Puedes cifrar poco a poco, √∫til para streaming.         |
| ‚ùå Sin padding                | No necesita rellenar el mensaje para completar bloques. |
| ‚úÖ Sin propagaci√≥n de errores | Si un bit se da√±a, solo afecta a ese bit.               |

---

### ‚ö†Ô∏è Desventajas de OFB

| Desventaja                         | Descripci√≥n                                                    |
| ---------------------------------- | -------------------------------------------------------------- |
| ‚ùó Si el IV se repite, es inseguro | Usar el mismo IV con la misma clave puede romper la seguridad. |
| ‚Ü©Ô∏è No permite cifrado paralelo     | Como cada paso depende del anterior, es m√°s lento en hardware. |

---

### üì• Instalaci√≥n (Python)

Usaremos la librer√≠a `pycryptodome`.

```bash
pip install pycryptodome
```

---

### üß™ Ejemplo completo en Python

Cifrar y descifrar un mensaje con **AES en modo OFB**:

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

# Texto plano
mensaje = b"Hola desde modo OFB"

# Clave de 16 bytes para AES-128
clave = get_random_bytes(16)

# IV (vector de inicializaci√≥n) de 16 bytes
iv = get_random_bytes(16)

# Cifrado
cifrador = AES.new(clave, AES.MODE_OFB, iv)
cifrado = cifrador.encrypt(mensaje)
print("Texto cifrado (hex):", cifrado.hex())

# Descifrado (necesita la misma clave e IV)
descifrador = AES.new(clave, AES.MODE_OFB, iv)
descifrado = descifrador.decrypt(cifrado)
print("Texto descifrado:", descifrado.decode())
```

---

#### üîé Resultado t√≠pico

```
Texto cifrado (hex): 1a4c7e...
Texto descifrado: Hola desde modo OFB
```

---

### üìå ¬øCu√°ndo usar OFB?

Usa OFB cuando:

- Necesitas cifrar datos **en tiempo real** (como voz o video en streaming).
- Quieres **evitar padding** (relleno).
- Quieres evitar propagaci√≥n de errores (por ejemplo, en redes inestables).

---

### üß† Resumen

| Propiedad                       | Valor |
| ------------------------------- | ----- |
| Usa IV                          | ‚úÖ S√≠ |
| Padding necesario               | ‚ùå No |
| Cifrado por flujo               | ‚úÖ S√≠ |
| Errores se propagan             | ‚ùå No |
| Cifrado y descifrado sim√©tricos | ‚úÖ S√≠ |

---

[üîº](#√≠ndice)

---

## **425. Modos de operaci√≥n: CTR**

### üîê ¬øQu√© es el modo CTR?

**CTR (Counter Mode)** es un **modo de operaci√≥n para cifrados por bloques** (como AES) que transforma el cifrado en **uno de flujo**. A diferencia de modos como ECB o CBC, **CTR es r√°pido, permite paralelismo y no necesita padding**.

---

### üß† ¬øC√≥mo funciona el CTR?

En lugar de cifrar directamente el bloque de texto plano, en **CTR se cifra un contador (counter)**. El resultado se **XORea** con el texto plano para obtener el texto cifrado.

#### üìã Pasos:

1. Se genera un **Nonce** (valor aleatorio √∫nico) y un **contador** que empieza desde 0.
2. Se **cifra el Nonce + contador** con la clave.
3. El resultado se **XORea** con el bloque del texto plano.
4. El contador se incrementa y se repite el proceso.

> üìå _Nonce = ‚ÄúNumber used once‚Äù ‚Üí Nunca debe repetirse con la misma clave._

---

### ‚úÖ Ventajas del modo CTR

| Ventaja                                  | Explicaci√≥n                                   |
| ---------------------------------------- | --------------------------------------------- |
| üîÅ Cifrado por flujo                     | Puedes cifrar bloques de longitud arbitraria. |
| ‚ö° R√°pido y paralelizable                | No depende de bloques anteriores.             |
| ‚ùå No necesita padding                   | Se adapta a cualquier longitud.               |
| üîÑ Mismo proceso para cifrar y descifrar | Solo se hace XOR.                             |

---

### ‚ö†Ô∏è Desventajas

| Desventaja                                  | Explicaci√≥n                                              |
| ------------------------------------------- | -------------------------------------------------------- |
| ‚ùó Si se repite el Nonce + clave ‚Üí inseguro | Dos mensajes con el mismo nonce y clave pueden romperse. |
| üì¶ Requiere sincronizaci√≥n                  | Ambos extremos deben conocer el mismo contador y nonce.  |

---

### üîÅ Ejemplo paso a paso (conceptual)

Sup√≥n que queremos cifrar `"HOLA"` con una clave `K` y un Nonce `N`.

- Paso 1: Contador = 0 ‚Üí Entrada = N + 0
- Paso 2: Salida = AES(K, Entrada)
- Paso 3: `C1 = H XOR AES(K, N+0)`

Repetimos para cada bloque:

- `C2 = O XOR AES(K, N+1)`
- `C3 = L XOR AES(K, N+2)`
- `C4 = A XOR AES(K, N+3)`

---

### üß∞ Instalaci√≥n (en Python)

Usaremos la librer√≠a `pycryptodome` para usar AES en modo CTR:

```bash
pip install pycryptodome
```

---

### üß™ Ejemplo completo en Python (cifrado y descifrado)

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util import Counter

# Texto plano
mensaje = b"Hola desde modo CTR en AES"

# Clave de 16 bytes para AES-128
clave = get_random_bytes(16)

# Nonce de 8 bytes (importante: debe ser √∫nico por clave)
nonce = get_random_bytes(8)

# Creamos el contador con el nonce
contador = Counter.new(64, prefix=nonce)

# Cifrado
cifrador = AES.new(clave, AES.MODE_CTR, counter=contador)
cifrado = cifrador.encrypt(mensaje)
print("Texto cifrado (hex):", cifrado.hex())

# Para descifrar, reiniciamos el contador con el mismo nonce
contador_dec = Counter.new(64, prefix=nonce)
descifrador = AES.new(clave, AES.MODE_CTR, counter=contador_dec)
descifrado = descifrador.decrypt(cifrado)
print("Texto descifrado:", descifrado.decode())
```

---

### üîé Resultado esperado:

```
Texto cifrado (hex): 4f1e9a2a...
Texto descifrado: Hola desde modo CTR en AES
```

---

### üìå ¬øCu√°ndo usar CTR?

Usa CTR cuando:

- Necesitas **alt√≠simo rendimiento** (cifrado en paralelo).
- No quieres lidiar con **padding**.
- Quieres cifrar **grandes vol√∫menes de datos** r√°pidamente (por ejemplo, en discos o VPNs).

---

### üß† Resumen final

| Propiedad           | CTR                                |
| ------------------- | ---------------------------------- |
| Padding necesario   | ‚ùå No                              |
| Cifrado por bloques | ‚úÖ S√≠, pero se comporta como flujo |
| Paralelismo         | ‚úÖ S√≠                              |
| Errores se propagan | ‚ùå No                              |
| Uso com√∫n           | VPNs, discos, protocolos modernos  |

---

[üîº](#√≠ndice)

---

## **426. Cu√°ndo usar criptosistemas sim√©tricos**

### üîê ¬øQu√© es un criptosistema sim√©trico?

Un **criptosistema sim√©trico** es un sistema de cifrado donde **la misma clave se usa tanto para cifrar como para descifrar**.

#### üìå Ejemplos populares:

- **AES** (Advanced Encryption Standard)
- **DES** y **Triple DES**
- **ChaCha20**
- **RC4** (ya no recomendado)

---

### ‚úÖ ¬øCu√°ndo usar criptosistemas sim√©tricos?

#### üîí **Cuando ambos extremos conf√≠an y pueden compartir una clave secreta**

- Ideal en sistemas **cerrados** o **controlados** (como una empresa o un servidor con sus clientes autorizados).

üì¶ **Ejemplo**: un banco que transmite datos entre su base de datos y su sistema interno.

---

#### ‚ö° **Cuando se necesita velocidad y eficiencia**

- Los criptosistemas sim√©tricos son **mucho m√°s r√°pidos** que los asim√©tricos (como RSA).

üì¶ **Ejemplo**: cifrado de discos duros o transmisi√≥n de video en tiempo real.

---

#### üìÅ **Cuando se manejan grandes vol√∫menes de datos**

- Son m√°s eficientes para cifrar **archivos grandes**, como backups, archivos multimedia, logs, etc.

üì¶ **Ejemplo**: servicios de almacenamiento como Google Drive o Dropbox cifran archivos en sus servidores usando AES.

---

#### üß© **Cuando se combina con criptograf√≠a asim√©trica**

- En muchas aplicaciones, se usa un **sistema h√≠brido**:

  - El canal se asegura con criptograf√≠a asim√©trica (como TLS/SSL),
  - Luego, se establece una clave sim√©trica para el resto de la sesi√≥n.

üì¶ **Ejemplo**: HTTPS en navegadores.

---

### ‚ùå ¬øCu√°ndo NO usar criptosistemas sim√©tricos?

| Situaci√≥n                                       | ¬øPor qu√© no es ideal?                                                                   |
| ----------------------------------------------- | --------------------------------------------------------------------------------------- |
| üîë No puedes compartir la clave de forma segura | No hay forma de que ambos extremos obtengan la clave sin que un atacante la intercepte. |
| üë• Comunicaci√≥n abierta entre desconocidos      | No se puede confiar en que todos manejen la misma clave secreta.                        |
| üîê Necesitas autenticaci√≥n del emisor           | No puedes saber _qui√©n_ cifr√≥ el mensaje (a diferencia de firmas digitales).            |

---

### üì¶ Instalaci√≥n y uso en Python (con `pycryptodome`)

#### Instalaci√≥n:

```bash
pip install pycryptodome
```

---

### üß™ Ejemplo completo: cifrado y descifrado con AES

Vamos a cifrar un mensaje con **AES en modo CBC**, un modo sim√©trico muy utilizado.

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

# Mensaje a cifrar
mensaje = b"Mensaje secreto que vamos a cifrar"

# Clave de 16 bytes (128 bits)
clave = get_random_bytes(16)

# IV (vector de inicializaci√≥n) de 16 bytes
iv = get_random_bytes(16)

# Crear objeto AES en modo CBC
cifrador = AES.new(clave, AES.MODE_CBC, iv)

# Cifrar el mensaje (lo rellenamos para que sea m√∫ltiplo de 16)
cifrado = cifrador.encrypt(pad(mensaje, AES.block_size))

print("Texto cifrado (hex):", cifrado.hex())

# Para descifrar, usamos la misma clave e IV
descifrador = AES.new(clave, AES.MODE_CBC, iv)
descifrado = unpad(descifrador.decrypt(cifrado), AES.block_size)

print("Texto descifrado:", descifrado.decode())
```

#### üîé Resultado esperado:

```
Texto cifrado (hex): 2e1ab7f3...
Texto descifrado: Mensaje secreto que vamos a cifrar
```

---

### üìå Resumen Final

| Situaci√≥n ideal para usar criptosimetr√≠a | Ejemplo                    |
| ---------------------------------------- | -------------------------- |
| Comunicaci√≥n interna en redes confiables | Intranet de una empresa    |
| Grandes vol√∫menes de datos               | Cifrado de discos, backups |
| Velocidad necesaria                      | Streaming, VPN             |
| Sesi√≥n segura tras autenticaci√≥n p√∫blica | HTTPS con AES              |

---

[üîº](#√≠ndice)

---

## **427. Criptosistemas asim√©tricos o de clave p√∫blica**

### üîê ¬øQu√© es un criptosistema asim√©trico?

Un **criptosistema asim√©trico** usa **dos claves diferentes**:

- üîë **Clave p√∫blica**: se comparte con cualquiera.
- üîê **Clave privada**: se guarda en secreto.

Estas claves est√°n **matem√°ticamente relacionadas**, pero **no puedes obtener la privada a partir de la p√∫blica** (al menos no f√°cilmente).

---

### üì§ ¬øC√≥mo funciona?

1. **Cifrado:**

   - El emisor **usa la clave p√∫blica del receptor** para cifrar el mensaje.
   - Solo el receptor, con su **clave privada**, puede descifrarlo.

2. **Firmas digitales:**

   - El emisor **firma** con su **clave privada**.
   - Cualquiera puede verificar la firma usando la **clave p√∫blica** del emisor.

---

### üéØ ¬øCu√°ndo se usa?

- Cuando **dos personas no se conocen**, pero quieren comunicarse de forma segura.
- Cuando se necesita **autenticidad y no repudio** (firmas digitales).
- Para **intercambiar claves sim√©tricas** de forma segura (ej. HTTPS).

---

### üß† Ejemplo f√°cil

Imagina que Mar√≠a quiere enviarle un mensaje a Juan:

- Juan genera un **par de claves**:

  üîê clave privada ‚Üí guarda en secreto

  üîë clave p√∫blica ‚Üí se la da a Mar√≠a

- Mar√≠a **cifra el mensaje** con la **clave p√∫blica de Juan**.

- Solo **Juan** puede **descifrarlo** con su **clave privada**.

---

### üõ†Ô∏è Instalaci√≥n en Python

Vamos a usar la librer√≠a `cryptography`.

#### üì¶ Instalaci√≥n:

```bash
pip install cryptography
```

---

### üß™ Ejemplo completo paso a paso

#### üîß 1. Generar claves p√∫blica y privada

```python
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

# Generar clave privada
clave_privada = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048
)

# Extraer clave p√∫blica
clave_publica = clave_privada.public_key()

# Mostrar en formato PEM
clave_privada_pem = clave_privada.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.TraditionalOpenSSL,
    encryption_algorithm=serialization.NoEncryption()
)

clave_publica_pem = clave_publica.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)

print("Clave privada:\n", clave_privada_pem.decode())
print("Clave p√∫blica:\n", clave_publica_pem.decode())
```

---

#### üîê 2. Cifrar un mensaje con la clave p√∫blica

```python
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes

mensaje = b"Hola Juan, este es un mensaje secreto."

# Cifrado
mensaje_cifrado = clave_publica.encrypt(
    mensaje,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

print("Mensaje cifrado:", mensaje_cifrado.hex())
```

---

#### üîì 3. Descifrar el mensaje con la clave privada

```python
mensaje_descifrado = clave_privada.decrypt(
    mensaje_cifrado,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

print("Mensaje descifrado:", mensaje_descifrado.decode())
```

---

### üìå Resumen de ventajas

| Ventaja                                       | Explicaci√≥n                                  |
| --------------------------------------------- | -------------------------------------------- |
| üîë No es necesario compartir la clave privada | Solo se comparte la clave p√∫blica            |
| üîí Seguridad para iniciar comunicaciones      | Aunque no haya confianza previa              |
| üßæ Firmas digitales                           | Permite verificar identidad y evitar repudio |
| üîÅ Combinaci√≥n con criptograf√≠a sim√©trica     | Ej. HTTPS, SSH, VPN, etc.                    |

---

### ‚ö†Ô∏è Desventajas

- M√°s **lento** que los sistemas sim√©tricos.
- Requiere gesti√≥n de **pares de claves**.
- No es pr√°ctico para **cifrar archivos grandes directamente**.

---

### üìö Ejemplo en la vida real

- **Correo seguro**: GPG o PGP usa claves p√∫blicas para que cualquiera pueda enviarte un mensaje cifrado.
- **HTTPS (SSL/TLS)**: tu navegador cifra la conexi√≥n usando la clave p√∫blica del servidor.
- **Firmas digitales de software**: aseguran que un programa no fue modificado.

---

[üîº](#√≠ndice)

---

## **428. Diffie Hellman: Intercambio de claves**

### üîê ¬øQu√© es Diffie-Hellman?

El **intercambio de claves Diffie-Hellman** es un **protocolo criptogr√°fico** que permite a **dos partes** (por ejemplo, Alicia y Bob) acordar **una clave secreta compartida**, **sin necesidad de enviarla directamente** por el canal inseguro.

> üìå Importante: **Diffie-Hellman no cifra mensajes directamente.** Solo sirve para **acordar una clave secreta** que luego se puede usar para cifrar comunicaciones con algoritmos sim√©tricos como AES.

---

### üß† ¬øPor qu√© es √∫til?

Imagina que Alicia y Bob quieren hablar de forma segura por internet. No tienen una clave previa. Usando Diffie-Hellman, pueden generar **cada uno una parte del secreto**, intercambiar valores **p√∫blicos**, y a√∫n as√≠ **terminar con la misma clave secreta**.

---

### üßÆ Ejemplo f√°cil con colores (met√°fora visual)

1. Ambos eligen un **color p√∫blico base** (como el n√∫mero primo `p`) y una **t√©cnica de mezcla** (como la base `g`).
2. Alicia elige un **color secreto privado** (clave privada `a`) y mezcla.
3. Bob tambi√©n elige uno.
4. Ambos **intercambian sus mezclas** (valores p√∫blicos).
5. Cada uno mezcla lo recibido con su secreto privado.
6. ¬°Ambos obtienen el mismo color final (clave secreta)!

---

### üìê Parte matem√°tica real

Se basa en la **aritm√©tica modular**.

#### Par√°metros p√∫blicos:

- `p`: n√∫mero primo grande
- `g`: generador (n√∫mero menor que `p`)

#### Cada parte:

- Elige un n√∫mero secreto:

  - Alicia: `a`
  - Bob: `b`

- Calcula:

  - Alicia env√≠a `A = g^a mod p`
  - Bob env√≠a `B = g^b mod p`

- Ambos calculan la clave compartida:

  - Alicia: `s = B^a mod p`
  - Bob: `s = A^b mod p`

- Ambos obtienen el **mismo resultado `s`**.

---

### üõ†Ô∏è ¬øC√≥mo se instala?

Usaremos Python con la biblioteca `cryptography`, que ya viene con soporte para **Diffie-Hellman**.

#### ‚úÖ Instalaci√≥n

```bash
pip install cryptography
```

---

### üß™ Ejemplo completo en Python (paso a paso)

```python
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF

# 1. Generar par√°metros (esto ser√≠a p√∫blico: p y g)
parametros = dh.generate_parameters(generator=2, key_size=2048)

# 2. Cada parte genera su clave privada y p√∫blica
# ALICE
clave_privada_alice = parametros.generate_private_key()
clave_publica_alice = clave_privada_alice.public_key()

# BOB
clave_privada_bob = parametros.generate_private_key()
clave_publica_bob = clave_privada_bob.public_key()

# 3. Cada parte genera la clave compartida
clave_compartida_alice = clave_privada_alice.exchange(clave_publica_bob)
clave_compartida_bob = clave_privada_bob.exchange(clave_publica_alice)

# 4. Usamos HKDF para derivar una clave sim√©trica segura a partir de la compartida
def derivar_clave(clave_compartida):
    return HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=None,
        info=b'intercambio de claves DH',
    ).derive(clave_compartida)

clave_simetrica_alice = derivar_clave(clave_compartida_alice)
clave_simetrica_bob = derivar_clave(clave_compartida_bob)

# 5. Verificamos que ambas claves coincidan
print("¬øClaves coinciden?:", clave_simetrica_alice == clave_simetrica_bob)
print("Clave secreta compartida (hex):", clave_simetrica_alice.hex())
```

---

### üìå ¬øQu√© logramos?

Ambas partes (Alicia y Bob):

‚úÖ Generaron una clave secreta compartida sin necesidad de enviarla directamente

‚úÖ Esa clave ahora puede usarse para cifrar informaci√≥n (ej. con AES)

‚úÖ Si un atacante observa todo el intercambio, **no puede calcular la clave secreta** (esto se basa en el problema del logaritmo discreto)

---

### üß± Resumen Visual

```text
   Paso            Alicia                  Bob
   ----           -------                -------
    1        Clave privada: a         Clave privada: b
    2        Calcula A = g^a mod p    Calcula B = g^b mod p
    3        Envia A a Bob            Envia B a Alicia
    4        Calcula s = B^a mod p    Calcula s = A^b mod p
           => Clave compartida secreta s (misma para ambos)
```

---

### üõë Limitaciones

- No tiene autenticaci√≥n por s√≠ solo (puede ser vulnerable a "man-in-the-middle").
- Se combina normalmente con **firmas digitales** para autenticar a las partes (como en TLS).

---

[üîº](#√≠ndice)

---

## **429. RSA**

### üîê ¬øQu√© es RSA?

**RSA** es un algoritmo de **criptograf√≠a asim√©trica**. Se usa para:

- **Cifrado**: Proteger mensajes con una clave p√∫blica.
- **Firmas digitales**: Validar la identidad del remitente con una clave privada.

#### üìå ¬øQu√© significa asim√©trica?

Significa que usa **dos claves diferentes**:

- üîì **Clave p√∫blica**: Se comparte con todos. Sirve para cifrar.
- üîí **Clave privada**: Se guarda en secreto. Sirve para descifrar.

> Si alguien cifra con tu clave p√∫blica, **solo t√∫** puedes descifrarlo con tu clave privada.
>
> Si t√∫ firmas algo con tu clave privada, **todos pueden verificarlo** con tu clave p√∫blica.

---

### üß† ¬øC√≥mo funciona RSA (en sencillo)?

RSA se basa en **matem√°ticas con n√∫meros primos muy grandes**. Aqu√≠ est√°n los pasos principales:

#### 1. Generar claves

- Se eligen dos n√∫meros primos grandes `p` y `q`.
- Se calcula `n = p * q`.
- Se calcula `œÜ(n) = (p - 1) * (q - 1)`.
- Se elige un n√∫mero `e` (clave p√∫blica) que no tenga factores comunes con `œÜ(n)`.
- Se calcula `d` (clave privada), tal que:
  `d * e ‚â° 1 (mod œÜ(n))`

#### 2. Claves

- Clave **p√∫blica**: `(e, n)`
- Clave **privada**: `(d, n)`

#### 3. Cifrado

Para cifrar un n√∫mero `m`:

```text
c = m^e mod n
```

#### 4. Descifrado

Para descifrar `c`:

```text
m = c^d mod n
```

---

### üßÆ Ejemplo num√©rico miniatura (muy peque√±o)

#### 1. Elegimos primos:

```text
p = 3, q = 11 ‚Üí n = 33
œÜ(n) = (3-1)(11-1) = 20
```

#### 2. Elegimos `e = 3` (debe ser primo con 20)

#### 3. Calculamos `d` tal que:

```text
d * 3 ‚â° 1 mod 20 ‚Üí d = 7
```

#### 4. Claves:

- P√∫blica: `(e=3, n=33)`
- Privada: `(d=7, n=33)`

#### 5. Cifrado de `m=4`:

```text
c = 4^3 mod 33 = 64 mod 33 = 31
```

#### 6. Descifrado:

```text
m = 31^7 mod 33 = 4
```

‚úÖ ¬°Se recupera el mensaje original!

---

### ‚öôÔ∏è Instalaci√≥n en Python

Vamos a usar `cryptography` o `PyCryptodome`.

#### Opci√≥n 1: `cryptography`

```bash
pip install cryptography
```

#### Opci√≥n 2: `pycryptodome` (alternativa potente)

```bash
pip install pycryptodome
```

---

### üß™ Ejemplo completo con `cryptography` (moderno y seguro)

```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes

# 1. Generar par de claves
clave_privada = rsa.generate_private_key(public_exponent=65537, key_size=2048)
clave_publica = clave_privada.public_key()

# 2. Mensaje a cifrar
mensaje = b"Hola mundo secreto"

# 3. Cifrar con la clave p√∫blica
mensaje_cifrado = clave_publica.encrypt(
    mensaje,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

# 4. Descifrar con la clave privada
mensaje_descifrado = clave_privada.decrypt(
    mensaje_cifrado,
    padding.OAEP(
        mgf=padding.MGF1(algorithm=hashes.SHA256()),
        algorithm=hashes.SHA256(),
        label=None
    )
)

# 5. Mostrar resultados
print("Mensaje original:", mensaje)
print("Cifrado (hex):", mensaje_cifrado.hex())
print("Descifrado:", mensaje_descifrado)
```

---

### üìå Resumen Visual

```text
              CLAVE P√öBLICA (e, n)               CLAVE PRIVADA (d, n)
                      ‚Üì                                   ‚Üì
Emisor cifra:    c = m^e mod n         Receptor descifra: m = c^d mod n
```

---

### üîê ¬øPara qu√© se usa RSA?

‚úÖ Intercambio seguro de claves (ej: en HTTPS/TLS)

‚úÖ Firmas digitales (validar identidad)

‚úÖ Autenticaci√≥n en tokens (como JWT en web)

‚úÖ Encriptaci√≥n de mensajes peque√±os o claves

---

### üõë Limitaciones

- Lento para mensajes grandes (por eso se usa solo para **intercambiar claves**, no para cifrar archivos completos)
- Vulnerable si se usan claves peque√±as o sin padding
- Siempre debe usarse con padding seguro como **OAEP** o **PSS**

---

[üîº](#√≠ndice)

---

## **430. Generando un par de claves RSA con OpenSSL**

### üîê ¬øQu√© es un par de claves RSA?

En criptograf√≠a **RSA**, usamos dos claves:

- üîì **Clave p√∫blica**: Para cifrar o verificar firmas.
- üîí **Clave privada**: Para descifrar o firmar datos.

El par de claves se genera al mismo tiempo, y est√°n matem√°ticamente relacionadas, pero es imposible (pr√°cticamente) obtener la clave privada solo con la p√∫blica.

---

### üß∞ ¬øQu√© es OpenSSL?

**OpenSSL** es una herramienta de l√≠nea de comandos de c√≥digo abierto que permite hacer operaciones de criptograf√≠a como:

- Generar claves (RSA, ECC, etc.)
- Cifrar y descifrar mensajes
- Crear certificados digitales
- Firmar archivos
- Verificar firmas

---

### ‚öôÔ∏è C√≥mo instalar OpenSSL

#### En Windows

1. Ve a: [https://slproweb.com/products/Win32OpenSSL.html](https://slproweb.com/products/Win32OpenSSL.html)
2. Descarga e instala **Win64 OpenSSL** o **Win32 OpenSSL** (seg√∫n tu sistema).
3. Durante la instalaci√≥n, selecciona la opci√≥n que agregue OpenSSL al PATH.

Luego, abre la terminal `cmd` o PowerShell y escribe:

```bash
openssl version
```

Debe salir algo como:

```
OpenSSL 3.x.x ...
```

---

#### En Linux (Ubuntu/Debian)

```bash
sudo apt update
sudo apt install openssl
```

#### En macOS

```bash
brew install openssl
```

---

### üõ†Ô∏è Generando un par de claves RSA

Vamos a usar la terminal paso a paso.

---

#### ‚úÖ Paso 1: Generar clave privada

```bash
openssl genpkey -algorithm RSA -out clave_privada.pem -pkeyopt rsa_keygen_bits:2048
```

Esto genera una clave privada de 2048 bits y la guarda en `clave_privada.pem`.

üìå **Nota:** Puedes usar 4096 bits para m√°s seguridad (pero es m√°s lento).

---

#### ‚úÖ Paso 2: Extraer clave p√∫blica desde la privada

```bash
openssl rsa -pubout -in clave_privada.pem -out clave_publica.pem
```

Esto lee la clave privada y genera la clave p√∫blica correspondiente en `clave_publica.pem`.

---

#### ‚úÖ Paso 3 (opcional): Ver el contenido de las claves

**Clave privada:**

```bash
openssl pkey -in clave_privada.pem -text -noout
```

**Clave p√∫blica:**

```bash
openssl pkey -pubin -in clave_publica.pem -text -noout
```

---

### üì¶ Archivos generados

- `clave_privada.pem` ‚Üí contiene la clave **privada**
- `clave_publica.pem` ‚Üí contiene la clave **p√∫blica**

Estos archivos est√°n codificados en formato **PEM** (texto Base64), que es compatible con muchos sistemas.

---

### üß™ Ejemplo completo: Cifrar y descifrar un mensaje

#### Paso 1: Crear un mensaje de prueba

```bash
echo "Este es un mensaje secreto" > mensaje.txt
```

---

#### Paso 2: Cifrar el mensaje con la **clave p√∫blica**

```bash
openssl pkeyutl -encrypt -in mensaje.txt -pubin -inkey clave_publica.pem -out mensaje_cifrado.bin
```

Esto crea un archivo binario cifrado `mensaje_cifrado.bin`.

---

#### Paso 3: Descifrar con la **clave privada**

```bash
openssl pkeyutl -decrypt -in mensaje_cifrado.bin -inkey clave_privada.pem -out mensaje_descifrado.txt
```

---

#### Paso 4: Leer el mensaje descifrado

```bash
cat mensaje_descifrado.txt
```

Deber√≠as ver:

```
Este es un mensaje secreto
```

‚úÖ ¬°Mensaje cifrado y descifrado correctamente con RSA y OpenSSL!

---

### üìå Resumen

| Acci√≥n                | Comando                                                                |
| --------------------- | ---------------------------------------------------------------------- |
| Generar clave privada | `openssl genpkey -algorithm RSA -out clave_privada.pem`                |
| Extraer clave p√∫blica | `openssl rsa -pubout -in clave_privada.pem -out clave_publica.pem`     |
| Cifrar mensaje        | `openssl pkeyutl -encrypt -pubin -inkey clave_publica.pem -in msg.txt` |
| Descifrar mensaje     | `openssl pkeyutl -decrypt -inkey clave_privada.pem -in msg_cifrado`    |

---

[üîº](#√≠ndice)

---

## **431. Curvas el√≠pticas**

### üîç ¬øQu√© son las curvas el√≠pticas?

En criptograf√≠a, las **curvas el√≠pticas** no son "curvas el√≠pticas" como elipses comunes, sino **curvas definidas por una ecuaci√≥n algebraica espec√≠fica** que tiene una forma como esta:

$$
y^2 = x^3 + ax + b
$$

üìå Estas curvas est√°n definidas sobre un conjunto finito (un campo), como los n√∫meros m√≥dulo un primo (por ejemplo, $\mathbb{F}_p$).

---

#### üéØ ¬øPor qu√© se usan en criptograf√≠a?

Las curvas el√≠pticas se usan porque permiten crear sistemas criptogr√°ficos:

- Muy seguros
- Con **claves mucho m√°s peque√±as** que RSA
- R√°pidos en dispositivos con poca potencia (tel√©fonos, tarjetas inteligentes)

> üìä Por ejemplo: ECC con 256 bits ‚âà seguridad de RSA con 3072 bits.

---

### üß† ¬øC√≥mo se usa una curva el√≠ptica para criptograf√≠a?

Se basa en un problema dif√≠cil: el **Problema del Logaritmo Discreto en Curvas El√≠pticas (ECDLP)**.

#### En palabras simples:

1. Se escoge un **punto base G** en la curva.
2. El usuario elige un n√∫mero secreto **k**.
3. Luego, se multiplica:

   $$
   P = k \cdot G
   $$

   Donde $P$ es **p√∫blico**, y $k$ es la **clave privada**.

üîê Calcular $P$ es f√°cil, pero dado $P$ y $G$, encontrar $k$ es pr√°cticamente imposible.

---

### üß∞ Herramientas para trabajar con ECC

La mayor√≠a de herramientas modernas ya soportan criptograf√≠a de curvas el√≠pticas.

Usaremos:

#### üü¶ OpenSSL

Para generar claves, firmar y verificar con ECC.

---

### ‚öôÔ∏è Instalaci√≥n de OpenSSL (si a√∫n no lo tienes)

#### En Ubuntu/Debian

```bash
sudo apt update
sudo apt install openssl
```

#### En Windows

- Ve a [https://slproweb.com/products/Win32OpenSSL.html](https://slproweb.com/products/Win32OpenSSL.html)
- Descarga e instala la versi√≥n recomendada.
- Agrega OpenSSL al **PATH** para usarlo desde la terminal (`cmd` o PowerShell).

---

### üõ†Ô∏è Ejemplo completo: ECC en OpenSSL

#### ‚úÖ Paso 1: Generar una clave privada ECC

Usaremos la curva `prime256v1` (muy com√∫n).

```bash
openssl ecparam -name prime256v1 -genkey -noout -out ecc_priv.pem
```

Esto crea una clave privada ECC en el archivo `ecc_priv.pem`.

---

#### ‚úÖ Paso 2: Generar la clave p√∫blica

```bash
openssl ec -in ecc_priv.pem -pubout -out ecc_pub.pem
```

Esto genera la clave p√∫blica a partir de la clave privada.

---

#### ‚úÖ Paso 3: Crear un mensaje a firmar

```bash
echo "Este es un mensaje firmado con ECC" > mensaje.txt
```

---

#### ‚úÖ Paso 4: Firmar el mensaje con la clave privada

```bash
openssl dgst -sha256 -sign ecc_priv.pem -out firma.bin mensaje.txt
```

Esto genera una **firma binaria** del archivo `mensaje.txt`.

---

#### ‚úÖ Paso 5: Verificar la firma con la clave p√∫blica

```bash
openssl dgst -sha256 -verify ecc_pub.pem -signature firma.bin mensaje.txt
```

Resultado esperado:

```
Verified OK
```

---

### üì¶ Archivos generados

- `ecc_priv.pem`: Clave privada ECC
- `ecc_pub.pem`: Clave p√∫blica ECC
- `mensaje.txt`: Mensaje a firmar
- `firma.bin`: Firma digital del mensaje

---

### üìå Comparaci√≥n r√°pida: ECC vs RSA

| Caracter√≠stica        | RSA (2048 bits) | ECC (256 bits)                        |
| --------------------- | --------------- | ------------------------------------- |
| Seguridad equivalente | 112 bits        | 112 bits                              |
| Tama√±o de clave       | Grande          | Mucho m√°s peque√±a                     |
| Rendimiento           | Lento           | R√°pido                                |
| Uso recomendado       | General         | Ideal para dispositivos m√≥viles o IoT |

---

### üß† En resumen

- ECC usa operaciones matem√°ticas sobre curvas para crear claves.
- Es tan seguro como RSA, pero con **menos consumo de recursos**.
- Herramientas como **OpenSSL** permiten generar claves, firmar y verificar f√°cilmente.

---

[üîº](#√≠ndice)

---

## **432. Computaci√≥n cu√°ntica: Un viaje hacia una nueva era en la criptograf√≠a**

![Computaci√≥n cu√°ntica](../img/6_Ciberseguridad_Defensiva/Computacion_cuantica.avif "Computaci√≥n cu√°ntica")

### üåê 1. Introducci√≥n sencilla: ¬øQu√© es la computaci√≥n cu√°ntica?

La **computaci√≥n cu√°ntica** es una nueva forma de procesar informaci√≥n **usando las leyes de la f√≠sica cu√°ntica**. A diferencia de las computadoras tradicionales (cl√°sicas) que usan bits (0 o 1), las computadoras cu√°nticas usan **qubits**, que pueden estar en **0, 1 o ambos a la vez** gracias a algo llamado **superposici√≥n**.

---

#### üß† Conceptos clave:

- **Qubit**: Unidad b√°sica de la computaci√≥n cu√°ntica (como el bit cl√°sico, pero m√°s poderoso).
- **Superposici√≥n**: Un qubit puede representar 0 y 1 al mismo tiempo.
- **Entrelazamiento (entanglement)**: Qubits que est√°n conectados de manera que lo que le pase a uno afecta al otro.
- **Interferencia**: Los resultados no deseados pueden "cancelarse" y reforzar los que s√≠ queremos.

---

### üîê 2. ¬øQu√© tiene que ver esto con la criptograf√≠a?

¬°Mucho!

La criptograf√≠a moderna (como RSA, ECC, Diffie-Hellman) **depende de que ciertos c√°lculos sean dif√≠ciles para una computadora cl√°sica**. Por ejemplo:

- **RSA**: Dif√≠cil factorizar n√∫meros muy grandes.
- **ECC**: Dif√≠cil resolver logaritmos discretos en curvas el√≠pticas.

Sin embargo, **una computadora cu√°ntica suficientemente potente puede romper estos sistemas** con algoritmos cu√°nticos especiales.

---

#### üìâ Criptograf√≠a vulnerable con computaci√≥n cu√°ntica

| Algoritmo cl√°sico | Algoritmo cu√°ntico que lo rompe        | ¬øSeguridad en peligro? |
| ----------------- | -------------------------------------- | ---------------------- |
| RSA               | **Shor** (factorizaci√≥n)               | ‚ùå S√≠                  |
| Diffie-Hellman    | **Shor**                               | ‚ùå S√≠                  |
| ECC               | **Shor**                               | ‚ùå S√≠                  |
| AES / Sym√©tricos  | **Grover** (reducci√≥n de fuerza bruta) | ‚ö†Ô∏è Parcialmente        |

üîê **AES**, aunque es afectado, **no est√° roto**, solo hay que **doblar el tama√±o de la clave** para mantener la seguridad.

---

### üß™ 3. ¬øQu√© es la criptograf√≠a post-cu√°ntica?

Es una rama de la criptograf√≠a que **dise√±a algoritmos resistentes a ataques cu√°nticos**. Se basa en problemas matem√°ticos que no pueden resolverse eficientemente, ni siquiera con una computadora cu√°ntica.

üìå Algunos candidatos:

- **Lattice-based** (basado en ret√≠culos): como Kyber, NTRU
- **Code-based**: como McEliece
- **Hash-based**: como SPHINCS+
- **Multivariable**: basados en polinomios

üí° **NIST (EE.UU.)** ya est√° estandarizando criptograf√≠a post-cu√°ntica (PQCrypto).

---

### ‚öôÔ∏è 4. ¬øC√≥mo experimentar con criptograf√≠a cu√°ntica o post-cu√°ntica?

#### üîß Instalaci√≥n y uso (con ejemplo)

Usaremos la biblioteca **`pqcrypto`** en Python para probar algoritmos post-cu√°nticos.

#### ‚úÖ Requisitos:

- Python 3.8+
- pip

---

#### üõ†Ô∏è Instalaci√≥n:

```bash
pip install pqcrypto
```

---

#### üë®‚Äçüíª Ejemplo completo: Cifrado con Kyber512 (post-cu√°ntico)

```python
from pqcrypto.kem.kyber512 import generate_keypair, encrypt, decrypt

# Generar par de claves
public_key, secret_key = generate_keypair()

# Simular env√≠o de clave secreta
ciphertext, shared_secret_enc = encrypt(public_key)

# Receptor descifra el mensaje
shared_secret_dec = decrypt(ciphertext, secret_key)

# Mostrar resultados
print("Clave secreta cifrada:", shared_secret_enc.hex())
print("Clave secreta descifrada:", shared_secret_dec.hex())
print("¬øCoinciden?:", shared_secret_enc == shared_secret_dec)
```

---

üîç Este ejemplo demuestra **c√≥mo un emisor y receptor** pueden compartir una clave secreta de forma segura usando un algoritmo resistente a ataques cu√°nticos.

---

### üöÄ 5. ¬øEn qu√© estado est√° la computaci√≥n cu√°ntica hoy?

üîπ Las computadoras cu√°nticas **ya existen**, pero con pocos qubits y muy **ruidosas**.
üîπ Empresas como IBM, Google, Microsoft y startups cu√°nticas est√°n desarroll√°ndolas.
üîπ Todav√≠a no pueden romper RSA, pero **en 10‚Äì20 a√±os**, podr√≠an hacerlo.

---

### üß≠ 6. ¬øQu√© debemos hacer ahora?

- **Adoptar criptograf√≠a post-cu√°ntica** poco a poco (por ejemplo, en nuevas aplicaciones).
- **Hacer auditor√≠as de sistemas actuales** que dependen de RSA o ECC.
- Estar informados sobre los est√°ndares del NIST.

---

### üß† En resumen:

| T√©rmino              | Explicaci√≥n f√°cil                                |
| -------------------- | ------------------------------------------------ |
| Computadora cu√°ntica | Usa f√≠sica cu√°ntica para c√°lculos incre√≠bles     |
| Qubit                | Bit cu√°ntico que puede ser 0 y 1 al mismo tiempo |
| Shor                 | Algoritmo que rompe RSA, ECC                     |
| Grover               | Acelera fuerza bruta, afecta AES                 |
| Criptograf√≠a PQ      | Dise√±ada para resistir ataques cu√°nticos         |

---

[üîº](#√≠ndice)

---

| **Inicio**         | **atr√°s 2**                                               | **Siguiente 4**                                         |
| ------------------ | --------------------------------------------------------- | ------------------------------------------------------- |
| [üè†](../README.md) | [‚è™](./6_2_Criptografia_y_Ciberseguridad_Introduccion.md) | [‚è©](./6_4_CiberSeguridad_de_los_datos_Data_Scurity.md) |
